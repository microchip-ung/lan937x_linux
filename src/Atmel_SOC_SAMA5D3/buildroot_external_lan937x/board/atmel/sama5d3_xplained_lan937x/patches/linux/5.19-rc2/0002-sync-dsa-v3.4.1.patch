From d7834407c3c9130f11b8989bc6efa8adcabe133e Mon Sep 17 00:00:00 2001
From: Rakesh <rakesh.sankaranarayanan@microchip.com>
Date: Mon, 27 Jun 2022 16:25:03 +0530
Subject: [PATCH 2/5] sync dsa v3.4.1

---
 drivers/net/dsa/microchip/Kconfig           |   30 +
 drivers/net/dsa/microchip/Makefile          |   17 +
 drivers/net/dsa/microchip/ksz_common.c      |    9 +
 drivers/net/dsa/microchip/ksz_common.h      |   46 +
 drivers/net/dsa/microchip/lan937x_acl.c     |  967 +++++++++++
 drivers/net/dsa/microchip/lan937x_acl.h     |  490 ++++++
 drivers/net/dsa/microchip/lan937x_dev.c     |  852 ++++++++++
 drivers/net/dsa/microchip/lan937x_dev.h     |  125 ++
 drivers/net/dsa/microchip/lan937x_devlink.c |  167 ++
 drivers/net/dsa/microchip/lan937x_devlink.h |   19 +
 drivers/net/dsa/microchip/lan937x_flower.c  | 1299 +++++++++++++++
 drivers/net/dsa/microchip/lan937x_flower.h  |  240 +++
 drivers/net/dsa/microchip/lan937x_main.c    | 1588 +++++++++++++++++++
 drivers/net/dsa/microchip/lan937x_ptp.c     | 1250 +++++++++++++++
 drivers/net/dsa/microchip/lan937x_ptp.h     |   74 +
 drivers/net/dsa/microchip/lan937x_reg.h     | 1104 +++++++++++++
 drivers/net/dsa/microchip/lan937x_spi.c     |  122 ++
 drivers/net/dsa/microchip/lan937x_tas.c     |  131 ++
 drivers/net/dsa/microchip/lan937x_tas.h     |   21 +
 drivers/net/dsa/microchip/lan937x_tc.c      |  117 ++
 drivers/net/dsa/microchip/lan937x_tc.h      |   17 +
 include/linux/dsa/ksz_common.h              |   71 +
 include/net/dsa.h                           |    6 +
 net/dsa/tag_ksz.c                           |  241 ++-
 24 files changed, 8998 insertions(+), 5 deletions(-)
 create mode 100644 drivers/net/dsa/microchip/lan937x_acl.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_acl.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_dev.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_dev.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_devlink.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_devlink.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_flower.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_flower.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_main.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_ptp.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_ptp.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_reg.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_spi.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_tas.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_tas.h
 create mode 100644 drivers/net/dsa/microchip/lan937x_tc.c
 create mode 100644 drivers/net/dsa/microchip/lan937x_tc.h
 create mode 100644 include/linux/dsa/ksz_common.h

diff --git a/drivers/net/dsa/microchip/Kconfig b/drivers/net/dsa/microchip/Kconfig
index c9e2a8989556..537782bdaee9 100644
--- a/drivers/net/dsa/microchip/Kconfig
+++ b/drivers/net/dsa/microchip/Kconfig
@@ -3,6 +3,36 @@ config NET_DSA_MICROCHIP_KSZ_COMMON
 	select NET_DSA_TAG_KSZ
 	tristate
 
+config NET_DSA_MICROCHIP_LAN937X
+	tristate "Microchip LAN937X series SPI connected switch support"
+	depends on NET_DSA && SPI
+	select NET_DSA_MICROCHIP_KSZ_COMMON
+	select REGMAP_SPI
+	help
+	  This driver adds support for Microchip LAN937X series
+	  switch chips.
+
+	  Select to enable support for registering switches configured
+	  through SPI.
+
+config NET_DSA_MICROCHIP_LAN937X_PTP
+	bool "Support for the PTP clock on the LAN937x Ethernet Switch"
+	depends on NET_DSA_MICROCHIP_LAN937X
+	depends on PTP_1588_CLOCK
+	help
+		This enables support for timestamping & PTP clock manipulation in the 
+		LAN937x Ethernet switch
+
+config NET_DSA_MICROCHIP_LAN937X_TAS
+	bool "Support for the Time-Aware Scheduler on LAN937x Ethernet Switch"
+	depends on NET_DSA_MICROCHIP_LAN937X && NET_SCH_TAPRIO
+	depends on NET_SCH_TAPRIO=y || NET_DSA_MICROCHIP_LAN937X=m
+	depends on NET_DSA_MICROCHIP_LAN937X_PTP
+	help
+	  This enables support for the Time aware scheduler in LAN937x DSA
+	  Driver, which is controlled using a hardware offload of the
+	  tc-tqprio qdisc.
+
 menuconfig NET_DSA_MICROCHIP_KSZ9477
 	tristate "Microchip KSZ9477 series switch support"
 	depends on NET_DSA
diff --git a/drivers/net/dsa/microchip/Makefile b/drivers/net/dsa/microchip/Makefile
index 2a03b21a3386..1da51546be51 100644
--- a/drivers/net/dsa/microchip/Makefile
+++ b/drivers/net/dsa/microchip/Makefile
@@ -6,3 +6,20 @@ obj-$(CONFIG_NET_DSA_MICROCHIP_KSZ9477_SPI)	+= ksz9477_spi.o
 obj-$(CONFIG_NET_DSA_MICROCHIP_KSZ8795)		+= ksz8795.o
 obj-$(CONFIG_NET_DSA_MICROCHIP_KSZ8795_SPI)	+= ksz8795_spi.o
 obj-$(CONFIG_NET_DSA_MICROCHIP_KSZ8863_SMI)	+= ksz8863_smi.o
+
+obj-$(CONFIG_NET_DSA_MICROCHIP_LAN937X)		+= lan937x.o
+lan937x-objs := lan937x_dev.o
+lan937x-objs += lan937x_main.o
+lan937x-objs += lan937x_spi.o
+lan937x-objs += lan937x_tc.o
+lan937x-objs += lan937x_devlink.o
+
+ifdef CONFIG_NET_DSA_MICROCHIP_LAN937X_PTP
+lan937x-objs += lan937x_ptp.o
+endif
+
+ifdef CONFIG_NET_DSA_MICROCHIP_LAN937X_TAS
+lan937x-objs += lan937x_tas.o
+endif
+lan937x-objs += lan937x_flower.o
+lan937x-objs += lan937x_acl.o
diff --git a/drivers/net/dsa/microchip/ksz_common.c b/drivers/net/dsa/microchip/ksz_common.c
index 9ca8c8d7740f..adb53ff70ff6 100644
--- a/drivers/net/dsa/microchip/ksz_common.c
+++ b/drivers/net/dsa/microchip/ksz_common.c
@@ -20,6 +20,7 @@
 #include <net/switchdev.h>
 
 #include "ksz_common.h"
+#include "lan937x_flower.h"
 
 #define MIB_COUNTER_NUM 0x20
 
@@ -1021,6 +1022,14 @@ int ksz_switch_register(struct ksz_device *dev,
 				     GFP_KERNEL);
 		if (!dev->ports[i].mib.counters)
 			return -ENOMEM;
+
+		dev->ports[i].priv =
+			devm_kzalloc(dev->dev,
+				     sizeof(struct lan937x_flr_blk),
+				     GFP_KERNEL);
+
+		if (!dev->ports[i].priv)
+			return -ENOMEM;
 	}
 
 	/* set the real number of ports */
diff --git a/drivers/net/dsa/microchip/ksz_common.h b/drivers/net/dsa/microchip/ksz_common.h
index 8500eaedad67..36de77fa64a5 100644
--- a/drivers/net/dsa/microchip/ksz_common.h
+++ b/drivers/net/dsa/microchip/ksz_common.h
@@ -7,6 +7,8 @@
 #ifndef __KSZ_COMMON_H
 #define __KSZ_COMMON_H
 
+#include <linux/dsa/ksz_common.h>
+#include <linux/ptp_clock_kernel.h>
 #include <linux/etherdevice.h>
 #include <linux/kernel.h>
 #include <linux/mutex.h>
@@ -14,6 +16,10 @@
 #include <linux/regmap.h>
 #include <net/dsa.h>
 
+enum ksz_ptp_tou_mode {
+       KSZ_PTP_TOU_IDLE,
+       KSZ_PTP_TOU_PPS
+};
 #define KSZ_MAX_NUM_PORTS 8
 
 struct vlan_table {
@@ -68,6 +74,22 @@ struct ksz_port {
 	struct ksz_port_mib mib;
 	phy_interface_t interface;
 	u16 max_frame;
+
+       void * priv;
+
+#if IS_ENABLED(CONFIG_NET_DSA_MICROCHIP_LAN937X_PTP)
+       bool hwts_tx_en;
+        struct lan937x_port_ptp_shared ptp_shared;
+        ktime_t tstamp_sync;
+       struct completion tstamp_sync_comp;
+        ktime_t tstamp_pdelayreq;
+       struct completion tstamp_pdelayreq_comp;
+        ktime_t tstamp_pdelayrsp;
+       struct completion tstamp_pdelayrsp_comp;
+#endif
+       u32 rgmii_tx_val;
+       u32 rgmii_rx_val;
+
 };
 
 struct ksz_device {
@@ -85,12 +107,15 @@ struct ksz_device {
 	struct regmap *regmap[3];
 
 	void *priv;
+	int irq;
 
 	struct gpio_desc *reset_gpio;	/* Optional reset GPIO */
 
 	/* chip specific data */
 	u32 chip_id;
 	int cpu_port;			/* port connected to CPU */
+	int dsa_port;
+	int smi_index;
 	int phy_port_cnt;
 	phy_interface_t compat_interface;
 	bool synclko_125;
@@ -105,6 +130,17 @@ struct ksz_device {
 	u16 mirror_tx;
 	u32 features;			/* chip specific features */
 	u16 port_mask;
+
+	u8 tas_port;
+       u16 cut_through_enable;
+#if IS_ENABLED(CONFIG_NET_DSA_MICROCHIP_LAN937X_PTP)
+       struct ptp_clock_info ptp_caps;
+       struct ptp_clock *ptp_clock;
+       struct mutex ptp_mutex;  //to serialize the activity in the phc
+       struct ksz_device_ptp_shared ptp_shared;
+       enum ksz_ptp_tou_mode ptp_tou_mode;
+#endif
+
 };
 
 /* List of supported models */
@@ -194,6 +230,9 @@ void ksz_switch_remove(struct ksz_device *dev);
 
 int ksz8_switch_register(struct ksz_device *dev);
 int ksz9477_switch_register(struct ksz_device *dev);
+int lan937x_switch_register(struct ksz_device *dev);
+
+int lan937x_check_device_id(struct ksz_device *dev);
 
 void ksz_update_port_member(struct ksz_device *dev, int port);
 void ksz_init_mib_timer(struct ksz_device *dev);
@@ -300,6 +339,13 @@ static inline int ksz_write64(struct ksz_device *dev, u32 reg, u64 value)
 	return regmap_bulk_write(dev->regmap[2], reg, val, 2);
 }
 
+static inline int ksz_write8_bulk(struct ksz_device *dev, u32 reg, u8 *value,
+				  u8 n)
+{
+       return regmap_bulk_write(dev->regmap[0], reg, value, n);
+}
+
+
 static inline void ksz_pread8(struct ksz_device *dev, int port, int offset,
 			      u8 *data)
 {
diff --git a/drivers/net/dsa/microchip/lan937x_acl.c b/drivers/net/dsa/microchip/lan937x_acl.c
new file mode 100644
index 000000000000..4f96e65a27f8
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_acl.c
@@ -0,0 +1,967 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip lan937x dev ops functions
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#include <net/dsa.h>
+#include <net/switchdev.h>
+#include "ksz_common.h"
+#include "lan937x_reg.h"
+#include "lan937x_dev.h"
+#include "lan937x_tc.h"
+#include "lan937x_flower.h"
+#include "lan937x_acl.h"
+
+static const u8 parser_key_format[MAX_ACL_PARSER] = {
+	[PARSER_IDX_0] = PARSER_MULTI_KEY_FORMAT,
+	[PARSER_IDX_1] = PARSER_UNIVERSAL_FORMAT,
+	[PARSER_IDX_2] = PARSER_MULTI_KEY_FORMAT,
+	[PARSER_IDX_3] = PARSER_UNIVERSAL_FORMAT
+};
+
+static const struct lan937x_acl_rfr acl_rfrs_table[MAX_ACL_PARSER][MAX_RFR] = {
+	[PARSER_IDX_0] = {
+		[RFR_IDX_0] = {
+			.dissectors_covered = DST_MAC_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 0,
+			.len = 6,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_1] = {
+			.dissectors_covered = SRC_MAC_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 6,
+			.len = 6,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_2] = {
+			.dissectors_covered = ETHTYPE_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 12,
+			.len = 2,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_3] = {
+			.dissectors_covered = IPV4_TOS_DISSECTOR_PRESENT,
+			.layer = l3,
+			.ofst = 0,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_4] = {
+			.dissectors_covered = (IPV4_TTL_DISSECTOR_PRESENT |
+					       IPV4_PROTO_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 8,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_5] = {
+			.dissectors_covered = (IPV4_SRC_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 12,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_6] = {
+			.dissectors_covered = (IPV4_DST_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 16,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_7] = {
+			.dissectors_covered = (L4_SRC_PORT_DISSECTOR_PRESENT),
+			.layer = l4,
+			.ofst = 0,
+			.len = 2,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_8] = {
+			.dissectors_covered = (L4_DST_PORT_DISSECTOR_PRESENT),
+			.layer = l4,
+			.ofst = 2,
+			.len = 2,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_9] = {
+			.dissectors_covered = 0,
+		},
+	},
+	[PARSER_IDX_1] = {
+		[RFR_IDX_0] = {
+			.dissectors_covered = IPV6_TC_DISSECTOR_PRESENT,
+			.layer = l3,
+			.ofst = 0,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_1] = {
+			.dissectors_covered = (IPV6_HOP_DISSECTOR_PRESENT |
+					       IPV6_NXTHDR_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 4,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_2] = {
+			.dissectors_covered = (IPV6_SRC_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 8,
+			.len = 16,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_3] = {
+			.dissectors_covered = (IPV6_DST_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 24,
+			.len = 16,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_4] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_5] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_6] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_7] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_8] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_9] = {
+			.dissectors_covered = 0,
+		},
+	},
+	[PARSER_IDX_2] = {
+		[RFR_IDX_0] = {
+			.dissectors_covered = DST_MAC_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 0,
+			.len = 6,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_1] = {
+			.dissectors_covered = SRC_MAC_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 6,
+			.len = 6,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_2] = {
+			.dissectors_covered = VLAN_TAG_DISSECTORS_PRESENT,
+			.layer = l2,
+			.ofst = 12,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_3] = {
+			.dissectors_covered = ETHTYPE_DISSECTOR_PRESENT,
+			.layer = l2,
+			.ofst = 12 + sizeof(struct vlan_tag),
+			.len = 2,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_4] = {
+			.dissectors_covered = IPV4_TOS_DISSECTOR_PRESENT,
+			.layer = l3,
+			.ofst = 0 + sizeof(struct vlan_tag),
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_5] = {
+			.dissectors_covered = (IPV4_TTL_DISSECTOR_PRESENT |
+					       IPV4_PROTO_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 8 + sizeof(struct vlan_tag),
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_6] = {
+			.dissectors_covered = (IPV4_SRC_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 12 + sizeof(struct vlan_tag),
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_7] = {
+			.dissectors_covered = (IPV4_DST_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 16 + sizeof(struct vlan_tag),
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_8] = {
+			.dissectors_covered = (L4_SRC_PORT_DISSECTOR_PRESENT),
+			.layer = l4,
+			.ofst = 0 + sizeof(struct vlan_tag),
+			.len = 2,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_9] = {
+			.dissectors_covered = (L4_DST_PORT_DISSECTOR_PRESENT),
+			.layer = l4,
+			.ofst = 2 + sizeof(struct vlan_tag),
+			.len = 2,
+			.rng_match_en = false,
+		},
+	},
+	[PARSER_IDX_3] = {
+		[RFR_IDX_0] = {
+			.dissectors_covered = IPV6_TC_DISSECTOR_PRESENT,
+			.layer = l3,
+			.ofst = 0,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_1] = {
+			.dissectors_covered = (IPV6_HOP_DISSECTOR_PRESENT |
+					       IPV6_NXTHDR_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 4,
+			.len = 4,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_2] = {
+			.dissectors_covered = (IPV6_SRC_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 8,
+			.len = 16,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_3] = {
+			.dissectors_covered = (IPV6_DST_IP_DISSECTOR_PRESENT),
+			.layer = l3,
+			.ofst = 24,
+			.len = 16,
+			.rng_match_en = false,
+		},
+		[RFR_IDX_4] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_5] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_6] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_7] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_8] = {
+			.dissectors_covered = 0,
+		},
+		[RFR_IDX_9] = {
+			.dissectors_covered = 0,
+		},
+	}
+};
+
+int lan937x_get_acl_req(enum lan937x_filter_type type,
+			u8 *parser_idx, u8 *n_entries)
+{
+	switch (type) {
+	case LAN937x_VLAN_UNAWARE_FILTER:
+		*parser_idx = 0;
+		*n_entries = 2;
+		break;
+	case LAN937x_VLAN_AWARE_FILTER:
+		*parser_idx = 2;
+		*n_entries = 2;
+		break;
+	case LAN937x_BCAST_FILTER:
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int lan937x_wait_tcam_busy(struct ksz_device *dev, int port)
+{
+	unsigned int val;
+
+	return regmap_read_poll_timeout(dev->regmap[2],
+					PORT_CTRL_ADDR(port,
+						       REG_ACL_PORT_ARACR),
+					val,
+					val & ACL_ARACR_TCAM_OP_STS,
+					10,
+					10000);
+}
+
+static int lan937x_set_acl_access_ctl(struct ksz_device *dev,
+				      int port,
+				      struct lan937x_acl_access_ctl *acc_ctl)
+{
+	u32 val;
+	int ret;
+
+	ret = lan937x_wait_tcam_busy(dev, port);
+	if (ret)
+		return ret;
+
+	val = acl_acc_ctl(acc_ctl);
+
+	ret = lan937x_pwrite32(dev, port, REG_ACL_PORT_ARACR, val);
+	if (ret)
+		return ret;
+
+	ret = lan937x_wait_tcam_busy(dev, port);
+	return ret;
+}
+
+static int lan937x_acl_entry_write(struct ksz_device *dev,
+				   u8 port, u8 entry_idx,
+				   struct lan937x_acl_entry *acl_entry)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	struct lan937x_acl_access_ctl access_ctl;
+	struct lan937x_acl_byte_en byte_en_cfg;
+	int ret;
+
+	ret = lan937x_wait_tcam_busy(dev, port);
+	if (ret)
+		return ret;
+
+	/* Write TCAM mask in ADR */
+	ret = lan937x_pwrite8_bulk(dev, port, REG_ACL_PORT_ADR,
+				   &acl_entry->acl_mask[0],
+				   MAX_ACL_DATA_MASK_SIZE);
+	if (ret)
+		return ret;
+
+	/* Write TCAM Data in ADR */
+	ret = lan937x_pwrite8_bulk(dev, port,
+				   REG_ACL_PORT_ADR + MAX_ACL_DATA_MASK_SIZE,
+				   &acl_entry->acl_data[0],
+				   MAX_ACL_DATA_MASK_SIZE);
+	if (ret)
+		return ret;
+
+	/* Write AAR */
+	ret = lan937x_pwrite8_bulk(dev, port, REG_ACL_PORT_AAR,
+				   &acl_entry->acl_action[0],
+				   MAX_ACL_ACTION_SIZE);
+	if (ret)
+		return ret;
+
+	/* Each bit of this BYTE_EN register defines which
+	 * bytes in ADR & AAR are writable
+	 */
+	memset(&byte_en_cfg, 0xFF, sizeof(byte_en_cfg));
+	ret = lan937x_pwrite8_bulk(dev, port, REG_ACL_PORT_ABER,
+				   &byte_en_cfg.acl_mask[0],
+				   sizeof(byte_en_cfg));
+	if (ret)
+		return ret;
+
+	/* HW workaround for ACL write */
+	ret = lan937x_pwrite16(dev, port, 0x66C, 0xFFFF);
+	if (ret)
+		return ret;
+
+	/* HW workaround for ACL write */
+	ret = lan937x_pwrite16(dev, port, 0x672, 0xFFFF);
+	if (ret)
+		return ret;
+
+	/* Clear data in access_ctl */
+	clr_data(access_ctl);
+
+	/* Set TCAM Control Register for TCAM Entry Write */
+	set_tcam_addr(access_ctl, entry_idx);
+	set_pri_low(access_ctl, true);
+	set_tcam_vben(access_ctl, true);
+	set_tcam_vbi(access_ctl, true);
+	set_tcam_row_vld(access_ctl, 0x0F);
+	set_tcam_req(access_ctl, TCAM_REQ_TYPE_WRITE_TCAM);
+	set_tcam_acc(access_ctl, TCAM_MASK_DATA);
+
+	/* Write ACL register */
+	ret = lan937x_set_acl_access_ctl(dev,
+					 port, &access_ctl);
+	if (ret)
+		return ret;
+
+	res->tcam_entries_used[entry_idx] = true;
+
+	return ret;
+}
+
+static void lan937x_cpy_array_to_entry(u8 *s_data, u8 *s_mask,
+				       struct lan937x_acl_entry *acl_entry,
+				       u8 offset,
+				       u8 n)
+{
+	u8 *d_mask = &acl_entry->acl_mask[offset];
+	u8 *d_data = &acl_entry->acl_data[offset];
+	u8 i;
+
+	for (i = 0; i < n; i++) {
+		/* Apply mask to data given from the rule */
+		s_data[i] &= s_mask[i];
+
+		/* As per datasheet, TCAM mask should be inverted of data
+		 * for strict match
+		 */
+		s_mask[i] &= (~s_data[i]);
+
+		/* Copy Mask & Data to TCAM Entry */
+		d_mask[i] = s_mask[i];
+		d_data[i] = s_data[i];
+	}
+}
+
+static void lan937x_cpy_ethaddr_to_entry(struct lan937x_val_mask_u64 *ethaddr,
+					 struct lan937x_acl_entry *acl_entry,
+					 u8 offset)
+{
+	u64 tdata = ethaddr->value;
+	u64 tmask = ethaddr->mask;
+
+	/* Apply mask to data given from the rule */
+	tdata &= tmask;
+
+	/* As per datasheet, TCAM mask should be inverted of data
+	 * for strict match
+	 */
+	tmask &= (~tdata);
+
+	/* Copy Mask & Data to TCAM Entry */
+	u64_to_ether_addr(tmask, &acl_entry->acl_mask[offset]);
+	u64_to_ether_addr(tdata, &acl_entry->acl_data[offset]);
+}
+
+static void lan937x_cpy_u8_to_entry(struct lan937x_val_mask_u8 *field,
+				    struct lan937x_acl_entry *acl_entry,
+				    u8 offset)
+{
+	u8 tdata = field->value;
+	u8 tmask = field->mask;
+
+	/* Apply mask to data given from the rule */
+	tdata &= tmask;
+
+	/* As per datasheet, TCAM mask should be inverted of data
+	 * for strict match
+	 */
+	tmask &= (~tdata);
+
+	/* Copy Mask & Data to TCAM Entry */
+	acl_entry->acl_mask[offset] |= (tmask);
+	acl_entry->acl_data[offset] |= (tdata);
+}
+
+static void lan937x_cpy_u16_to_entry(struct lan937x_val_mask_u16 *field,
+				     struct lan937x_acl_entry *acl_entry,
+				     u8 offset)
+{
+	u16 tdata;
+	u16 tmask;
+
+	*((__be16 *)&tdata) = cpu_to_be16(field->value);
+	*((__be16 *)&tmask) = cpu_to_be16(field->mask);
+
+	/* Apply mask to data given from the rule */
+	tdata &= tmask;
+
+	/* As per datasheet, TCAM mask should be inverted of data
+	 * for strict match
+	 */
+	tmask &= (~tdata);
+
+	acl_entry->acl_mask[offset + 1] |= ((tmask & 0xFF00) >> 8);
+	acl_entry->acl_mask[offset] |= (tmask & 0x00FF);
+	acl_entry->acl_data[offset + 1] |= (tdata & 0xFF00) >> 8;
+	acl_entry->acl_data[offset] |= (tdata & 0x00FF);
+}
+
+static int lan937x_acl_fill_entry(struct ksz_device *dev,
+				  int port, u8 parser_idx,
+				  enum lan937x_acl_dissector_type disctr,
+				  struct lan937x_key *key,
+				  struct lan937x_acl_entry *acl_entry)
+{
+	const struct lan937x_acl_rfr *rfr_ptr = acl_rfrs_table[parser_idx];
+	u8 *acl_mask = acl_entry->acl_mask;
+	u8 *acl_data = acl_entry->acl_data;
+	u8 ofst = 0;
+	int i;
+
+	if (parser_key_format[parser_idx] == PARSER_MULTI_KEY_FORMAT)
+		ofst += TCAM_MULTI_KEY_ENTRY_START;
+
+	for (i = 0; i < MAX_RFR_PER_PARSER; i++) {
+		/* No more valid RFRs in Parser */
+		if (!rfr_ptr[i].dissectors_covered)
+			break;
+
+		if (!(rfr_ptr[i].dissectors_covered & BIT(disctr))) {
+			/* Accumulate the length of all previous RFRs till
+			 * the intended RFR which carries the intended
+			 * dissector. Accumulated offset is finally used as the
+			 * offset in TCAM entry to fill TCAM data
+			 */
+			ofst += rfr_ptr[i].len;
+			continue;
+		}
+
+		switch (disctr) {
+		case acl_dst_mac_dissector:
+			lan937x_cpy_ethaddr_to_entry(&key->dst_mac,
+						     acl_entry,
+							ofst);
+			break;
+		case acl_src_mac_dissector:
+			lan937x_cpy_ethaddr_to_entry(&key->src_mac,
+						     acl_entry,
+							ofst);
+			break;
+		case acl_vlan_id_dissector: {
+			u16 tdata;
+			u16 tmask;
+
+			*((__be16 *)&tdata) = cpu_to_be16(key->vlan_id.value);
+			*((__be16 *)&tmask) = cpu_to_be16(key->vlan_id.mask);
+
+			tdata &= tmask;
+			tmask &= (~tdata);
+
+			acl_mask[ofst + 2] |= (tmask & 0x0F);
+			acl_mask[ofst + 3] |= (tmask & 0xFF00) >> 8;
+			acl_data[ofst + 2] |= (tdata & 0x0F);
+			acl_data[ofst + 3] |= (tdata & 0xFF00) >> 8;
+			break;
+		}
+		case acl_vlan_pcp_dissector: {
+			u16 tdata = key->vlan_prio.value;
+			u16 tmask = key->vlan_prio.mask;
+
+			tdata &= tmask;
+			tmask &= (~tdata);
+
+			acl_mask[ofst + 2] |= (tmask & 0x07) << 5;
+			acl_data[ofst + 2] |= (tdata & 0x07) << 5;
+			break;
+		}
+		case acl_ethtype_dissector:
+			lan937x_cpy_u16_to_entry(&key->ethtype,
+						 acl_entry,
+						 ofst);
+			break;
+		case acl_ipv4_tos_dissector: {
+			/* IPV4 TOS starts at offset 1 byte from RFR start */
+			lan937x_cpy_u8_to_entry(&key->ipv4.tos,
+						acl_entry,
+						ofst + 1);
+			break;
+		}
+		case acl_ipv4_ttl_dissector: {
+			lan937x_cpy_u8_to_entry(&key->ipv4.ttl,
+						acl_entry,
+						ofst);
+			break;
+		}
+		case acl_ipv4_protocol_dissector: {
+			/* IPV4 proto starts at offset 1 byte from RFR start */
+			lan937x_cpy_u8_to_entry(&key->ipv4.proto,
+						acl_entry,
+						ofst + 1);
+			break;
+		}
+		case acl_ipv4_src_ip_dissector: {
+			lan937x_cpy_array_to_entry(key->ipv4.sip.value,
+						   key->ipv4.sip.mask,
+						   acl_entry,
+						   ofst, 0x04);
+			break;
+		}
+		case acl_ipv4_dst_ip_dissector: {
+			lan937x_cpy_array_to_entry(key->ipv4.dip.value,
+						   key->ipv4.dip.mask,
+						   acl_entry,
+						   ofst, 0x04);
+			break;
+		}
+		case acl_ipv6_tc_dissector: {
+			u8 tdata = key->ipv6.tc.value;
+			u8 tmask = key->ipv6.tc.mask;
+
+			tdata &= tmask;
+			tmask &= (~tdata);
+
+			acl_mask[ofst]	|= ((tmask & 0xF0) >> 0x04);
+			acl_data[ofst]	|= ((tdata & 0xF0) >> 0x04);
+			acl_mask[ofst + 1] |= ((tmask & 0x0F) << 0x04);
+			acl_data[ofst + 1] |= ((tdata & 0x0F) << 0x04);
+			break;
+		}
+		case acl_ipv6_nxt_hdr_dissector: {
+			/* IPV6 next header starts at offset 2 byte from RFR
+			 * start
+			 */
+			lan937x_cpy_u8_to_entry(&key->ipv6.next_hdr,
+						acl_entry,
+						ofst + 2);
+			break;
+		}
+		case acl_ipv6_hop_dissector: {
+			/* IPV6 hop starts at offset 3 byte from RFR start */
+			lan937x_cpy_u8_to_entry(&key->ipv6.hop,
+						acl_entry,
+						ofst + 3);
+			break;
+		}
+		case acl_ipv6_src_ip_dissector: {
+			lan937x_cpy_array_to_entry(key->ipv6.sip.value,
+						   key->ipv6.sip.mask,
+						   acl_entry,
+						   ofst, 16);
+			break;
+		}
+		case acl_ipv6_dst_ip_dissector: {
+			lan937x_cpy_array_to_entry(key->ipv6.dip.value,
+						   key->ipv6.dip.mask,
+						   acl_entry,
+						   ofst, 16);
+			break;
+		}
+		case acl_l4_src_port_dissector: {
+			lan937x_cpy_u16_to_entry(&key->src_port,
+						 acl_entry,
+						 ofst);
+			break;
+		}
+		case acl_l4_dst_port_dissector: {
+			lan937x_cpy_u16_to_entry(&key->dst_port,
+						 acl_entry,
+						 ofst);
+			break;
+		}
+		default:
+			break;
+		} /* switch ends */
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+int lan937x_acl_program_entry(struct ksz_device *dev, int port,
+			      struct lan937x_flower_rule *rule)
+{
+	struct lan937x_flower_action *action = &rule->flower->action;
+	u32 actions_presence_mask = action->actions_presence_mask;
+	struct lan937x_key *key = &rule->flower->filter.key;
+	struct lan937x_resrc_alloc *resrc = rule->resrc;
+	u32 acl_dissector_map = key->acl_dissector_map;
+	u8 n_entries = resrc->type.tcam.n_entries;
+	u8 parser = resrc->type.tcam.parser;
+	struct lan937x_acl_entry *acl_entry;
+	int ret = EINVAL;
+	u8 *acl_action;
+	u8 i, j;
+
+	acl_entry = devm_kzalloc(dev->dev, sizeof(*acl_entry) * n_entries,
+				 GFP_KERNEL);
+
+	if (!acl_entry)
+		return -ENOSPC;
+
+	for (i = 0; ((acl_dissector_map != 0) &&
+		     (i < LAN937X_NUM_DISSECTORS_SUPPORTED)); i++) {
+		if (!(acl_dissector_map & BIT(i)))
+			continue;
+
+		acl_dissector_map &= ~BIT(i);
+
+		for (j = 0; j < n_entries; j++) {
+			ret = lan937x_acl_fill_entry(dev, port, parser + j,
+						     i, key, &acl_entry[j]);
+			if (!ret)
+				break;
+		}
+		if (ret)
+			goto out;
+	}
+
+	for (i = 0; ((actions_presence_mask != 0) &&
+		     (i < LAN937X_NUM_ACTIONS_SUPPORTED)); i++) {
+		if (!(actions_presence_mask & BIT(i)))
+			continue;
+
+		actions_presence_mask &= ~BIT(i);
+
+		/* Only use the first entry to fill the action */
+		acl_action = acl_entry[0].acl_action;
+
+		switch (i) {
+		case LAN937X_ACT_REDIRECT_FLOW:
+			set_map_mode(acl_action, MM_REPLACE_FWD_LKUP_TABLE);
+			set_dst_port(acl_action, action->redirect_port_mask);
+			break;
+		case LAN937X_ACT_STREAM_POLICE:
+		case LAN937X_ACT_STREAM_GATE:
+			set_map_mode(acl_action, 2);
+			set_dst_port(acl_action, 0xff);
+			set_strm_en(acl_action, resrc->type.strm_flt.en);
+			set_strm_id(acl_action, resrc->type.strm_flt.index);
+			break;
+		case LAN937X_ACT_DROP:
+			set_map_mode(acl_action, MM_REPLACE_FWD_LKUP_TABLE);
+			/* Donot forward to any valid port */
+			set_dst_port(acl_action, 0x00);
+			break;
+		case LAN937X_ACT_PRIORITY:
+			set_que_en(acl_action);
+			set_que_sel(acl_action, action->skbedit_prio);
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+	if (resrc->type.tcam.cntr != STATS_COUNTER_NOT_ASSIGNED)
+		set_fr_counter(acl_action, resrc->type.tcam.cntr);
+
+	/* For Multiple format Key
+	 * Bit 383:382 PARSER_NUM Programmed to the 1st parser used TCAM rule
+	 */
+	if (parser_key_format[parser] == PARSER_MULTI_KEY_FORMAT) {
+		acl_entry[0].acl_mask[0] |= ((~parser) << 6);
+		acl_entry[0].acl_data[0] |= (parser << 6);
+	}
+
+	for (j = 0; j < n_entries; j++) {
+		ret = lan937x_acl_entry_write(dev, port,
+					      resrc->type.tcam.index + j,
+					      &acl_entry[j]);
+		if (ret)
+			break;
+	}
+
+out:
+	devm_kfree(dev->dev, acl_entry);
+	return ret;
+}
+
+static int lan937x_set_rfr_entry(struct ksz_device *dev, int port,
+				 u8 parser_idx, u8 rfr_idx,
+				 const struct lan937x_acl_rfr *rfr_entry)
+{
+	struct lan937x_rfr_reg_type rfr_data;
+	u8 tcam_addr_access;
+	u16 reg_ofst;
+	int ret;
+
+	tcam_addr_access = parser_idx % 2;
+
+	reg_ofst = ACL_CTRL_BASE_ADDR + (rfr_idx * MAX_RFR_SIZE) +
+		   (tcam_addr_access * MAX_RFR_SIZE * MAX_RFR_PER_PARSER);
+
+	if (!(rfr_entry->dissectors_covered)) {
+		/* Ensure unused RFRs arent filled with junk */
+		rfr_data.u32value = 0x00000000;
+		goto pgm;
+	}
+
+	rfr_data.u32value = (RFR_OSFT_L4_RELATV(rfr_entry->layer == l4) |
+			     RFR_OSFT_L3_RELATV(rfr_entry->layer == l3) |
+			     RFR_OSFT_L2_RELATV(rfr_entry->layer == l2));
+	rfr_data.u32value |= RFR_OFST(rfr_entry->ofst);
+	rfr_data.u32value |= RFR_LENGTH(rfr_entry->len);
+	rfr_data.u32value |= RFR_RNG_MATCH_EN(rfr_entry->rng_match_en);
+	rfr_data.u32value |= RFR_RNG_OSFT(rfr_entry->rng_ofst);
+
+pgm:
+	ret = lan937x_pwrite32(dev, port, reg_ofst, rfr_data.u32value);
+
+	return ret;
+}
+
+static int lan937x_program_rfrs(struct ksz_device *dev,
+				int port)
+{
+	struct lan937x_acl_access_ctl access_ctl;
+	const struct lan937x_acl_rfr *rfr_entry;
+	int parser_idx, rfr_idx;
+	int count = 0;
+	int ret;
+
+	for (parser_idx = 0; parser_idx < MAX_ACL_PARSERS; parser_idx++) {
+		for (rfr_idx = 0; rfr_idx < MAX_RFR_PER_PARSER; rfr_idx++) {
+			rfr_entry = &acl_rfrs_table[parser_idx][rfr_idx];
+			ret = lan937x_set_rfr_entry(dev, port, parser_idx,
+						    rfr_idx, rfr_entry);
+			if (ret)
+				return ret;
+		}
+
+		/* Increament the parser count */
+		count++;
+
+		/* At once Rule Format regs for 2 Parsers are programmable */
+		if (count != (MAX_PARSER_PER_ENTRY))
+			continue;
+
+		/* Restart the parser counter */
+		count = 0;
+
+		clr_data(access_ctl);
+
+		if (parser_idx < MAX_PARSER_PER_ENTRY)
+			set_tcam_addr(access_ctl, TCAM_PARSER_0_1);
+		else
+			set_tcam_addr(access_ctl, TCAM_PARSER_2_3);
+
+		set_tcam_vben(access_ctl, true);
+		set_tcam_vbi(access_ctl, true);
+		set_tcam_row_vld(access_ctl, 0x0F);
+		set_tcam_req(access_ctl, TCAM_REQ_TYPE_WRITE_RFR);
+		set_tcam_acc(access_ctl, TCAM_MASK_DATA);
+
+		ret = lan937x_set_acl_access_ctl(dev, port, &access_ctl);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+int lan937x_init_acl_parsers(struct ksz_device *dev, int port)
+{
+	int ret;
+
+	ret = lan937x_program_rfrs(dev, port);
+	if (ret)
+		return ret;
+
+	ret = lan937x_pwrite32(dev, port, REG_ACL_PORT_PCTRL,
+			       (PCTRL_TWO_FORMAT_TWO_PARSER_EACH |
+				PCTRL_KEY2_VLAN_TAG_EN	|
+				PCTRL_KEYTYPE0_MULTI_FMT |
+				PCTRL_KEYTYPE2_MULTI_FMT));
+	if (ret)
+		return ret;
+
+	ret = lan937x_pwrite8(dev, port, REG_PORT_RX_AUTH_CTL,
+			      (AUTH_CTL_ACL_PASS_MODE | AUTH_CTL_ACL_ENABLE));
+
+	return ret;
+}
+
+int lan937x_acl_free_entry(struct ksz_device *dev, int port,
+			   struct lan937x_flower_rule *rule)
+{
+	struct lan937x_resrc_alloc *resrc = rule->resrc;
+	u8 n_entries = resrc->type.tcam.n_entries;
+	struct lan937x_acl_access_ctl access_ctl;
+	bool last_entry = false;
+	u8 i, row;
+	int ret;
+
+	/* Nothing to delete */
+	if (!n_entries)
+		return 0;
+
+	/* Shift all the TCAM Entries that are below the current entry upwards
+	 * by n_entries time to over write the current rule
+	 */
+	clr_data(access_ctl);
+
+	/* Assign the first entry index */
+	set_row_shift(access_ctl, (n_entries + resrc->type.tcam.index));
+
+	/* Identify the row where the Last Entry is present*/
+	ret = lan937x_assign_tcam_entries(dev, port, 0x01,
+					  &access_ctl.tcam_addr);
+	if (ret == -ENOSPC) {
+		set_tcam_addr(access_ctl, LAN937X_NUM_TCAM_ENTRIES);
+		last_entry = true;
+	}
+
+	if (access_ctl.row_shift == access_ctl.tcam_addr ||
+	    last_entry) {
+		/* There are no valid entries below the current
+		 * rule under deletion. So No shifting is necessary
+		 */
+		set_pri_low(access_ctl, true);
+		set_tcam_vben(access_ctl, true);
+		set_tcam_vbi(access_ctl, false);
+		set_tcam_row_vld(access_ctl, 0x0F);
+		set_num_shift(access_ctl, (n_entries - 1));
+		set_tcam_req(access_ctl, TCAM_REQ_TYPE_SHIFT_TCAM);
+		set_tcam_acc(access_ctl, TCAM_MASK_DATA);
+
+		ret = lan937x_set_acl_access_ctl(dev, port, &access_ctl);
+		if (ret)
+			return ret;
+	}
+
+	/* After shifting upward, invalidate the very last n_entries.
+	 * If last_entry is true then shifting will not happen, but the last
+	 * n_entries will be invalidated, which will decommision the rule
+	 */
+	row = access_ctl.tcam_addr;
+	for (i = (row - 1); i > (row - n_entries); i--) {
+		clr_data(access_ctl);
+
+		set_tcam_addr(access_ctl, i);
+		set_pri_low(access_ctl, true);
+		set_tcam_vben(access_ctl, true);
+		/*vbi - 0: makes TCAM entry invalid.*/
+		set_tcam_vbi(access_ctl, false);
+		set_tcam_row_vld(access_ctl, 0x0F);
+		set_tcam_req(access_ctl, TCAM_REQ_TYPE_WRITE_TCAM);
+		set_tcam_acc(access_ctl, TCAM_MASK_DATA);
+
+		ret = lan937x_set_acl_access_ctl(dev, port, &access_ctl);
+		if (ret)
+			return ret;
+	}
+
+	/* Deleted rule no longer has any tcam entries */
+	resrc->type.tcam.n_entries = 0x00;
+
+	return ret;
+}
+
+irqreturn_t lan937x_acl_isr(struct ksz_device *dev, int port)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u8 intsts;
+	int ret;
+
+	ret = lan937x_pread8(dev, port, REG_ACL_PORT_INT_STS, &intsts);
+	if (ret)
+		return IRQ_NONE;
+
+	if (intsts & ACL_FR_COUNT_OVR0) {
+		res->tcam_match_cntr_bkup[0] += ACL_FR_COUNT_MAX_VALUE;
+		res->tcam_match_cntr_bkup[0] &= ~((u64)ACL_FR_COUNT_MAX_VALUE);
+	}
+	if (intsts & ACL_FR_COUNT_OVR1) {
+		res->tcam_match_cntr_bkup[1] += ACL_FR_COUNT_MAX_VALUE;
+		res->tcam_match_cntr_bkup[1] &= ~((u64)ACL_FR_COUNT_MAX_VALUE);
+	}
+	if (intsts & ACL_FR_COUNT_OVR2) {
+		res->tcam_match_cntr_bkup[2] += ACL_FR_COUNT_MAX_VALUE;
+		res->tcam_match_cntr_bkup[2] &= ~((u64)ACL_FR_COUNT_MAX_VALUE);
+	}
+	if (intsts & ACL_FR_COUNT_OVR3) {
+		res->tcam_match_cntr_bkup[3] += ACL_FR_COUNT_MAX_VALUE;
+		res->tcam_match_cntr_bkup[3] &= ~((u64)ACL_FR_COUNT_MAX_VALUE);
+	}
+
+	ret =  lan937x_pwrite8(dev, port, REG_ACL_PORT_INT_STS, intsts);
+	if (ret)
+		return IRQ_NONE;
+
+	return IRQ_HANDLED;
+}
diff --git a/drivers/net/dsa/microchip/lan937x_acl.h b/drivers/net/dsa/microchip/lan937x_acl.h
new file mode 100644
index 000000000000..bd32ac2b180a
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_acl.h
@@ -0,0 +1,490 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip switch driver common header
+ *
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#ifndef _NET_DSA_DRIVERS_LAN937X_ACL_H
+#define _NET_DSA_DRIVERS_LAN937X_ACL_H
+
+/* Reg Data */
+#define ACL_ARACR_ADD_SHIFT_LO_PRI	(0x10000000)
+#define ACL_ARACR_TCAM_FLUSH		(0x08000000)
+#define ACL_ARACR_TCAM_VBEN		(0x04000000)
+#define ACL_ARACR_TCAM_VBI		(0x02000000)
+#define ACL_ARACR_TCAM_ROW_VLD	(0x01E00000)
+#define ACL_ARACR_START_ROW_SHFIT	(0x000FC000)
+#define ACL_ARACR_TCAM_OP_STS		(0x00002000)
+#define ACL_ARACR_TCAM_REQ_TYPE	(0x00001C00)
+#define ACL_ARACR_TCAM_ACC_TYPE	(0x00000300)
+#define ACL_ARACR_TCAM_NUM_SHIFT	(0x000000C0)
+#define ACL_ARACR_TCAM_ADDR_MASK	(0x0000003F)
+
+#define ACL_PCTRL_NUM_KEY_FORMAT	(0xF0000000)
+#define ACL_PCTRL_KEY_TYPE		(0x0F000000)
+#define ACL_PCTRL_IP_OPTIONS		(0x00F00000)
+#define ACL_PCTRL_VLAN_TAG		(0x000F0000)
+#define ACL_PCTRL_ABS_OFF		(0x0000F000)
+#define ACL_PCTRL_HSR_TAG		(0x00000F00)
+#define ACL_PCTRL_SNAP_TAG		(0x000000F0)
+
+#define ACL_INT_STS_TOP		(0x00000001)
+#define ACL_INT_STS_FRC0		(0x00000002)
+#define ACL_INT_STS_FRC1		(0x00000004)
+#define ACL_INT_STS_FRC2		(0x00000008)
+#define ACL_INT_STS_FRC3		(0x00000010)
+#define ACL_INT_STS_FRCX		(0x0000001E)
+#define ACL_INT_MASK_TOP		(0x00000001)
+#define ACL_INT_MASK_FRC0		(0x00000002)
+#define ACL_INT_MASK_FRC1		(0x00000004)
+#define ACL_INT_MASK_FRC2		(0x00000008)
+#define ACL_INT_MASK_FRC3		(0x00000010)
+#define ACL_INT_MASK_FRCX		(0x0000001E)
+
+#define ACL_TCAM_BIST0_TCAMSEL	(0x00000600)
+#define ACL_TCAM_BIST0_FAIL		(0x00000100)
+#define ACL_TCAM_BIST0_PASS		(0x00000080)
+#define ACL_TCAM_BIST0_PAUSE		(0x00000040)
+#define ACL_TCAM_BIST0_SHO		(0x00000020)
+#define ACL_TCAM_BIST0_SHI		(0x00000010)
+#define ACL_TCAM_BIST0_RESUME		(0x00000008)
+#define ACL_TCAM_BIST0_RTNEN		(0x00000004)
+#define ACL_TCAM_BIST0_RUN		(0x00000002)
+#define ACL_TCAM_BIST0_RESET		(0x00000001)
+#define ACL_TCAM_BIST1_DEFADDR	(0x0000007F)
+#define ACL_TCAM_BIST2_FAILSEQ	(0x000000FF)
+#define ACL_TCAM_BIST3_SKPERRCNT	(0x0000001F)
+
+#define TCAM_BIST_TCAMSEL_SHIFT	9
+#define TCAM_BIST_FAIL_SHIFT		8
+#define TCAM_BIST_PASS_SHIFT		7
+#define TCAM_BIST_PAUSE_SHIFT		6
+#define TCAM_BIST_SHO_SHIFT		5
+#define TCAM_BIST_SHI_SHIFT		4
+#define TCAM_BIST_RESUME_SHIFT	3
+#define TCAM_BIST_RTNEN_SHIFT		2
+#define TCAM_BIST_RUN_SHIFT		1
+#define TCAM_BIST_RESET_SHIFT		0
+
+/* AAR0 [40:33]*/
+#define LAN937X_ACL_AAR_TS		(0x80)
+#define LAN937X_ACL_AAR_COUNT		(0x40)
+#define LAN937X_ACL_AAR_COUNT_SEL	(0x30)
+#define LAN937X_ACL_AAR_STREAM_EN	(0x8)
+#define LAN937X_ACL_AAR_STREAM_ID	(0x7)
+
+/* AAR1 [32:25] */
+#define LAN937X_ACL_AAR_RVTG		(0x80)
+#define LAN937X_ACL_AAR_VID_H		(0x7F)
+/* AAR2 [24:17] */
+#define LAN937X_ACL_AAR_VID_L		(0xFC)
+#define LAN937X_ACL_AAR_QUE_EN		(0x03)
+/* ARR3 [16:9] */
+#define LAN937X_ACL_AAR_QUE_SEL	(0xE0)
+#define LAN937X_ACL_AAR_RP		(0x10)
+#define LAN937X_ACL_AAR_PRI		(0x0E)
+#define LAN937X_ACL_AAR_MM_H		(0x01)
+/* ARR4 [8:1] */
+#define LAN937X_ACL_AAR_MM_L		(0x80)
+#define LAN937X_ACL_AAR_DPORT_H	(0x7F)
+/* AAR5 [0] */
+#define LAN937X_ACL_AAR_DPORT_L	(0x80)
+
+#define TCAM_RFR_EN_RNGM		(0x20000000)
+#define TCAM_RFR_L4			(0x10000000)
+#define TCAM_RFR_L3			(0x08000000)
+#define TCAM_RFR_L2			(0x04000000)
+#define TCAM_RFR_OFST			(0x03FFE000)
+#define TCAM_RFR_LEN			(0x00000F80)
+#define TCAM_RFR_RNG_OFST		(0x0000003E)
+
+/* Reg Mask */
+#define TCAM_LO_PRI_POS		28
+#define TCAM_FLUSH_POS		27
+#define TCAM_VBEN_POS		26
+#define TCAM_VBI_POS			25
+#define TCAM_ROW_VLD_POS		21
+#define TCAM_START_ROW_SHIFT_POS	14
+#define TCAM_OPERATION_STATUS_POS	13
+#define TCAM_REQ_TYPE_POS		10
+#define TCAM_ACC_TYPE_POS		8
+#define TCAM_NUM_SHIFT_POS		6
+#define TCAM_ADDR_POS		0
+
+/* AAR0 [63:56]*/
+#define TCAM_AAR_TS_POS		7
+#define TCAM_AAR_COUNT_POS		6
+#define TCAM_AAR_COUNT_SEL_POS		4
+#define TCAM_AAR_STREAM_EN_POS		3
+#define TCAM_AAR_STREAM_ID_POS		0
+/* AAR1 [55:48] */
+#define TCAM_AAR_RVTG_POS		7
+#define TCAM_AAR_VID_DATA_H_POS	6
+/* AAR2 [47:40] */
+#define TCAM_AAR_VID_DATA_L_POS	2
+#define TCAM_AAR_QUE_EN_POS  0
+/* ARR3 [39:32] */
+#define TCAM_AAR_QUE_SEL_POS		5
+#define TCAM_AAR_RP_POS		4
+#define TCAM_AAR_PRI_POS		1
+#define TCAM_AAR_MM_H_POS		1
+/* ARR4 [31:24] */
+#define TCAM_AAR_MM_L_POS		7
+#define TCAM_AAR_DP_H_POS		1
+/* AAR5 [23:16] */
+#define TCAM_AAR_DP_L_POS		7
+/* AAR6 [15:8] */
+/* AAR7 [7:0 */
+
+/* Map Mode value defines */
+/* The forwarding map from the lookup table is replaced with DPORT map.*/
+#define MM_REPLACE_FWD_LKUP_TABLE	0x03
+/* the forwarding map from the lookup table is AND'ed with DPORT map*/
+#define MM_AND_FWD_LKUP_TABLE		0x02
+/* the forwarding map from the lookup table is OR'ed with DPORT map*/
+#define MM_OR_FWD_LKUP_TABLE		0x01
+/**No remapping of Dport*/
+#define MM_NO_REMAPPING			0x00
+
+#define TCAM_NUM_KEY_FORMAT_POS	28
+#define TCAM_KEY_TYPE_POS		24
+#define TCAM_IP_OPTIONS_POS		20
+#define TCAM_VLAN_TAG_POS		16
+#define TCAM_ABS_OFF_POS		12
+#define TCAM_HSR_TAG_POS		8
+#define TCAM_SNAP_TAG_POS		4
+
+#define TCAM_RFR_RN_EN_POS		29
+#define TCAM_RFR_L4_POS		28
+#define TCAM_RFR_L3_POS		27
+#define TCAM_RFR_L2_POS		26
+#define TCAM_RFR_OFST_POS		13
+#define TCAM_RFR_LEN_POS		7
+#define TCAM_RFR_RNG_POS		1
+
+#define LAN937X_MAX_RFR		10
+
+#define TCAM_INT_TOP			0
+#define TCAM_INT_FRC0			1
+#define TCAM_INT_FRC1			2
+#define TCAM_INT_FRC2			3
+#define TCAM_INT_FRC3			4
+#define TCAM_INT_FRCX			1
+/* Misc */
+#define TCAM_REQ_TYPE_READ_TCAM	0x0
+#define TCAM_REQ_TYPE_WRITE_TCAM	0x1
+#define TCAM_REQ_TYPE_ADD_TCAM	0x2
+#define TCAM_REQ_TYPE_SHIFT_TCAM	0x3
+#define TCAM_REQ_TYPE_READ_KIVR	0x4
+#define TCAM_REQ_TYPE_WRITE_KIVR	0x5
+#define TCAM_REQ_TYPE_READ_RFR	0x6
+#define TCAM_REQ_TYPE_WRITE_RFR	0x7
+#define TCAM_ADDR_KIVR_0_1		0x00
+#define TCAM_ADDR_KIVR_2_3		0x01
+#define TCAM_ADDR_RFR_0_1		0x00
+#define TCAM_ADDR_RFR_2_3		0x01
+#define TCAM_ADDR_RNG_BND		0x02
+#define TCAM_ADDR_RNG_CMP		0x03
+
+#define TCAM_ADR_SIZE			96
+#define TCAM_AAR_SIZE			6
+
+#define TCAM_MASK			0x01
+#define TCAM_DATA			0x02
+#define TCAM_MASK_DATA		0x03
+
+#define TCAM_MULTI_KEY_ENTRY_START	0x01
+
+#define TCAM_PARSER_0_1		0x00
+#define TCAM_PARSER_2_3		0x01
+
+#define TCAM_RC_ULM			0x02
+#define TCAM_RC_CMP			0x03
+
+#define ADR2RFR			0x01
+#define RFR2ADR			0x02
+#define ADR2KIVR			0x03
+#define KIVR2ADR			0x04
+#define ADR2ADR			0x05
+
+#define ACLTCAMHW			0x01
+#define ACLTCAMRAM			0x02
+#define ACLRFRHW			0x03
+#define ACLRFRRAM			0x04
+#define ACLTCAMDATA			0x02
+#define ACLKIVRHW			0x05
+#define ACLKIVRRAM			0x06
+#define ACLRCMHW			0x07
+#define ACLRCMRAM			0x08
+
+#define ACLTCAMMASK			0x01
+#define ACLTCAMDATA			0x02
+#define ACLTCAMAAR			0x03
+#define ACLTCAMPARX			0x04
+#define ACLTCAMPARX_1			0x05
+
+/* ACL MACRO*/
+#define MAX_ACL_ENTRIES		64
+#define MAX_ACL_DATA_MASK_SIZE		48  /* Bytes */
+#define MAX_ACL_ACTION_SIZE		8   /* Bytes */
+#define MAX_KIVR_SIZE			48  /* Bytes */
+#define MAX_RFR_SIZE			4   /* Bytes */
+#define MAX_RNG_BOUND_SIZE		2   /* Bytes */
+#define MAX_RNG_COMP_SIZE		2   /* Bytes */
+#define MAX_RNG_MASK_SIZE		4   /* Bytes */
+#define MAX_BYTE_ENABLE_SIZE		14  /* Bytes */
+#define MAX_MASK_DATA_BEN_SIZE		6   /* Bytes */
+#define MAX_ACL_COUNTER_SIZE		4   /* Bytes */
+#define MAX_ACL_NMATCH_SIZE		8   /* Bytes */
+#define MAX_DSCP_X_COLOR		16
+#define MAX_RX_QUEUE			8
+#define MAX_METER_STREAM		8
+#define MAX_MAC_LENGTH			6
+#define MAX_ACL_FRAME_COUNT		4
+#define MAX_ACL_PARSERS		4
+#define MAX_PARSER_PER_ENTRY		2
+#define MAX_RFR_PER_PARSER		10
+#define MAX_RFR				MAX_RFR_PER_PARSER
+#define MAX_ACL_PARSER		4
+#define MAX_RNG_CMP_PER_PARSER		10
+#define MAX_RNG_LB			16
+#define MAX_RNG_UB			16
+
+#define PARSER_IDX_0			0
+#define PARSER_IDX_1			1
+#define PARSER_IDX_2			2
+#define PARSER_IDX_3			3
+
+#define RFR_IDX_0			0
+#define RFR_IDX_1			1
+#define RFR_IDX_2			2
+#define RFR_IDX_3			3
+#define RFR_IDX_4			4
+#define RFR_IDX_5			5
+#define RFR_IDX_6			6
+#define RFR_IDX_7			7
+#define RFR_IDX_8			8
+#define RFR_IDX_9			9
+
+/* Key Format
+ * Multi Key Format - First byte of Entry should match Parser index to
+ * avoid false matches
+ * Univerasal Format - No Parser index matches. Only dissector classification
+ */
+#define PARSER_UNIVERSAL_FORMAT		0x00
+#define PARSER_MULTI_KEY_FORMAT		0x01
+
+enum lan937x_acl_dissector_type {
+	acl_dst_mac_dissector,
+	acl_src_mac_dissector,
+	acl_vlan_id_dissector,
+	acl_vlan_pcp_dissector,
+	acl_ethtype_dissector,
+	acl_ipv4_tos_dissector,
+	acl_ipv4_ttl_dissector,
+	acl_ipv4_protocol_dissector,
+	acl_ipv4_src_ip_dissector,
+	acl_ipv4_dst_ip_dissector,
+	acl_ipv6_tc_dissector,
+	acl_ipv6_hop_dissector,
+	acl_ipv6_nxt_hdr_dissector,
+	acl_ipv6_src_ip_dissector,
+	acl_ipv6_dst_ip_dissector,
+	acl_l4_src_port_dissector,
+	acl_l4_dst_port_dissector,
+
+	acl_num_dissectors_supported,
+};
+
+#define DST_MAC_DISSECTOR_PRESENT	BIT(acl_dst_mac_dissector)
+#define SRC_MAC_DISSECTOR_PRESENT	BIT(acl_src_mac_dissector)
+#define VLAN_ID_DISSECTOR_PRESENT	BIT(acl_vlan_id_dissector)
+#define VLAN_PCP_DISSECTOR_PRESENT	BIT(acl_vlan_pcp_dissector)
+#define ETHTYPE_DISSECTOR_PRESENT	BIT(acl_ethtype_dissector)
+#define IPV4_TOS_DISSECTOR_PRESENT	BIT(acl_ipv4_tos_dissector)
+#define IPV4_TTL_DISSECTOR_PRESENT	BIT(acl_ipv4_ttl_dissector)
+#define IPV4_PROTO_DISSECTOR_PRESENT	BIT(acl_ipv4_protocol_dissector)
+#define IPV4_SRC_IP_DISSECTOR_PRESENT	BIT(acl_ipv4_src_ip_dissector)
+#define IPV4_DST_IP_DISSECTOR_PRESENT	BIT(acl_ipv4_dst_ip_dissector)
+#define IPV6_TC_DISSECTOR_PRESENT	BIT(acl_ipv6_tc_dissector)
+#define IPV6_HOP_DISSECTOR_PRESENT	BIT(acl_ipv6_hop_dissector)
+#define IPV6_NXTHDR_DISSECTOR_PRESENT	BIT(acl_ipv6_nxt_hdr_dissector)
+#define IPV6_SRC_IP_DISSECTOR_PRESENT	BIT(acl_ipv6_src_ip_dissector)
+#define IPV6_DST_IP_DISSECTOR_PRESENT	BIT(acl_ipv6_dst_ip_dissector)
+#define L4_SRC_PORT_DISSECTOR_PRESENT	BIT(acl_l4_src_port_dissector)
+#define L4_DST_PORT_DISSECTOR_PRESENT	BIT(acl_l4_dst_port_dissector)
+
+#define VLAN_TAG_DISSECTORS_PRESENT	(VLAN_ID_DISSECTOR_PRESENT | \
+					VLAN_PCP_DISSECTOR_PRESENT)
+
+/**TCAM Access Control Register defines*/
+
+#define acl_pri_low(val)	((((u32)val) << TCAM_LO_PRI_POS)\
+				 & ACL_ARACR_ADD_SHIFT_LO_PRI)
+#define acl_tcam_flush(val)	((((u32)val) << TCAM_FLUSH_POS)\
+				 & ACL_ARACR_TCAM_FLUSH)
+#define acl_tcam_vben(val)	((((u32)val) << TCAM_VBEN_POS)\
+				 & ACL_ARACR_TCAM_VBEN)
+#define acl_tcam_vbi(val)	((((u32)val) << TCAM_VBI_POS)\
+				 & ACL_ARACR_TCAM_VBI)
+#define acl_tcam_row_vld(val)	((((u32)val) << TCAM_ROW_VLD_POS)\
+				 & ACL_ARACR_TCAM_ROW_VLD)
+#define acl_row_shift(val)	((((u32)val) << TCAM_START_ROW_SHIFT_POS)\
+				 & ACL_ARACR_START_ROW_SHFIT)
+#define acl_tcam_req(val)	((((u32)val) << TCAM_REQ_TYPE_POS)\
+				 & ACL_ARACR_TCAM_REQ_TYPE)
+#define acl_tcam_acc(val)	((((u32)val) << TCAM_ACC_TYPE_POS)\
+				 & ACL_ARACR_TCAM_ACC_TYPE)
+#define acl_num_shift(val)	((((u32)val) << TCAM_NUM_SHIFT_POS)\
+				 & ACL_ARACR_TCAM_NUM_SHIFT)
+#define acl_tcam_addr(val)	(((u32)val) & ACL_ARACR_TCAM_ADDR_MASK)
+
+ /* TCAM data structures */
+struct lan937x_acl_entry {
+	u8 acl_entry_index;
+	u8 acl_mask[MAX_ACL_DATA_MASK_SIZE];
+	u8 acl_data[MAX_ACL_DATA_MASK_SIZE];
+	u8 acl_action[MAX_ACL_ACTION_SIZE];
+};
+
+/* Defines to help filling the action RAM contents */
+static inline void set_que_en(u8 *act)
+{
+	act[2] |= (0x03 >> TCAM_AAR_QUE_EN_POS);
+}
+
+static inline void set_que_sel(u8 *act, u8 pri)
+{
+	act[3] |= ((pri << TCAM_AAR_QUE_SEL_POS) & LAN937X_ACL_AAR_QUE_SEL);
+}
+
+static inline void set_map_mode(u8 *act, u8 MM)
+{
+	act[3] |= ((MM >> TCAM_AAR_MM_H_POS) & LAN937X_ACL_AAR_MM_H);
+	act[4] |= ((MM << TCAM_AAR_MM_L_POS) & LAN937X_ACL_AAR_MM_L);
+}
+
+static inline void set_dst_port(u8 *act, u8 dp)
+{
+	act[4] |= ((dp >> TCAM_AAR_DP_H_POS) & LAN937X_ACL_AAR_DPORT_H);
+	act[5] |= ((dp << TCAM_AAR_DP_L_POS) & LAN937X_ACL_AAR_DPORT_L);
+}
+
+static inline void set_strm_en(u8 *act, u8 en)
+{
+	act[0] |= ((en << TCAM_AAR_STREAM_EN_POS) & LAN937X_ACL_AAR_STREAM_EN);
+}
+
+static inline void set_strm_id(u8 *act, u8 i)
+{
+	act[0] |= (i & LAN937X_ACL_AAR_STREAM_ID);
+}
+
+static inline void set_fr_counter(u8 *act, u8 i)
+{
+	act[0] |= ((1 << TCAM_AAR_COUNT_POS) | (i << TCAM_AAR_COUNT_SEL_POS));
+}
+
+struct lan937x_acl_rfr {
+	u32 dissectors_covered;
+	u8 layer;
+	u16 ofst;
+	u8 len;
+	bool rng_match_en;
+	u8 rng_ofst;
+};
+
+/* enum for layer 2, layer 3, layer 4*/
+enum layer {
+	l2,
+	l3,
+	l4,
+};
+
+/* Defines to set RFR fields*/
+#define RFR_RNG_MATCH_EN(X)	(((X) << TCAM_RFR_RN_EN_POS) & TCAM_RFR_EN_RNGM)
+#define RFR_OSFT_L4_RELATV(X)	((((u32)(X)) << TCAM_RFR_L4_POS) & TCAM_RFR_L4)
+#define RFR_OSFT_L3_RELATV(X)	((((u32)(X)) << TCAM_RFR_L3_POS) & TCAM_RFR_L3)
+#define RFR_OSFT_L2_RELATV(X)	((((u32)(X)) << TCAM_RFR_L2_POS) & TCAM_RFR_L2)
+
+#define RFR_OFST(X)	((((X) >> 1) << TCAM_RFR_OFST_POS) & TCAM_RFR_OFST)
+#define RFR_LENGTH(X)	((((X) >> 1) << TCAM_RFR_LEN_POS) & TCAM_RFR_LEN)
+#define RFR_RNG_OSFT(X)	(((X) << TCAM_RFR_RNG_POS) & TCAM_RFR_RNG_OFST)
+
+struct lan937x_acl_rfr_table {
+	struct lan937x_acl_rfr rfr_entries[MAX_PARSER_PER_ENTRY][MAX_RFR];
+};
+
+struct lan937x_rfr_reg_type {
+	union {
+		u8 bval[MAX_RFR_SIZE];
+		u32 u32value;
+	};
+};
+
+struct lan937x_acl_range_cfg {
+	u16 rng_upper_bound[MAX_RNG_UB];
+	u16 rng_lower_bound[MAX_RNG_LB];
+	u32 rng_bound_msk;
+};
+
+struct lan937x_acl_range_comparator {
+	u16 rng_cmp[MAX_ACL_PARSER][MAX_RNG_CMP_PER_PARSER];
+};
+
+struct lan937x_acl_kivr {
+	u8 kivr[MAX_PARSER_PER_ENTRY][MAX_KIVR_SIZE];
+};
+
+struct lan937x_acl_access_ctl {
+	bool pri_low;
+	bool tcam_flush;
+	bool tcam_vben;
+	bool tcam_vbi;
+	u8 tcam_row_vld;
+	u8 row_shift;
+	u8 tcam_req;
+	u8 tcam_acc;
+	u8 num_shift;
+	u8 tcam_addr;
+};
+
+/* Form the register value to program in the acl_access control register*/
+static inline u32 acl_acc_ctl(struct lan937x_acl_access_ctl *acc)
+{
+	return (acl_pri_low(acc->pri_low) |
+		acl_tcam_flush(acc->tcam_flush) |
+		acl_tcam_vben(acc->tcam_vben) |
+		acl_tcam_vbi(acc->tcam_vbi) |
+		acl_tcam_row_vld(acc->tcam_row_vld) |
+		acl_row_shift(acc->row_shift) |
+		acl_tcam_req(acc->tcam_req) |
+		acl_tcam_acc(acc->tcam_acc) |
+		acl_num_shift(acc->num_shift) |
+		acl_tcam_addr(acc->tcam_addr));
+}
+
+/*Macros to set values in lan937x_acl_access_ctl*/
+#define clr_data(data)	memset(&(data), 0x00, sizeof(data))
+#define set_pri_low(acc, val)	acc.pri_low = val
+#define set_tcam_flush(acc, val)	acc.tcam_flush = val
+#define set_tcam_vben(acc, val)	acc.tcam_vben = val
+#define set_tcam_vbi(acc, val)	acc.tcam_vbi = val
+#define set_tcam_row_vld(acc, val)	acc.tcam_row_vld = val
+#define set_row_shift(acc, val)	acc.row_shift = val
+#define set_tcam_req(acc, val)	acc.tcam_req = val
+#define set_tcam_acc(acc, val)	acc.tcam_acc = val
+#define set_num_shift(acc, val)	acc.num_shift = val
+#define set_tcam_addr(acc, val)	acc.tcam_addr = val
+
+struct lan937x_acl_byte_en {
+	u8 acl_mask[6];
+	u8 acl_data[6];
+	u8 acl_action[1];
+} __packed;
+
+struct vlan_tag {
+	u16 vlan_tpid;
+	u8 tci[2];
+} __packed;
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_dev.c b/drivers/net/dsa/microchip/lan937x_dev.c
new file mode 100644
index 000000000000..1574d38c8d49
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_dev.c
@@ -0,0 +1,852 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip lan937x dev ops functions
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/iopoll.h>
+#include <linux/of_mdio.h>
+#include <linux/platform_data/microchip-ksz.h>
+#include <linux/phy.h>
+#include <linux/if_bridge.h>
+#include <net/dsa.h>
+#include <net/switchdev.h>
+
+#include "lan937x_reg.h"
+#include "ksz_common.h"
+#include "lan937x_dev.h"
+#include "lan937x_ptp.h"
+#include "lan937x_flower.h"
+
+const struct mib_names lan937x_mib_names[] = {
+	{ 0x00, "rx_hi" },
+	{ 0x01, "rx_undersize" },
+	{ 0x02, "rx_fragments" },
+	{ 0x03, "rx_oversize" },
+	{ 0x04, "rx_jabbers" },
+	{ 0x05, "rx_symbol_err" },
+	{ 0x06, "rx_crc_err" },
+	{ 0x07, "rx_align_err" },
+	{ 0x08, "rx_mac_ctrl" },
+	{ 0x09, "rx_pause" },
+	{ 0x0A, "rx_bcast" },
+	{ 0x0B, "rx_mcast" },
+	{ 0x0C, "rx_ucast" },
+	{ 0x0D, "rx_64_or_less" },
+	{ 0x0E, "rx_65_127" },
+	{ 0x0F, "rx_128_255" },
+	{ 0x10, "rx_256_511" },
+	{ 0x11, "rx_512_1023" },
+	{ 0x12, "rx_1024_1522" },
+	{ 0x13, "rx_1523_2000" },
+	{ 0x14, "rx_2001" },
+	{ 0x15, "tx_hi" },
+	{ 0x16, "tx_late_col" },
+	{ 0x17, "tx_pause" },
+	{ 0x18, "tx_bcast" },
+	{ 0x19, "tx_mcast" },
+	{ 0x1A, "tx_ucast" },
+	{ 0x1B, "tx_deferred" },
+	{ 0x1C, "tx_total_col" },
+	{ 0x1D, "tx_exc_col" },
+	{ 0x1E, "tx_single_col" },
+	{ 0x1F, "tx_mult_col" },
+	{ 0x80, "rx_total" },
+	{ 0x81, "tx_total" },
+	{ 0x82, "rx_discards" },
+	{ 0x83, "tx_discards" },
+};
+
+int lan937x_cfg(struct ksz_device *dev, u32 addr, u8 bits, bool set)
+{
+	return regmap_update_bits(dev->regmap[0], addr, bits, set ? bits : 0);
+}
+
+int lan937x_port_cfg(struct ksz_device *dev, int port, int offset, u8 bits,
+		     bool set)
+{
+	return regmap_update_bits(dev->regmap[0], PORT_CTRL_ADDR(port, offset),
+				  bits, set ? bits : 0);
+}
+
+int lan937x_cfg32(struct ksz_device *dev, u32 addr, u32 bits, bool set)
+{
+	return regmap_update_bits(dev->regmap[2], addr, bits, set ? bits : 0);
+}
+
+int lan937x_pread8(struct ksz_device *dev, int port, int offset, u8 *data)
+{
+	return ksz_read8(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pread16(struct ksz_device *dev, int port, int offset, u16 *data)
+{
+	return ksz_read16(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pread32(struct ksz_device *dev, int port, int offset, u32 *data)
+{
+	return ksz_read32(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pwrite8(struct ksz_device *dev, int port, int offset, u8 data)
+{
+	return ksz_write8(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pwrite16(struct ksz_device *dev, int port, int offset, u16 data)
+{
+	return ksz_write16(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pwrite32(struct ksz_device *dev, int port, int offset, u32 data)
+{
+	return ksz_write32(dev, PORT_CTRL_ADDR(port, offset), data);
+}
+
+int lan937x_pwrite8_bulk(struct ksz_device *dev, int port, int offset,
+			 u8 *data, u8 n)
+{
+	return ksz_write8_bulk(dev, PORT_CTRL_ADDR(port, offset), data, n);
+}
+
+void lan937x_cfg_port_member(struct ksz_device *dev, int port, u8 member)
+{
+	lan937x_pwrite32(dev, port, REG_PORT_VLAN_MEMBERSHIP__4, member);
+}
+
+static void lan937x_flush_dyn_mac_table(struct ksz_device *dev, int port)
+{
+	unsigned int value;
+	u8 data;
+
+	regmap_update_bits(dev->regmap[0], REG_SW_LUE_CTRL_2,
+			   SW_FLUSH_OPTION_M << SW_FLUSH_OPTION_S,
+			   SW_FLUSH_OPTION_DYN_MAC << SW_FLUSH_OPTION_S);
+
+	if (port < dev->info->port_cnt) {
+		/* flush individual port */
+		lan937x_pread8(dev, port, P_STP_CTRL, &data);
+		if (!(data & PORT_LEARN_DISABLE))
+			lan937x_pwrite8(dev, port, P_STP_CTRL,
+					(data | PORT_LEARN_DISABLE));
+		lan937x_cfg(dev, S_FLUSH_TABLE_CTRL, SW_FLUSH_DYN_MAC_TABLE,
+			    true);
+
+		regmap_read_poll_timeout(dev->regmap[0], S_FLUSH_TABLE_CTRL,
+					 value,
+					 !(value & SW_FLUSH_DYN_MAC_TABLE), 10,
+					 1000);
+
+		lan937x_pwrite8(dev, port, P_STP_CTRL, data);
+	} else {
+		/* flush all */
+		lan937x_cfg(dev, S_FLUSH_TABLE_CTRL, SW_FLUSH_STP_TABLE, true);
+	}
+}
+
+static void lan937x_r_mib_cnt(struct ksz_device *dev, int port, u16 addr,
+			      u64 *cnt)
+{
+	unsigned int val;
+	u32 data;
+	int ret;
+
+	/* Enable MIB Counter read */
+	data = MIB_COUNTER_READ;
+	data |= (addr << MIB_COUNTER_INDEX_S);
+	lan937x_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT, data);
+
+	ret = regmap_read_poll_timeout(dev->regmap[2],
+				       PORT_CTRL_ADDR(port,
+						      REG_PORT_MIB_CTRL_STAT),
+				       val, !(val & MIB_COUNTER_READ),
+				       10, 1000);
+	if (ret) {
+		dev_err(dev->dev, "Failed to get MIB\n");
+		return;
+	}
+
+	/* count resets upon read */
+	lan937x_pread32(dev, port, REG_PORT_MIB_DATA, &data);
+	*cnt += data;
+}
+
+void lan937x_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,
+		       u64 *dropped, u64 *cnt)
+{
+	addr = lan937x_mib_names[addr].index;
+	lan937x_r_mib_cnt(dev, port, addr, cnt);
+}
+
+static void lan937x_r_mib_stats64(struct ksz_device *dev, int port)
+{
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+	struct rtnl_link_stats64 *s;
+	u64 *ctr = mib->counters;
+
+	s = &mib->stats64;
+	spin_lock(&mib->stats64_lock);
+
+	s->rx_packets = ctr[lan937x_mib_rx_mcast] +
+			ctr[lan937x_mib_rx_bcast] +
+			ctr[lan937x_mib_rx_ucast] +
+			ctr[lan937x_mib_rx_pause];
+
+	s->tx_packets = ctr[lan937x_mib_tx_mcast] +
+			ctr[lan937x_mib_tx_bcast] +
+			ctr[lan937x_mib_tx_ucast] +
+			ctr[lan937x_mib_tx_pause];
+
+	s->rx_bytes = ctr[lan937x_mib_rx_total];
+	s->tx_bytes = ctr[lan937x_mib_tx_total];
+
+	s->rx_errors = ctr[lan937x_mib_rx_fragments] +
+			ctr[lan937x_mib_rx_jabbers] +
+			ctr[lan937x_mib_rx_sym_err] +
+			ctr[lan937x_mib_rx_align_err] +
+			ctr[lan937x_mib_rx_crc_err];
+
+	s->tx_errors = ctr[lan937x_mib_tx_exc_col] +
+			ctr[lan937x_mib_tx_late_col];
+
+	s->rx_dropped = ctr[lan937x_mib_rx_discard];
+	s->tx_dropped = ctr[lan937x_mib_tx_discard];
+	s->multicast = ctr[lan937x_mib_rx_mcast];
+
+	s->collisions = ctr[lan937x_mib_tx_late_col] +
+			ctr[lan937x_mib_tx_single_col] +
+			ctr[lan937x_mib_tx_mult_col];
+
+	s->rx_length_errors = ctr[lan937x_mib_rx_fragments] +
+			ctr[lan937x_mib_rx_jabbers];
+
+	s->rx_crc_errors = ctr[lan937x_mib_rx_crc_err];
+	s->rx_frame_errors = ctr[lan937x_mib_rx_align_err];
+	s->tx_aborted_errors = ctr[lan937x_mib_tx_exc_col];
+	s->tx_window_errors = ctr[lan937x_mib_tx_late_col];
+
+	spin_unlock(&mib->stats64_lock);
+}
+
+static void lan937x_port_init_cnt(struct ksz_device *dev, int port)
+{
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+
+	/* flush all enabled port MIB counters */
+	mutex_lock(&mib->cnt_mutex);
+	lan937x_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT,
+			 MIB_COUNTER_FLUSH_FREEZE);
+	ksz_write8(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FLUSH);
+	lan937x_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT, 0);
+	mutex_unlock(&mib->cnt_mutex);
+}
+
+int lan937x_reset_switch(struct ksz_device *dev)
+{
+	u32 data32;
+	u8 data8;
+	int ret;
+
+	/* reset switch */
+	ret = lan937x_cfg(dev, REG_SW_OPERATION, SW_RESET, true);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_read8(dev, REG_SW_LUE_CTRL_1, &data8);
+	if (ret < 0)
+		return ret;
+
+	/* Enable Auto Aging */
+	ret = ksz_write8(dev, REG_SW_LUE_CTRL_1, data8 | SW_LINK_AUTO_AGING);
+	if (ret < 0)
+		return ret;
+
+	/* disable interrupts */
+	ret = ksz_write32(dev, REG_SW_INT_MASK__4, SWITCH_INT_MASK);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_PORT_INT_MASK__4, 0xFF);
+	if (ret < 0)
+		return ret;
+
+	return ksz_read32(dev, REG_SW_PORT_INT_STATUS__4, &data32);
+}
+
+static int lan937x_switch_detect(struct ksz_device *dev)
+{
+	u32 id32;
+	int ret;
+
+	/* Read Chip ID */
+	ret = ksz_read32(dev, REG_CHIP_ID0__1, &id32);
+	if (ret < 0)
+		return ret;
+
+	if (id32 != 0 && id32 != 0xffffffff) {
+		dev->chip_id = id32 & 0x00FFFF00;
+		dev_info(dev->dev, "Chip ID: 0x%x", id32);
+		ret = 0;
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+int lan937x_enable_spi_indirect_access(struct ksz_device *dev)
+{
+	u16 data16;
+	u8 data8;
+	int ret;
+
+	ret = ksz_read8(dev, REG_GLOBAL_CTRL_0, &data8);
+	if (ret < 0)
+		return ret;
+
+	/* Check if PHY register is blocked */
+	if (data8 & SW_PHY_REG_BLOCK) {
+		/* Enable Phy access through SPI */
+		data8 &= ~SW_PHY_REG_BLOCK;
+
+		ret = ksz_write8(dev, REG_GLOBAL_CTRL_0, data8);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ksz_read16(dev, REG_VPHY_SPECIAL_CTRL__2, &data16);
+	if (ret < 0)
+		return ret;
+
+	/* Allow SPI access */
+	data16 |= VPHY_SPI_INDIRECT_ENABLE;
+	return ksz_write16(dev, REG_VPHY_SPECIAL_CTRL__2, data16);
+}
+
+static u32 lan937x_get_port_addr(int port, int offset)
+{
+	return PORT_CTRL_ADDR(port, offset);
+}
+
+bool lan937x_is_internal_phy_port(struct ksz_device *dev, int port)
+{
+	/* Check if the port is RGMII */
+	if (port == LAN937X_RGMII_1_PORT || port == LAN937X_RGMII_2_PORT)
+		return false;
+
+	/* Check if the port is SGMII */
+	if (port == LAN937X_SGMII_PORT &&
+	    GET_CHIP_ID_LSB(dev->chip_id) == CHIP_ID_73)
+		return false;
+
+	return true;
+}
+
+bool lan937x_is_rgmii_port(struct ksz_device *dev, int port)
+{
+	/* Check if the port is RGMII */
+	if (port == LAN937X_RGMII_1_PORT || port == LAN937X_RGMII_2_PORT)
+		return true;
+
+	return false;
+}
+
+bool lan937x_is_internal_base_tx_phy_port(struct ksz_device *dev, int port)
+{
+	/* Check if the port is internal tx phy port */
+	if (lan937x_is_internal_phy_port(dev, port) &&
+	    port == LAN937X_TXPHY_PORT)
+		if ((GET_CHIP_ID_LSB(dev->chip_id) == CHIP_ID_71) ||
+		    (GET_CHIP_ID_LSB(dev->chip_id) == CHIP_ID_72))
+			return true;
+
+	return false;
+}
+
+bool lan937x_is_internal_base_t1_phy_port(struct ksz_device *dev, int port)
+{
+	/* Check if the port is internal t1 phy port */
+	if (lan937x_is_internal_phy_port(dev, port) &&
+	    !lan937x_is_internal_base_tx_phy_port(dev, port))
+		return true;
+
+	return false;
+}
+
+static int lan937x_vphy_ind_addr_wr(struct ksz_device *dev, int addr, int reg)
+{
+	u16 temp, addr_base;
+
+	if (lan937x_is_internal_base_tx_phy_port(dev, addr))
+		addr_base = REG_PORT_TX_PHY_CTRL_BASE;
+	else
+		addr_base = REG_PORT_T1_PHY_CTRL_BASE;
+
+	/* get register address based on the logical port */
+	temp = PORT_CTRL_ADDR(addr, (addr_base + (reg << 2)));
+
+	return ksz_write16(dev, REG_VPHY_IND_ADDR__2, temp);
+}
+
+int lan937x_internal_phy_write(struct ksz_device *dev, int addr, int reg,
+			       u16 val)
+{
+	unsigned int value;
+	int ret;
+
+	/* Check for internal phy port */
+	if (!lan937x_is_internal_phy_port(dev, addr))
+		return -EOPNOTSUPP;
+
+	ret = lan937x_vphy_ind_addr_wr(dev, addr, reg);
+	if (ret < 0)
+		return ret;
+
+	/* Write the data to be written to the VPHY reg */
+	ret = ksz_write16(dev, REG_VPHY_IND_DATA__2, val);
+	if (ret < 0)
+		return ret;
+
+	/* Write the Write En and Busy bit */
+	ret = ksz_write16(dev, REG_VPHY_IND_CTRL__2,
+			  (VPHY_IND_WRITE | VPHY_IND_BUSY));
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read_poll_timeout(dev->regmap[1], REG_VPHY_IND_CTRL__2,
+				       value, !(value & VPHY_IND_BUSY), 10,
+				       1000);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to write phy register\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int lan937x_internal_phy_read(struct ksz_device *dev, int addr, int reg,
+			      u16 *val)
+{
+	unsigned int value;
+	int ret;
+
+	/* Check for internal phy port, return 0xffff for non-existent phy */
+	if (!lan937x_is_internal_phy_port(dev, addr))
+		return 0xffff;
+
+	ret = lan937x_vphy_ind_addr_wr(dev, addr, reg);
+	if (ret < 0)
+		return ret;
+
+	/* Write Read and Busy bit to start the transaction */
+	ret = ksz_write16(dev, REG_VPHY_IND_CTRL__2, VPHY_IND_BUSY);
+	if (ret < 0)
+		return ret;
+
+	ret = regmap_read_poll_timeout(dev->regmap[1], REG_VPHY_IND_CTRL__2,
+				       value, !(value & VPHY_IND_BUSY), 10,
+				       1000);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to read phy register\n");
+		return ret;
+	}
+
+	/* Read the VPHY register which has the PHY data */
+	return ksz_read16(dev, REG_VPHY_IND_DATA__2, val);
+}
+
+static void lan937x_config_gbit(struct ksz_device *dev, bool gbit, u8 *data)
+{
+	if (gbit)
+		*data &= ~PORT_MII_NOT_1GBIT;
+	else
+		*data |= PORT_MII_NOT_1GBIT;
+}
+
+static void lan937x_update_rgmii_tx_rx_delay(struct ksz_device *dev, int port,
+					      bool is_tx)
+{
+	u16 data16;
+	int reg;
+	u8 val;
+
+	/* Apply different codes based on the ports as per characterization
+	 * results
+	 */
+	if (is_tx) {
+		reg = REG_PORT_XMII_CTRL_5;
+		val = (port == LAN937X_RGMII_1_PORT) ? RGMII_1_TX_DELAY_2NS :
+						       RGMII_2_TX_DELAY_2NS;
+	} else {
+		reg = REG_PORT_XMII_CTRL_4;
+		val = (port == LAN937X_RGMII_1_PORT) ? RGMII_1_RX_DELAY_2NS :
+						       RGMII_2_RX_DELAY_2NS;
+	}
+
+	lan937x_pread16(dev, port, reg, &data16);
+
+	/* clear tune Adjust */
+	data16 &= ~PORT_TUNE_ADJ;
+	data16 |= (val << 7);
+	lan937x_pwrite16(dev, port, reg, data16);
+
+	data16 |= PORT_DLL_RESET;
+	/* write DLL reset to take effect */
+	lan937x_pwrite16(dev, port, reg, data16);
+}
+
+static void lan937x_apply_rgmii_delay(struct ksz_device *dev, int port,
+				      phy_interface_t interface, u8 val)
+{
+	struct ksz_port *p = &dev->ports[port];
+
+	/* Clear Ingress & Egress internal delay enabled bits */
+	val &= ~(PORT_RGMII_ID_EG_ENABLE | PORT_RGMII_ID_IG_ENABLE);
+
+	/* if the delay is 0, do not enable DLL */
+	if (p->rgmii_tx_val) {
+		lan937x_update_rgmii_tx_rx_delay(dev, port, true);
+		dev_info(dev->dev, "Applied rgmii tx delay for the port %d\n",
+			 port);
+		val |= PORT_RGMII_ID_EG_ENABLE;
+	}
+
+	/* if the delay is 0, do not enable DLL */
+	if (p->rgmii_rx_val) {
+		lan937x_update_rgmii_tx_rx_delay(dev, port, false);
+		dev_info(dev->dev, "Applied rgmii rx delay for the port %d\n",
+			 port);
+		val |= PORT_RGMII_ID_IG_ENABLE;
+	}
+
+	/* Enable RGMII internal delays */
+	lan937x_pwrite8(dev, port, REG_PORT_XMII_CTRL_1, val);
+}
+
+void lan937x_mac_config(struct ksz_device *dev, int port,
+			phy_interface_t interface)
+{
+	u8 data8;
+
+	lan937x_pread8(dev, port, REG_PORT_XMII_CTRL_1, &data8);
+
+	/* clear MII selection & set it based on interface later */
+	data8 &= ~PORT_MII_SEL_M;
+
+	/* configure MAC based on interface */
+	switch (interface) {
+	case PHY_INTERFACE_MODE_MII:
+		lan937x_config_gbit(dev, false, &data8);
+		data8 |= PORT_MII_SEL;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		lan937x_config_gbit(dev, false, &data8);
+		data8 |= PORT_RMII_SEL;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+		lan937x_config_gbit(dev, true, &data8);
+		data8 |= PORT_RGMII_SEL;
+
+		/* Apply rgmii internal delay for the mac */
+		lan937x_apply_rgmii_delay(dev, port, interface, data8);
+
+		/* rgmii delay configuration is already applied above,
+		 * hence return from here as no changes required
+		 */
+		return;
+	default:
+		dev_err(dev->dev, "Unsupported interface '%s' for port %d\n",
+			phy_modes(interface), port);
+		return;
+	}
+
+	/* Write the updated value */
+	lan937x_pwrite8(dev, port, REG_PORT_XMII_CTRL_1, data8);
+}
+
+void lan937x_config_interface(struct ksz_device *dev, int port,
+			      int speed, int duplex,
+			      bool tx_pause, bool rx_pause)
+{
+	u8 xmii_ctrl0, xmii_ctrl1;
+
+	lan937x_pread8(dev, port, REG_PORT_XMII_CTRL_0, &xmii_ctrl0);
+	lan937x_pread8(dev, port, REG_PORT_XMII_CTRL_1, &xmii_ctrl1);
+
+	switch (speed) {
+	case SPEED_1000:
+		lan937x_config_gbit(dev, true, &xmii_ctrl1);
+		break;
+	case SPEED_100:
+		lan937x_config_gbit(dev, false, &xmii_ctrl1);
+		xmii_ctrl0 |= PORT_MAC_SPEED_100;
+		break;
+	case SPEED_10:
+		lan937x_config_gbit(dev, false, &xmii_ctrl1);
+		xmii_ctrl0 &= ~PORT_MAC_SPEED_100;
+		break;
+	default:
+		dev_err(dev->dev, "Unsupported speed on port %d: %d\n",
+			port, speed);
+		return;
+	}
+
+	if (duplex)
+		xmii_ctrl0 |= PORT_FULL_DUPLEX;
+	else
+		xmii_ctrl0 &= ~PORT_FULL_DUPLEX;
+
+	if (tx_pause)
+		xmii_ctrl0 |= PORT_TX_FLOW_CTRL;
+	else
+		xmii_ctrl1 &= ~PORT_TX_FLOW_CTRL;
+
+	if (rx_pause)
+		xmii_ctrl0 |= PORT_RX_FLOW_CTRL;
+	else
+		xmii_ctrl0 &= ~PORT_RX_FLOW_CTRL;
+
+	lan937x_pwrite8(dev, port, REG_PORT_XMII_CTRL_0, xmii_ctrl0);
+	lan937x_pwrite8(dev, port, REG_PORT_XMII_CTRL_1, xmii_ctrl1);
+}
+
+void lan937x_port_setup(struct ksz_device *dev, int port, bool cpu_port)
+{
+	struct dsa_switch *ds = dev->ds;
+	u8 member;
+
+	/* enable tag tail for host port */
+	if (cpu_port)
+		lan937x_port_cfg(dev, port, REG_PORT_CTRL_0,
+				 PORT_TAIL_TAG_ENABLE, true);
+
+	/* disable frame check length field */
+	lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_0, PORT_FR_CHK_LENGTH,
+			 false);
+
+	/* set back pressure for half duplex */
+	lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_1, PORT_BACK_PRESSURE,
+			 true);
+
+	/* enable 802.1p priority */
+	lan937x_port_cfg(dev, port, P_PRIO_CTRL, PORT_802_1P_PRIO_ENABLE, true);
+
+	if (!lan937x_is_internal_phy_port(dev, port))
+		lan937x_port_cfg(dev, port, REG_PORT_XMII_CTRL_0,
+				 PORT_TX_FLOW_CTRL | PORT_RX_FLOW_CTRL,
+				 true);
+
+	if (dsa_is_cpu_port(ds, port))
+		member = (dsa_user_ports(ds) | BIT(dev->dsa_port));
+	else
+		member = BIT(dsa_upstream_port(ds, port));
+
+	lan937x_cfg_port_member(dev, port, member);
+}
+
+static int lan937x_sw_mdio_read(struct mii_bus *bus, int addr, int regnum)
+{
+	struct ksz_device *dev = bus->priv;
+	u16 val;
+	int ret;
+
+	if (regnum & MII_ADDR_C45)
+		return -EOPNOTSUPP;
+
+	ret = lan937x_internal_phy_read(dev, addr, regnum, &val);
+	if (ret < 0)
+		return ret;
+
+	return val;
+}
+
+static irqreturn_t lan937x_switch_irq_thread(int irq, void *dev_id)
+{
+	struct ksz_device *dev = dev_id;
+	irqreturn_t result = IRQ_NONE;
+	u32 data;
+	int port;
+	int ret;
+
+	/* Read global interrupt status register */
+	ret = ksz_read32(dev, REG_SW_INT_STATUS__4, &data);
+	if (ret)
+		return result;
+
+	if (data & POR_READY_INT) {
+		ret = ksz_write32(dev, REG_SW_INT_STATUS__4, POR_READY_INT);
+		if (ret)
+			return result;
+	}
+
+	/*Read the Port Interrupt status register */
+	ret = ksz_read32(dev, REG_SW_PORT_INT_STATUS__4, &data);
+	if (ret)
+		return result;
+
+	for (port = 0; port < dev->info->port_cnt; port++) {
+		if (data & BIT(port)) {
+			u32 prtaddr;
+			u8 data8;
+
+			prtaddr = PORT_CTRL_ADDR(port, REG_PORT_INT_STATUS);
+
+			/* Read port interrupt status register */
+			ret = ksz_read8(dev, prtaddr, &data8);
+			if (ret)
+				return result;
+
+			if (data8 & PORT_PTP_INT) {
+				if (lan937x_ptp_port_interrupt(dev, port) !=
+				    IRQ_NONE)
+					result = IRQ_HANDLED;
+			}
+
+			if (data8 & PORT_ACL_INT) {
+				if (lan937x_acl_isr(dev, port) != IRQ_NONE)
+					result = IRQ_HANDLED;
+			}
+
+			if (data8 & PORT_QCI_INT) {
+				if (lan937x_qci_cntr_isr(dev, port) != IRQ_NONE)
+					result = IRQ_HANDLED;
+			}
+		}
+	}
+
+	return result;
+}
+
+static int lan937x_sw_mdio_write(struct mii_bus *bus, int addr, int regnum,
+				 u16 val)
+{
+	struct ksz_device *dev = bus->priv;
+
+	if (regnum & MII_ADDR_C45)
+		return -EOPNOTSUPP;
+
+	return lan937x_internal_phy_write(dev, addr, regnum, val);
+}
+
+static int lan937x_mdio_register(struct ksz_device *dev)
+{
+	struct dsa_switch *ds = dev->ds;
+	struct device_node *mdio_np;
+	struct mii_bus *bus;
+	int ret;
+
+	mdio_np = of_get_child_by_name(dev->dev->of_node, "mdio");
+	if (!mdio_np) {
+		dev_err(ds->dev, "no MDIO bus node\n");
+		return -ENODEV;
+	}
+
+	bus = devm_mdiobus_alloc(ds->dev);
+	if (!bus) {
+		of_node_put(mdio_np);
+		return -ENOMEM;
+	}
+
+	bus->priv = dev;
+	bus->read = lan937x_sw_mdio_read;
+	bus->write = lan937x_sw_mdio_write;
+	bus->name = "lan937x slave smi";
+	snprintf(bus->id, MII_BUS_ID_SIZE, "SMI-%d", dev->smi_index);
+	bus->parent = ds->dev;
+	bus->phy_mask = ~ds->phys_mii_mask;
+
+	ds->slave_mii_bus = bus;
+
+	ret = devm_of_mdiobus_register(ds->dev, bus, mdio_np);
+	if (ret) {
+		dev_err(ds->dev, "unable to register MDIO bus %s\n",
+			bus->id);
+	}
+
+	of_node_put(mdio_np);
+
+	return ret;
+}
+
+static int lan937x_switch_init(struct ksz_device *dev)
+{
+	int ret;
+
+	dev->ds->ops = &lan937x_switch_ops;
+
+	ret = lan937x_reset_switch(dev);
+	if (ret) {
+		dev_err(dev->dev, "failed to reset switch\n");
+		return ret;
+	}
+
+	dev->port_mask = (1 << dev->info->port_cnt) - 1;
+
+	if (dev->irq > 0) {
+		unsigned long irqflags =
+			irqd_get_trigger_type(irq_get_irq_data(dev->irq));
+
+		irqflags |= IRQF_ONESHOT;
+		irqflags |= IRQF_SHARED;
+		ret = devm_request_threaded_irq(dev->dev, dev->irq, NULL,
+						lan937x_switch_irq_thread,
+						irqflags, dev_name(dev->dev),
+						dev);
+		if (ret) {
+			dev_err(dev->dev, "failed to request IRQ.\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void lan937x_switch_exit(struct ksz_device *dev)
+{
+	lan937x_reset_switch(dev);
+}
+
+static int lan937x_init(struct ksz_device *dev)
+{
+	int ret;
+
+	ret = lan937x_switch_init(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "failed to initialize the switch");
+		return ret;
+	}
+
+	/* enable Indirect Access from SPI to the VPHY registers */
+	ret = lan937x_enable_spi_indirect_access(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "failed to enable spi indirect access");
+		return ret;
+	}
+
+	ret = lan937x_mdio_register(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "failed to register the mdio");
+		return ret;
+	}
+
+	return 0;
+}
+
+const struct ksz_dev_ops lan937x_dev_ops = {
+	.get_port_addr = lan937x_get_port_addr,
+	.cfg_port_member = lan937x_cfg_port_member,
+	.flush_dyn_mac_table = lan937x_flush_dyn_mac_table,
+	.port_setup = lan937x_port_setup,
+	.r_mib_cnt = lan937x_r_mib_cnt,
+	.r_mib_pkt = lan937x_r_mib_pkt,
+	.port_init_cnt = lan937x_port_init_cnt,
+	.r_mib_stat64 = lan937x_r_mib_stats64,
+	.shutdown = lan937x_reset_switch,
+	.detect = lan937x_switch_detect,
+	.init = lan937x_init,
+	.exit = lan937x_switch_exit,
+};
diff --git a/drivers/net/dsa/microchip/lan937x_dev.h b/drivers/net/dsa/microchip/lan937x_dev.h
new file mode 100644
index 000000000000..28bed3395ad9
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_dev.h
@@ -0,0 +1,125 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip lan937x dev ops headers
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+
+#ifndef __LAN937X_CFG_H
+#define __LAN937X_CFG_H
+
+int lan937x_cfg(struct ksz_device *dev, u32 addr, u8 bits, bool set);
+int lan937x_port_cfg(struct ksz_device *dev, int port, int offset,
+		     u8 bits, bool set);
+int lan937x_cfg32(struct ksz_device *dev, u32 addr, u32 bits, bool set);
+int lan937x_pread8(struct ksz_device *dev, int port, int offset,
+		   u8 *data);
+int lan937x_pread16(struct ksz_device *dev, int port, int offset,
+		    u16 *data);
+int lan937x_pread32(struct ksz_device *dev, int port, int offset,
+		    u32 *data);
+int lan937x_pwrite8(struct ksz_device *dev, int port,
+		    int offset, u8 data);
+int lan937x_pwrite16(struct ksz_device *dev, int port,
+		     int offset, u16 data);
+int lan937x_pwrite32(struct ksz_device *dev, int port,
+		     int offset, u32 data);
+int lan937x_pwrite8_bulk(struct ksz_device *dev, int port, int offset,
+			 u8 *data, u8 n);
+int lan937x_internal_phy_write(struct ksz_device *dev, int addr,
+			       int reg, u16 val);
+int lan937x_internal_phy_read(struct ksz_device *dev, int addr,
+			      int reg, u16 *val);
+bool lan937x_is_internal_phy_port(struct ksz_device *dev, int port);
+bool lan937x_is_internal_base_tx_phy_port(struct ksz_device *dev, int port);
+bool lan937x_is_internal_base_t1_phy_port(struct ksz_device *dev, int port);
+bool lan937x_is_rgmii_port(struct ksz_device *dev, int port);
+int lan937x_reset_switch(struct ksz_device *dev);
+void lan937x_cfg_port_member(struct ksz_device *dev, int port,
+			     u8 member);
+void lan937x_port_setup(struct ksz_device *dev, int port, bool cpu_port);
+int lan937x_enable_spi_indirect_access(struct ksz_device *dev);
+void lan937x_config_interface(struct ksz_device *dev, int port,
+			      int speed, int duplex,
+			      bool tx_pause, bool rx_pause);
+void lan937x_mac_config(struct ksz_device *dev, int port,
+			phy_interface_t interface);
+void lan937x_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,
+		       u64 *dropped, u64 *cnt);
+
+struct mib_names {
+	int index;
+	char string[ETH_GSTRING_LEN];
+};
+
+enum lan937x_mib_list {
+	lan937x_mib_rx_hi_pri_byte = 0,
+	lan937x_mib_rx_undersize,
+	lan937x_mib_rx_fragments,
+	lan937x_mib_rx_oversize,
+	lan937x_mib_rx_jabbers,
+	lan937x_mib_rx_sym_err,
+	lan937x_mib_rx_crc_err,
+	lan937x_mib_rx_align_err,
+	lan937x_mib_rx_mac_ctrl,
+	lan937x_mib_rx_pause,
+	lan937x_mib_rx_bcast,
+	lan937x_mib_rx_mcast,
+	lan937x_mib_rx_ucast,
+	lan937x_mib_rx_64_or_less,
+	lan937x_mib_rx_65_127,
+	lan937x_mib_rx_128_255,
+	lan937x_mib_rx_256_511,
+	lan937x_mib_rx_512_1023,
+	lan937x_mib_rx_1024_1522,
+	lan937x_mib_rx_1523_2000,
+	lan937x_mib_rx_2001,
+	lan937x_mib_tx_hi_pri_byte,
+	lan937x_mib_tx_late_col,
+	lan937x_mib_tx_pause,
+	lan937x_mib_tx_bcast,
+	lan937x_mib_tx_mcast,
+	lan937x_mib_tx_ucast,
+	lan937x_mib_tx_deferred,
+	lan937x_mib_tx_total_col,
+	lan937x_mib_tx_exc_col,
+	lan937x_mib_tx_single_col,
+	lan937x_mib_tx_mult_col,
+	lan937x_mib_rx_total,
+	lan937x_mib_tx_total,
+	lan937x_mib_rx_discard,
+	lan937x_mib_tx_discard,
+};
+
+struct lan_alu_struct {
+	/* entry 1 */
+	u32	is_static:1;
+	u32	is_src_filter:1;
+	u32	is_dst_filter:1;
+	u32	prio_age:3;
+	u32	_reserv_0_1:23;
+	u32	mstp:3;
+	/* entry 2 */
+	u32	is_override:1;
+	u32	is_use_fid:1;
+	u32	_reserv_1_1:22;
+	u32	port_forward:8;
+	/* entry 3 & 4*/
+	u32	_reserv_2_1:9;
+	u32	fid:7;
+	u8	mac[ETH_ALEN];
+};
+
+struct lan937x_vlan {
+	/* entry 1 */
+	bool valid;
+	u8 fid;
+	/* entry 2 */
+	u32 untag_prtmap;
+	/* entry 3 */
+	u32 fwd_map;
+};
+
+extern const struct dsa_switch_ops lan937x_switch_ops;
+extern const struct ksz_dev_ops lan937x_dev_ops;
+extern const struct mib_names lan937x_mib_names[];
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_devlink.c b/drivers/net/dsa/microchip/lan937x_devlink.c
new file mode 100644
index 000000000000..567c1cb37010
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_devlink.c
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip LAN937X devlink implementation
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+
+#include "ksz_common.h"
+#include "lan937x_reg.h"
+#include "lan937x_dev.h"
+#include "lan937x_devlink.h"
+
+static int lan937x_cut_through_get(struct ksz_device *dev, u16 *value)
+{
+	*value = dev->cut_through_enable;
+
+	return 0;
+}
+
+/* Devlink param is not accepting the hex decimal number. So as of now
+ * 1000, 2000, is used to differentiate the lan1, 2 and so on.
+ * Bit 0 to 7 corresponds to each queue. So if 1255 then for lan1 all the
+ * queues are cut-through enabled.
+ */
+static int lan937x_cut_through_set(struct ksz_device *dev, u16 value)
+{
+	struct dsa_switch *ds = dev->ds;
+	u8 queue = (value % 1000);
+	u8 port = (value / 1000);
+	u8 tas_gate_ctl;
+	bool enable;
+	int ret;
+	u8 i;
+
+	if ((port == 0) || (port > ds->num_ports)) {
+		dev_err(dev->dev, "Port number should be from 1 to %d",
+			ds->num_ports);
+		return -EINVAL;
+	}
+
+	//Port starts from value 0
+	port = port - 1;
+
+	if (!dsa_is_user_port(ds, port)) {
+		dev_err(dev->dev, "Port is not a user port");
+		return -EINVAL;
+	}
+
+	ret = lan937x_pread8(dev, port, REG_PORT_TAS_GATE_CTRL__1,
+			     &tas_gate_ctl);
+	if (ret)
+		return ret;
+
+	if (!(tas_gate_ctl & TAS_GATE_ENABLE)) {
+		dev_err(dev->dev, "TAS should be enabled before cut-through");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ds->num_tx_queues; i++) {
+		ret = lan937x_pwrite32(dev, port, REG_PORT_MTI_QUEUE_INDEX__4,
+				       i);
+		if (ret)
+			return ret;
+
+		if (queue & (1<<i))
+			enable = 1;
+		else
+			enable = 0;
+
+		ret = lan937x_port_cfg(dev, port, REG_PORT_TAS_CTL__1,
+				       TAS_CUT_THROUGH, enable);
+		if (ret)
+			return ret;
+	}
+
+	dev->cut_through_enable = value;
+
+	return 0;
+}
+
+enum lan937x_devlink_param_id {
+	LAN937X_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,
+	LAN937X_DEVLINK_PARAM_ID_CUT_THROUGH,
+};
+
+int lan937x_devlink_param_get(struct dsa_switch *ds, u32 id,
+			      struct devlink_param_gset_ctx *ctx)
+{
+	struct ksz_device *dev = ds->priv;
+	int ret;
+
+	switch (id) {
+	case LAN937X_DEVLINK_PARAM_ID_CUT_THROUGH:
+		ret = lan937x_cut_through_get(dev, &ctx->val.vu16);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+int lan937x_devlink_param_set(struct dsa_switch *ds, u32 id,
+			      struct devlink_param_gset_ctx *ctx)
+{
+	struct ksz_device *dev = ds->priv;
+	int ret;
+
+	switch (id) {
+	case LAN937X_DEVLINK_PARAM_ID_CUT_THROUGH:
+		ret = lan937x_cut_through_set(dev, ctx->val.vu16);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct devlink_param lan937x_devlink_params[] = {
+	DSA_DEVLINK_PARAM_DRIVER(LAN937X_DEVLINK_PARAM_ID_CUT_THROUGH,
+				 "cut_through", DEVLINK_PARAM_TYPE_U16,
+				 BIT(DEVLINK_PARAM_CMODE_RUNTIME)),
+};
+
+static int lan937x_init_devlink_params(struct dsa_switch *ds)
+{
+	return dsa_devlink_params_register(ds, lan937x_devlink_params,
+					   ARRAY_SIZE(lan937x_devlink_params));
+}
+
+static void lan937x_exit_devlink_params(struct dsa_switch *ds)
+{
+	dsa_devlink_params_unregister(ds, lan937x_devlink_params,
+				      ARRAY_SIZE(lan937x_devlink_params));
+}
+
+int lan937x_devlink_info_get(struct dsa_switch *ds,
+			     struct devlink_info_req *req,
+			     struct netlink_ext_ack *extack)
+{
+	int ret;
+
+	ret = devlink_info_driver_name_put(req, "lan937x");
+	if (ret)
+		return ret;
+
+	ret = devlink_info_version_fixed_put(
+		req, DEVLINK_INFO_VERSION_GENERIC_ASIC_ID, "lan937x");
+	return ret;
+}
+
+int lan937x_devlink_init(struct dsa_switch *ds)
+{
+	int ret;
+
+	ret = lan937x_init_devlink_params(ds);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void lan937x_devlink_exit(struct dsa_switch *ds)
+{
+	lan937x_exit_devlink_params(ds);
+}
diff --git a/drivers/net/dsa/microchip/lan937x_devlink.h b/drivers/net/dsa/microchip/lan937x_devlink.h
new file mode 100644
index 000000000000..60ee764e5c59
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_devlink.h
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2021 Microchip Technology Inc.
+ */
+
+#ifndef _LAN937x_DEVLINK_H
+#define _LAN937x_DEVLINK_H
+
+
+int lan937x_devlink_init(struct dsa_switch *ds);
+void lan937x_devlink_exit(struct dsa_switch *ds);
+int lan937x_devlink_param_get(struct dsa_switch *ds, u32 id,
+			      struct devlink_param_gset_ctx *ctx);
+int lan937x_devlink_param_set(struct dsa_switch *ds, u32 id,
+			      struct devlink_param_gset_ctx *ctx);
+int lan937x_devlink_info_get(struct dsa_switch *ds,
+			     struct devlink_info_req *req,
+			     struct netlink_ext_ack *extack);
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_flower.c b/drivers/net/dsa/microchip/lan937x_flower.c
new file mode 100644
index 000000000000..079b2c59864e
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_flower.c
@@ -0,0 +1,1299 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip LAN937X switch driver main logic
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/iopoll.h>
+#include <linux/phy.h>
+#include <linux/if_bridge.h>
+#include <net/dsa.h>
+#include <net/switchdev.h>
+#include "lan937x_reg.h"
+#include "lan937x_ptp.h"
+#include "ksz_common.h"
+#include "lan937x_dev.h"
+#include "lan937x_tc.h"
+#include "lan937x_flower.h"
+#include "lan937x_acl.h"
+
+struct lan937x_flr_blk *lan937x_get_flr_blk(struct ksz_device *dev, int port)
+{
+	struct ksz_port *p = &dev->ports[port];
+
+	return p->priv;
+}
+
+struct lan937x_p_res *lan937x_get_flr_res(struct ksz_device *dev, int port)
+{
+	struct lan937x_flr_blk *blk = lan937x_get_flr_blk(dev, port);
+
+	return &blk->res;
+}
+
+static int lan937x_assign_stream_filter(struct ksz_device *dev, int port,
+					u8 *stream_idx)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	int i;
+
+	for (i = 0; i < LAN937X_NUM_STREAM_FILTERS; i++) {
+		if (!(res->stream_filters_used[i])) {
+			*stream_idx = i;
+
+			return 0;
+		}
+	}
+	return -ENOSPC;
+}
+
+static int lan937x_check_tc_pol_availability(struct ksz_device *dev, int port,
+					     int traffic_class)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+
+	if (res->tc_policers_used[traffic_class])
+		return -ENOSPC;
+
+	return 0;
+}
+
+static int lan937x_assign_tcam_counters(struct ksz_device *dev, int port,
+					u8 *countr)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u8 i;
+
+	for (i = 0; i < LAN937x_NUM_TCAM_COUNTERS; i++) {
+		if (!(res->tcam_frm_counters[i])) {
+			*countr = i;
+
+			return 0;
+		}
+	}
+	/* Invalid Value */
+	*countr = STATS_COUNTER_NOT_ASSIGNED;
+
+	return -ENOSPC;
+}
+
+int lan937x_assign_tcam_entries(struct ksz_device *dev, int port,
+				u8 num_entry_reqd, u8 *tcam_idx)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	int i, j, count;
+
+	for (i = 0; i < LAN937X_NUM_TCAM_ENTRIES; i++) {
+		count = 0;
+		for (j = 0; j < num_entry_reqd; j++) {
+			if (i + j >= LAN937X_NUM_TCAM_ENTRIES)
+				goto out;
+
+			if (!(res->tcam_entries_used[i + j]))
+				count++;
+		}
+
+		if (count == num_entry_reqd) {
+			*tcam_idx = i;
+
+			return 0;
+		}
+	}
+out:
+	return -ENOSPC;
+}
+
+static struct lan937x_flower_rule *lan937x_rule_find(struct ksz_device *dev,
+						     int port,
+						     unsigned long cookie)
+{
+	struct lan937x_flower_rule *rule;
+	struct lan937x_flr_blk *blk = lan937x_get_flr_blk(dev, port);
+
+	list_for_each_entry(rule, &blk->rules, list) {
+		if (rule->cookie == cookie)
+			return rule;
+	}
+
+	return NULL;
+}
+
+static int lan937x_flower_parse_key(struct netlink_ext_ack *extack,
+				    struct flow_cls_offload *cls,
+				    struct lan937x_flower_filter *filter)
+{
+	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+	struct flow_dissector *dissector = rule->match.dissector;
+	struct lan937x_key *key = &filter->key;
+	bool is_bcast_dmac = false;
+	u16 n_proto_mask = 0;
+	u16 n_proto_key = 0;
+	u16 addr_type = 0;
+
+	if (dissector->used_keys &
+	    ~(BIT(FLOW_DISSECTOR_KEY_BASIC) |
+	      BIT(FLOW_DISSECTOR_KEY_CONTROL) |
+	      BIT(FLOW_DISSECTOR_KEY_VLAN) |
+	      BIT(FLOW_DISSECTOR_KEY_ETH_ADDRS) |
+	      BIT(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |
+	      BIT(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |
+	      BIT(FLOW_DISSECTOR_KEY_IP) |
+	      BIT(FLOW_DISSECTOR_KEY_PORTS))) {
+		NL_SET_ERR_MSG_MOD(extack, "Unsupported keys used");
+		return -EOPNOTSUPP;
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {
+		struct flow_match_control match;
+
+		flow_rule_match_control(rule, &match);
+		addr_type = match.key->addr_type;
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {
+		struct flow_match_basic match;
+
+		flow_rule_match_basic(rule, &match);
+		n_proto_key = ntohs(match.key->n_proto);
+		n_proto_mask = ntohs(match.mask->n_proto);
+
+		if (n_proto_key == ETH_P_ALL) {
+			n_proto_key = 0;
+			n_proto_mask = 0;
+		}
+
+		key->ethtype.value = (n_proto_key);
+		key->ethtype.mask = (n_proto_mask);
+		key->acl_dissector_map |= ETHTYPE_DISSECTOR_PRESENT;
+
+		if (n_proto_key == ETH_P_IP) {
+			key->ipv4.proto.value = match.key->ip_proto;
+			key->ipv4.proto.mask = match.mask->ip_proto;
+			key->acl_dissector_map |= IPV4_PROTO_DISSECTOR_PRESENT;
+		}
+		if (n_proto_key == ETH_P_IPV6) {
+			key->ipv6.next_hdr.value = match.key->ip_proto;
+			key->ipv6.next_hdr.mask = match.mask->ip_proto;
+			key->acl_dissector_map |= IPV6_NXTHDR_DISSECTOR_PRESENT;
+		}
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {
+		u8 bcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+		u8 null[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+		struct flow_match_eth_addrs match;
+
+		flow_rule_match_eth_addrs(rule, &match);
+
+		if (!ether_addr_equal_masked(match.key->src, null,
+					     match.mask->src)) {
+			key->src_mac.mask = ether_addr_to_u64(match.mask->src);
+			key->src_mac.value = ether_addr_to_u64(match.key->src);
+			key->acl_dissector_map |= SRC_MAC_DISSECTOR_PRESENT;
+		}
+		is_bcast_dmac = ether_addr_equal(match.key->dst, bcast);
+		key->dst_mac.mask = ether_addr_to_u64(match.mask->dst);
+		key->dst_mac.value = ether_addr_to_u64(match.key->dst);
+		key->acl_dissector_map |= DST_MAC_DISSECTOR_PRESENT;
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {
+		struct flow_match_vlan match;
+
+		flow_rule_match_vlan(rule, &match);
+		if (match.mask->vlan_id) {
+			key->vlan_id.value = match.key->vlan_id;
+			key->vlan_id.mask = match.mask->vlan_id;
+			key->acl_dissector_map |= VLAN_ID_DISSECTOR_PRESENT;
+		}
+
+		if (match.mask->vlan_priority) {
+			key->vlan_prio.value = match.key->vlan_priority;
+			key->vlan_prio.mask = match.mask->vlan_priority;
+			key->acl_dissector_map |= VLAN_PCP_DISSECTOR_PRESENT;
+		}
+	}
+
+	if (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
+		struct flow_match_ipv4_addrs match;
+		u8 *tmp;
+
+		flow_rule_match_ipv4_addrs(rule, &match);
+
+		tmp = &key->ipv4.sip.value[0];
+		memcpy(tmp, &match.key->src, 4);
+
+		tmp = &key->ipv4.sip.mask[0];
+		memcpy(tmp, &match.mask->src, 4);
+
+		tmp = &key->ipv4.dip.value[0];
+		memcpy(tmp, &match.key->dst, 4);
+
+		tmp = &key->ipv4.dip.mask[0];
+		memcpy(tmp, &match.mask->dst, 4);
+
+		key->acl_dissector_map |= (IPV4_SRC_IP_DISSECTOR_PRESENT |
+					   IPV4_DST_IP_DISSECTOR_PRESENT);
+	}
+
+	if (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
+		struct flow_match_ipv6_addrs match;
+		u8 *tmp;
+
+		flow_rule_match_ipv6_addrs(rule, &match);
+
+		tmp = &key->ipv6.sip.value[0];
+		memcpy(tmp, &match.key->src.s6_addr[0], 16);
+
+		tmp = &key->ipv6.sip.mask[0];
+		memcpy(tmp, &match.mask->src.s6_addr[0], 16);
+
+		tmp = &key->ipv6.dip.value[0];
+		memcpy(tmp, &match.key->dst.s6_addr[0], 16);
+
+		tmp = &key->ipv6.dip.mask[0];
+		memcpy(tmp, &match.mask->dst.s6_addr[0], 16);
+
+		key->acl_dissector_map |= (IPV6_SRC_IP_DISSECTOR_PRESENT |
+					   IPV6_DST_IP_DISSECTOR_PRESENT);
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_IP)) {
+		struct flow_match_ip match;
+
+		flow_rule_match_ip(rule, &match);
+		if (n_proto_key == ETH_P_IP) {
+			key->ipv4.tos.value = match.key->tos;
+			key->ipv4.tos.mask = match.mask->tos;
+
+			key->ipv4.ttl.value = match.key->ttl;
+			key->ipv4.ttl.mask = match.mask->ttl;
+
+			key->acl_dissector_map |= (IPV4_TOS_DISSECTOR_PRESENT |
+						   IPV4_TTL_DISSECTOR_PRESENT);
+		}
+
+		if (n_proto_key == ETH_P_IPV6) {
+			key->ipv6.tc.value = match.key->tos;
+			key->ipv6.tc.mask = match.mask->tos;
+
+			key->ipv6.hop.value = match.key->ttl;
+			key->ipv6.hop.mask = match.mask->ttl;
+
+			key->acl_dissector_map |= (IPV6_TC_DISSECTOR_PRESENT |
+						   IPV6_HOP_DISSECTOR_PRESENT);
+		}
+	}
+
+	if (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {
+		struct flow_match_ports match;
+
+		flow_rule_match_ports(rule, &match);
+
+		key->src_port.value = ntohs(match.key->src);
+		key->src_port.mask =  ntohs(match.mask->src);
+		key->dst_port.value = ntohs(match.key->dst);
+		key->dst_port.mask = ntohs(match.mask->dst);
+		key->acl_dissector_map |= (L4_SRC_PORT_DISSECTOR_PRESENT |
+					   L4_DST_PORT_DISSECTOR_PRESENT);
+	}
+
+	if (key->acl_dissector_map == DST_MAC_DISSECTOR_PRESENT &&
+	    is_bcast_dmac) {
+		filter->type = LAN937x_BCAST_FILTER;
+	} else if (key->acl_dissector_map & (VLAN_ID_DISSECTOR_PRESENT |
+					  VLAN_PCP_DISSECTOR_PRESENT)){
+		filter->type = LAN937x_VLAN_AWARE_FILTER;
+	} else {
+		filter->type = LAN937x_VLAN_UNAWARE_FILTER;
+	}
+
+	return 0;
+}
+
+static int lan937x_setup_bcast_policer(struct ksz_device *dev,
+				       struct netlink_ext_ack *extack, int port,
+				       struct lan937x_flower_rule *rule)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+
+	if (res->broadcast_pol_used) {
+		NL_SET_ERR_MSG_MOD(extack, "Broadcast Policer already exists");
+		return -ENOSPC;
+	}
+
+	rsrc->resrc_used_mask |= BIT(LAN937X_BROADCAST_POLICER);
+
+	return 0;
+}
+
+static int lan937x_setup_action_redirect(struct ksz_device *dev,
+					 struct netlink_ext_ack *extack,
+					 int port,
+					 struct lan937x_flower_rule *rule,
+					 unsigned long destport_mask)
+{
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+	struct lan937x_flower *flower = rule->flower;
+	int ret = 0;
+
+	flower->action.actions_presence_mask |= BIT(LAN937X_ACT_REDIRECT_FLOW);
+
+	if (!rsrc->type.tcam.n_entries) {
+		ret = lan937x_get_acl_req(flower->filter.type,
+					  &rsrc->type.tcam.parser,
+					  &rsrc->type.tcam.n_entries);
+		if (ret)
+			return ret;
+
+		ret = lan937x_assign_tcam_entries(dev, port,
+						  rsrc->type.tcam.n_entries,
+						  &rsrc->type.tcam.index);
+		if (ret) {
+			NL_SET_ERR_MSG_MOD(extack, "TCAM entry unavailable");
+			return ret;
+		}
+
+		lan937x_assign_tcam_counters(dev, port, &rsrc->type.tcam.cntr);
+	}
+	flower->action.redirect_port_mask |= destport_mask;
+	rsrc->resrc_used_mask |= BIT(LAN937X_TCAM_ENTRIES);
+
+	return ret;
+}
+
+static int lan937x_setup_action_drop(struct ksz_device *dev,
+				     struct netlink_ext_ack *extack, int port,
+				     struct lan937x_flower_rule *rule)
+{
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+	struct lan937x_flower *flower = rule->flower;
+	u8 *n_entries = &rsrc->type.tcam.n_entries;
+	u8 *parser = &rsrc->type.tcam.parser;
+	u8 *index = &rsrc->type.tcam.index;
+	int ret = 0;
+
+	flower->action.actions_presence_mask |= BIT(LAN937X_ACT_DROP);
+
+	if (flower->action.n_actions == 1) {
+		ret = lan937x_get_acl_req(flower->filter.type,
+					  parser, n_entries);
+		if (ret)
+			return ret;
+
+		ret = lan937x_assign_tcam_entries(dev, port, *n_entries, index);
+		if (ret) {
+			NL_SET_ERR_MSG_MOD(extack, "TCAM entry unavailable");
+			return ret;
+		}
+
+		lan937x_assign_tcam_counters(dev, port, &rsrc->type.tcam.cntr);
+	}
+	rsrc->resrc_used_mask |= BIT(LAN937X_TCAM_ENTRIES);
+	return ret;
+}
+
+static int lan937x_setup_action_priority(struct ksz_device *dev,
+					 struct netlink_ext_ack *extack,
+					 int port, u32 priority,
+					 struct lan937x_flower_rule *rule)
+{
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+	struct lan937x_flower *flower = rule->flower;
+	u8 *n_entries = &rsrc->type.tcam.n_entries;
+	u8 *parser = &rsrc->type.tcam.parser;
+	u8 *index = &rsrc->type.tcam.index;
+	int ret = 0;
+
+	flower->action.actions_presence_mask |= BIT(LAN937X_ACT_PRIORITY);
+	ret = lan937x_get_acl_req(flower->filter.type,
+				  parser, n_entries);
+	if (ret)
+		return ret;
+
+	ret = lan937x_assign_tcam_entries(dev, port, *n_entries, index);
+	if (ret) {
+		NL_SET_ERR_MSG_MOD(extack, "TCAM entry unavailable");
+		return ret;
+	}
+
+	lan937x_assign_tcam_counters(dev, port, &rsrc->type.tcam.cntr);
+	flower->action.skbedit_prio = priority;
+	rsrc->resrc_used_mask |= BIT(LAN937X_TCAM_ENTRIES);
+
+	return ret;
+}
+
+static int lan937x_setup_tc_policer(struct ksz_device *dev,
+				    struct netlink_ext_ack *extack, int port,
+				    struct lan937x_flower_rule *rule,
+				    u64 rate_bytes_per_sec, u32 burst)
+{
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+	struct lan937x_flower *flower = rule->flower;
+	struct lan937x_flower_action *action;
+	struct lan937x_key *key;
+	int ret;
+
+	action = &flower->action;
+	action->actions_presence_mask |= BIT(LAN937X_ACT_TC_POLICE);
+
+	key = &flower->filter.key;
+	ret = lan937x_check_tc_pol_availability(dev, port,
+						key->vlan_prio.value);
+	if (ret) {
+		NL_SET_ERR_MSG_MOD(extack, "TC Policer already exists");
+		return ret;
+	}
+
+	action->police.rate_bytes_per_sec = div_u64(rate_bytes_per_sec *
+						    512, 1000000);
+	action->police.burst = burst;
+	/* Burst Setting is not supported by Queue Policer Hardware*/
+	NL_SET_ERR_MSG_MOD(extack,
+			   "Burst setting not supported by Queue Policer hw");
+	rsrc->type.tc_pol_used = key->vlan_prio.value;
+	rsrc->resrc_used_mask |= BIT(LAN937X_TC_POLICER);
+
+	return ret;
+}
+
+static int lan937x_setup_stream_policer(struct ksz_device *dev,
+					struct netlink_ext_ack *extack,
+					int port,
+					struct lan937x_flower_rule *rule,
+					u64 rate_bytes_per_sec, u32 burst,
+					u32 mtu)
+{
+	struct lan937x_resrc_alloc *rsrc = rule->resrc;
+	struct lan937x_flower *flower = rule->flower;
+	struct lan937x_flower_action *action;
+	int ret = 0;
+
+	action = &flower->action;
+	action->actions_presence_mask |= BIT(LAN937X_ACT_STREAM_POLICE);
+
+	if (!rsrc->type.strm_flt.en) {
+		ret = lan937x_assign_stream_filter(dev, port,
+						   &rsrc->type.strm_flt.index);
+		if (ret) {
+			NL_SET_ERR_MSG_MOD(extack,
+					   "Stream filter not available");
+			return ret;
+		}
+
+		ret = lan937x_get_acl_req(flower->filter.type,
+					  &rsrc->type.tcam.parser,
+					  &rsrc->type.tcam.n_entries);
+		if (ret)
+			return ret;
+
+		ret = lan937x_assign_tcam_entries(dev, port,
+						  rsrc->type.tcam.n_entries,
+						  &rsrc->type.tcam.index);
+		if (ret) {
+			NL_SET_ERR_MSG_MOD(extack, "TCAM entry not available");
+			return ret;
+		}
+
+		/* Stream policer uses PSFP counters for stats, so tcam
+		 * counter assignment is needed
+		 */
+		rsrc->type.tcam.cntr = STATS_COUNTER_NOT_ASSIGNED;
+		rsrc->type.strm_flt.en = true;
+	}
+
+	action->police.rate_bytes_per_sec = rate_bytes_per_sec;
+	action->police.burst = burst;
+	action->police.mtu = mtu;
+	rsrc->resrc_used_mask |= (BIT(LAN937X_STREAM_FILTER) |
+				  BIT(LAN937X_TCAM_ENTRIES));
+	return ret;
+}
+
+static int lan937x_flower_policer(struct ksz_device *dev,
+				  struct netlink_ext_ack *extack, int port,
+				  struct lan937x_flower_rule *rule,
+				  u64 rate_bytes_per_sec, u32 burst, u32 mtu)
+{
+	struct lan937x_flower *flower = rule->flower;
+	struct lan937x_key *key;
+	int ret;
+
+	switch (flower->filter.type) {
+	case LAN937x_BCAST_FILTER:
+		ret = lan937x_setup_bcast_policer(dev, extack, port, rule);
+		if (ret)
+			return ret;
+
+		/* Utilize the Stream Filter to Implement BCAST Policer*/
+		return lan937x_setup_stream_policer(dev, extack, port, rule,
+						    rate_bytes_per_sec, burst,
+						    mtu);
+	case LAN937x_VLAN_AWARE_FILTER:
+		key = &flower->filter.key;
+
+		/* if number of action is one and only if vlan pcp
+		 * is the only classifier then use HW INGRESS_RATE_LIMIT
+		 * register. This method is used for not to consure more
+		 * stream filter resources
+		 */
+		if (flower->action.n_actions == 1 &&
+		    key->acl_dissector_map == VLAN_PCP_DISSECTOR_PRESENT) {
+			return lan937x_setup_tc_policer(dev, extack, port, rule,
+							rate_bytes_per_sec,
+							burst);
+		}
+		/* if number of classifier is more than one then use
+		 * TCAM and stream policer
+		 */
+		fallthrough;
+	case LAN937x_VLAN_UNAWARE_FILTER:
+		return lan937x_setup_stream_policer(dev, extack, port, rule,
+						    rate_bytes_per_sec, burst,
+						    mtu);
+	default:
+		NL_SET_ERR_MSG_MOD(extack, "Unknown keys for policing");
+		return -EOPNOTSUPP;
+	}
+}
+
+static int lan937x_flower_rule_init(struct ksz_device *dev,
+				    struct lan937x_flower_rule **flower_rule)
+{
+	struct lan937x_flower_rule *t;
+
+	t = devm_kzalloc(dev->dev, sizeof(*t), GFP_KERNEL);
+	if (!t)
+		return -ENOMEM;
+
+	t->flower = devm_kzalloc(dev->dev, sizeof(*t->flower), GFP_KERNEL);
+	if (!t->flower) {
+		devm_kfree(dev->dev, t);
+		return -ENOMEM;
+	}
+
+	t->resrc = devm_kzalloc(dev->dev, sizeof(*t->resrc), GFP_KERNEL);
+	if (!t->resrc) {
+		devm_kfree(dev->dev, t->flower);
+		devm_kfree(dev->dev, t);
+		return -ENOMEM;
+	}
+
+	*flower_rule = t;
+	return 0;
+}
+
+static int lan937x_flower_parse_actions(struct ksz_device *dev,
+					struct netlink_ext_ack *extack,
+					int port, struct flow_rule *rule,
+					struct lan937x_flower_rule *flower_rule)
+{
+	const struct flow_action_entry *act;
+	struct lan937x_flower *flower;
+	int ret = 0;
+	int i;
+
+	flower = flower_rule->flower;
+	flower->action.n_actions = rule->action.num_entries;
+
+	/* For every action, identify the capability & hw resrc availability*/
+	flow_action_for_each(i, act, &rule->action) {
+		switch (act->id) {
+		case FLOW_ACTION_POLICE: {
+			if (act->police.rate_pkt_ps) {
+				NL_SET_ERR_MSG_MOD(extack,
+						   "QoS offload not support packets per second");
+				ret = -EOPNOTSUPP;
+				goto out;
+			}
+			ret = lan937x_flower_policer(dev, extack, port,
+						     flower_rule,
+						     act->police.rate_bytes_ps,
+						     act->police.burst,
+						     act->police.mtu);
+			if (ret)
+				goto out;
+			break;
+		}
+		case FLOW_ACTION_TRAP: {
+			unsigned int cpu = dsa_upstream_port(dev->ds, port);
+
+			ret = lan937x_setup_action_redirect(dev, extack,
+							    port,
+							    flower_rule,
+							    BIT(cpu));
+			break;
+		}
+		case FLOW_ACTION_REDIRECT: {
+			struct dsa_port *to_dp;
+
+			to_dp = dsa_port_from_netdev(act->dev);
+
+			ret = lan937x_setup_action_redirect(dev, extack, port,
+							    flower_rule,
+							    BIT(to_dp->index));
+			break;
+		}
+		case FLOW_ACTION_DROP:
+			ret = lan937x_setup_action_drop(dev, extack, port,
+							flower_rule);
+			break;
+		case FLOW_ACTION_PRIORITY:
+			if (act->priority >= dev->ds->num_tx_queues) {
+				NL_SET_ERR_MSG_MOD(extack,
+						   "Only priorities 0..7 are supported");
+				return -EINVAL;
+			}
+
+			ret = lan937x_setup_action_priority(dev, extack, port,
+							    act->priority,
+							    flower_rule);
+			break;
+		default:
+			NL_SET_ERR_MSG_MOD(extack, "Action not supported");
+			ret = -EOPNOTSUPP;
+			goto out;
+		}
+	}
+out:
+	return ret;
+}
+
+static int lan937x_init_tc_policer_hw(struct ksz_device *dev, int port)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	int ret, i;
+
+	ret = lan937x_port_cfg(dev, port, REG_PORT_MAC_IN_RATE_LIMIT,
+			       PORT_RATE_LIMIT, false);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < LAN937X_NUM_TC; i++) {
+		ret = lan937x_pwrite8(dev, port,
+				      REG_PORT_PRI0_IN_RLIMIT_CTL + i,
+				      0x00);
+		if (ret)
+			return ret;
+		/* Note that the update will not take effect until the
+		 * Port Queue 7 Ingress Limit ctrl Register is written.
+		 */
+		ret = lan937x_pwrite8(dev, port, REG_PORT_PRI7_IN_RLIMIT_CTL,
+				      0x00);
+		if (ret)
+			return ret;
+		res->tc_policers_used[i] = false;
+	}
+
+	return 0;
+}
+
+static int lan937x_cfg_tc_policer_hw(struct ksz_device *dev, int port,
+				     struct lan937x_resrc_alloc *resrc,
+				     u64 rate_bytes_per_sec)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u8 code = 0;
+	int ret, i;
+
+	ret = lan937x_tc_pol_rate_to_reg(rate_bytes_per_sec, &code);
+	if (ret)
+		return ret;
+
+	/* Clear Port Rate Limit to Priority based Rate Limit */
+	ret = lan937x_port_cfg(dev, port, REG_PORT_MAC_IN_RATE_LIMIT,
+			       PORT_RATE_LIMIT, false);
+	if (ret)
+		return ret;
+
+	i = resrc->type.tc_pol_used;
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI0_IN_RLIMIT_CTL + i, code);
+	if (ret)
+		return ret;
+	/* Note that the update will not take effect until the Port Queue 7
+	 * Ingress Limit ctrl Register is written. When port-based rate limiting
+	 * is used a value of 0h should be written to Port Queue 7 Egress Limit
+	 * Control Register.
+	 */
+	ret = lan937x_pread8(dev, port, REG_PORT_PRI7_IN_RLIMIT_CTL, &code);
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI7_IN_RLIMIT_CTL, code);
+	if (ret)
+		return ret;
+
+	res->tc_policers_used[i] = true;
+
+	return 0;
+}
+
+static int lan937x_init_strm_filter_hw(struct ksz_device *dev, int port)
+{
+	int ret, i;
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_PSFP, 0x00);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < LAN937X_NUM_STREAM_FILTERS; i++) {
+		ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_PTR, i);
+		if (ret)
+			return ret;
+
+		/* Clear the Meter Enable and Gate enable */
+		ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_FS_CTL, 0x00);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+/* The PSFP rate limiting register contains 16 bit field each for CIR and PIR
+ * The individual bits in CIR/PIR is assigned weightage in bits/sec unit.
+ * To arrive at desired frequency, set one or more registers bits, which
+ * cumulatively match the desired frequency approximately.
+ * The below logic identifies the reg value by accumulating the weights until
+ * the desired frequency is exceeded, and then looks back and removes the
+ * weights to bring it further near the desired value. This function returns a
+ * value that is greater than or equal to the desired value
+ */
+static u16 lan937x_psfp_rate_to_reg(u64 rate_bytes_per_sec)
+{
+	u64 rate_bps = (8 * rate_bytes_per_sec);
+	u64 t_rate = 0;
+	u16 regcode;
+	u8 i = 0;
+	int j;
+	u32 t;
+	const u32 regbit_weightage_bps[] = {
+		1525,		/* BIT 0*/
+		3051,		/* BIT 1*/
+		6103,		/* BIT 2*/
+		12207,		/* BIT 3*/
+		24414,		/* BIT 4*/
+		48828,		/* BIT 5*/
+		97656,		/* BIT 6*/
+		195312,		/* BIT 7*/
+		390625,		/* BIT 8*/
+		781250,		/* BIT 9*/
+		1562500,	/* BIT 10*/
+		3125000,	/* BIT 11*/
+		6250000,	/* BIT 12*/
+		12500000,	/* BIT 13*/
+		25000000,	/* BIT 14*/
+		50000000	/* BIT 15*/
+	};
+
+	/* Reg Field Size is 16 bits*/
+	while (i < 16) {
+		if (t_rate < rate_bps) {
+			/* Accumulate until desired frequency is exceeded*/
+			t_rate = t_rate + regbit_weightage_bps[i];
+			regcode |= BIT(i);
+		} else {
+			break;
+		}
+
+		i++;
+	}
+
+	if (t_rate != rate_bps) {
+		/* j tracks the last bit index accumulated */
+		j = i - 1;
+		while (j >= 0) {
+			t = t_rate - regbit_weightage_bps[j];
+			if (t >= rate_bps) {
+				/* Remove bits that are giving excessive value*/
+				t_rate = t;
+				regcode &= ~BIT(j);
+			}
+			j--;
+		}
+	}
+
+	return regcode;
+}
+
+static int lan937x_cfg_strm_policer_hw(struct ksz_device *dev, int port,
+				       struct lan937x_resrc_alloc *resrc,
+				       struct lan937x_flower_action *action)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u32 burst;
+	u8 index;
+	u16 cir;
+	u32 val;
+	int ret;
+
+	if (!resrc->type.strm_flt.en)
+		return -EINVAL;
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_PSFP, PSFP_ENABLE);
+	if (ret)
+		return ret;
+
+	index = resrc->type.strm_flt.index;
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_PTR, index);
+	if (ret)
+		return ret;
+
+	ret = lan937x_pwrite8(dev, port, REG_PORT_METER_RED_INT_MSK,
+			      PORT_METER_RED_INT_MSK_ALL);
+	if (ret)
+		return ret;
+
+	cir = lan937x_psfp_rate_to_reg(action->police.rate_bytes_per_sec);
+
+	/* fill PIR with same vaue*/
+	val = METER_SR_UPDT_RATE(cir, cir);
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_METER_SR, val);
+	if (ret)
+		return ret;
+
+	burst = action->police.burst;
+
+	/* fill Peak burst same */
+	val = METER_SR_UPDT_BURST(burst, burst);
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_METER_BS, val);
+	if (ret)
+		return ret;
+
+	/* Enable flow meter of Id (same as stream ID)*/
+	val = (FS_CTL_METER_EN |
+	       FS_UPDT_METER_IDX(index) |
+	       FS_UPDT_MTU(action->police.mtu) |
+	       FS_CTL_MAX_SDU_EN);
+	ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_FS_CTL, val);
+	if (ret)
+		return ret;
+
+	res->stream_filters_used[index] = true;
+
+	return ret;
+}
+
+static int lan937x_flower_configure_hw(struct ksz_device *dev, int port,
+				       struct lan937x_flower_rule *rule)
+{
+	struct lan937x_flower_action *action = &rule->flower->action;
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u32 actions_presence_mask = action->actions_presence_mask;
+	struct lan937x_resrc_alloc *resrc = rule->resrc;
+	u64 rate = action->police.rate_bytes_per_sec;
+	int ret;
+	u8 i;
+
+	if (resrc->resrc_used_mask & BIT(LAN937X_TCAM_ENTRIES)) {
+		ret = lan937x_acl_program_entry(dev, port, rule);
+		if (ret)
+			return ret;
+
+		if (resrc->type.tcam.cntr != STATS_COUNTER_NOT_ASSIGNED)
+			res->tcam_frm_counters[resrc->type.tcam.cntr] = true;
+	}
+
+	for (i = 0; ((actions_presence_mask != 0) &&
+		     (i < LAN937X_NUM_ACTIONS_SUPPORTED));
+	     i++) {
+		if (!(actions_presence_mask & BIT(i)))
+			continue;
+
+		actions_presence_mask &= ~BIT(i);
+
+		switch (i) {
+		case LAN937X_ACT_TC_POLICE:
+			ret = lan937x_cfg_tc_policer_hw(dev, port, resrc, rate);
+			break;
+
+		case LAN937X_ACT_STREAM_POLICE:
+			ret = lan937x_cfg_strm_policer_hw(dev, port, resrc,
+							  action);
+			break;
+
+		default:
+			break;
+		}
+
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* Adjust the tcam start index of all the flower rules
+ * occupying tcam rows below the deleted entry.
+ */
+static void lan937x_flower_recfg_tcam_idx(struct ksz_device *dev, int port,
+					  struct lan937x_flower_rule *rule,
+					  u8 shift_count)
+{
+	struct lan937x_flr_blk *blk = lan937x_get_flr_blk(dev, port);
+	struct lan937x_resrc_alloc *resrc;
+	struct lan937x_flower_rule *nxt_rule;
+	u8 i, row;
+
+	nxt_rule = rule;
+	while (!list_is_first(&nxt_rule->list, &blk->rules)) {
+		/* get the next rule */
+		nxt_rule = list_prev_entry(nxt_rule, list);
+		resrc = nxt_rule->resrc;
+
+		/* Identify if subsequent rules use TCAM entries
+		 * If used, shift the entries by shift_count
+		 */
+		if (resrc->type.tcam.n_entries)
+			resrc->type.tcam.index = (resrc->type.tcam.index -
+						  shift_count);
+	}
+
+	/* Clear the status of freed up rows to "Available for new rule" */
+	if (-ENOSPC == lan937x_assign_tcam_entries(dev, port, 0x01, &row))
+		row = LAN937X_NUM_TCAM_ENTRIES;
+
+	for (i = 0; i < shift_count; i++) {
+		--row;
+		blk->res.tcam_entries_used[row] = false;
+	}
+}
+
+static int lan937x_flower_free_resrcs(struct ksz_device *dev, int port,
+				      struct lan937x_flower_rule *rule)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	struct lan937x_resrc_alloc *resrc = rule->resrc;
+	int ret;
+	int i;
+
+	if (resrc->resrc_used_mask & BIT(LAN937X_TC_POLICER)) {
+		i = resrc->type.tc_pol_used;
+		ret = lan937x_pwrite8(dev, port,
+				      REG_PORT_PRI0_IN_RLIMIT_CTL + i,
+				      0x00);
+		if (ret)
+			return ret;
+
+		res->tc_policers_used[i] = false;
+	}
+
+	if (resrc->resrc_used_mask & BIT(LAN937X_TCAM_ENTRIES)) {
+		u8 n_entries = resrc->type.tcam.n_entries;
+
+		if (resrc->type.tcam.cntr != STATS_COUNTER_NOT_ASSIGNED)
+			res->tcam_frm_counters[resrc->type.tcam.cntr] = false;
+
+		if (resrc->type.tcam.n_entries) {
+			ret = lan937x_acl_free_entry(dev, port, rule);
+			if (ret)
+				return ret;
+
+			/* After deletion, shift the entries to avoid holes
+			 * in the entries
+			 */
+			lan937x_flower_recfg_tcam_idx(dev, port, rule,
+						      n_entries);
+		}
+	}
+
+	if (resrc->resrc_used_mask & BIT(LAN937X_STREAM_FILTER)) {
+		if (!(resrc->type.strm_flt.en))
+			return -EINVAL;
+
+		i = resrc->type.strm_flt.index;
+
+		/* Write the index first */
+		ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_PTR, i);
+		if (ret)
+			return ret;
+
+		/* Clear the Meter,Gate enable, Max SDU, Oversize block etc */
+		ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_FS_CTL, 0x00);
+		if (ret)
+			return ret;
+
+		res->stream_filters_used[i] = false;
+	}
+
+	if (resrc->resrc_used_mask & BIT(LAN937X_BROADCAST_POLICER)) {
+		if (resrc->type.broadcast_pol_en)
+			res->broadcast_pol_used = false;
+	}
+
+	return 0;
+}
+
+int lan937x_cls_flower_add(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_flr_blk *blk = lan937x_get_flr_blk(dev, port);
+	struct flow_rule *rule = flow_cls_offload_flow_rule(cls);
+	struct netlink_ext_ack *extack = cls->common.extack;
+	struct lan937x_flower_rule *flower_rule;
+	int ret;
+
+	if (lan937x_flower_rule_init(dev, &flower_rule))
+		return -ENOMEM;
+
+	flower_rule->cookie = cls->cookie;
+
+	/* Parse the Keys and identify the hw resources required*/
+	ret = lan937x_flower_parse_key(extack, cls,
+				       &flower_rule->flower->filter);
+	if (ret)
+		goto err;
+
+	ret = lan937x_flower_parse_actions(dev, extack, port,
+					   rule, flower_rule);
+	if (ret)
+		goto err;
+
+	/* Configure the hardware Resources */
+	ret = lan937x_flower_configure_hw(dev, port, flower_rule);
+	if (ret)
+		goto err;
+
+	devm_kfree(dev->dev, flower_rule->flower);
+	flower_rule->flower = NULL;
+
+	list_add(&flower_rule->list, &blk->rules);
+
+	cls->stats.pkts = 0x00;
+	cls->stats.drops = 0x00;
+
+	return 0;
+err:
+	devm_kfree(dev->dev, flower_rule->flower);
+	devm_kfree(dev->dev, flower_rule->resrc);
+	devm_kfree(dev->dev, flower_rule);
+	return ret;
+}
+
+int lan937x_cls_flower_del(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_flower_rule *rule;
+	int ret;
+
+	rule = lan937x_rule_find(dev, port, cls->cookie);
+	/* No Rules to delete*/
+	if (!rule)
+		return 0;
+
+	ret = lan937x_flower_free_resrcs(dev, port, rule);
+	if (ret)
+		return ret;
+
+	/* Delete the rule */
+	list_del(&rule->list);
+	if (rule->flower)
+		devm_kfree(dev->dev, rule->flower);
+
+	devm_kfree(dev->dev, rule->resrc);
+	devm_kfree(dev->dev, rule);
+
+	return ret;
+}
+
+static int lan937x_enable_interrupts(struct ksz_device *dev, int port)
+{
+	u8 data;
+	int ret;
+
+	/* ACL FR Counters Interrupt Enable*/
+	ret = lan937x_pwrite8(dev, port,
+			      REG_ACL_PORT_INT_MASK, ACL_FR_CNTR_INTR_EN);
+	if (ret)
+		return ret;
+
+	/* Stream Filter Counters Interrupt Enable*/
+	ret = lan937x_pwrite8(dev, port,
+			      REG_PORT_RX_CNT_OVR_INT_MSK,
+			      EN_ALL_STREAM_CNTR_INTR);
+	if (ret)
+		return ret;
+
+	/* Enable ACL and QCI Top interrupts */
+	ret = lan937x_pread8(dev, port, REG_PORT_INT_MASK, &data);
+	if (ret)
+		return ret;
+
+	data &= ~(PORT_ACL_INT | PORT_QCI_INT);
+	ret = lan937x_pwrite8(dev, port, REG_PORT_INT_MASK, data);
+
+	return ret;
+}
+
+int lan937x_flower_setup(struct dsa_switch *ds)
+{
+	struct ksz_device *dev = ds->priv;
+	int port, ret;
+
+	for (port = 0; port < dev->info->port_cnt; port++) {
+		struct lan937x_flr_blk *blk = lan937x_get_flr_blk(dev, port);
+		struct lan937x_p_res *res = &blk->res;
+
+		ret = lan937x_init_acl_parsers(dev, port);
+		if (ret)
+			return ret;
+
+		ret = lan937x_init_strm_filter_hw(dev, port);
+		if (ret)
+			return ret;
+
+		ret = lan937x_init_tc_policer_hw(dev, port);
+		if (ret)
+			return ret;
+
+		ret = lan937x_enable_interrupts(dev, port);
+		if (ret)
+			return ret;
+
+		INIT_LIST_HEAD(&blk->rules);
+
+		memset(res->gate_used, false, LAN937X_NUM_GATES);
+		memset(res->stream_filters_used, false,
+		       LAN937X_NUM_STREAM_FILTERS);
+		memset(res->tcam_entries_used, false, LAN937X_NUM_TCAM_ENTRIES);
+		memset(res->tc_policers_used, false, LAN937X_NUM_TC);
+
+		res->broadcast_pol_used = false;
+	}
+
+	return 0;
+}
+
+int lan937x_cls_flower_stats(struct dsa_switch *ds, int port,
+			     struct flow_cls_offload *cls, bool ingress)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_resrc_alloc *resrc;
+	struct lan937x_flower_rule *rule;
+	struct flow_stats stats = {0};
+	struct lan937x_p_res *res;
+	u32 drops, pkts;
+	int ret;
+	u8 i;
+
+	res = lan937x_get_flr_res(dev, port);
+	rule = lan937x_rule_find(dev, port, cls->cookie);
+	if (!rule)
+		return -EINVAL;
+
+	resrc = rule->resrc;
+	if (resrc->resrc_used_mask & BIT(LAN937X_TCAM_ENTRIES)) {
+		if (resrc->type.tcam.cntr != STATS_COUNTER_NOT_ASSIGNED) {
+			i = resrc->type.tcam.cntr;
+
+			ret = lan937x_pread32(dev, port,
+					      REG_ACL_PORT_FR_COUNT0 + (i * 4),
+					      &pkts);
+			if (ret)
+				return ret;
+
+			cls->stats.pkts = 0;
+			stats.pkts = (res->tcam_match_cntr_bkup[i] +
+				      pkts - rule->stats.pkts);
+			rule->stats.pkts = res->tcam_match_cntr_bkup[i] + pkts;
+		} else if (resrc->resrc_used_mask &
+			   BIT(LAN937X_STREAM_FILTER)) {
+			i = resrc->type.strm_flt.index;
+
+			ret = lan937x_pwrite32(dev, port, REG_PORT_RX_QCI_PTR,
+					       i);
+			if (ret)
+				return ret;
+
+			ret = lan937x_pread32(dev, port,
+					      REG_PORT_RX_QCI_FS_FM,
+					      &pkts);
+			if (ret)
+				return ret;
+
+			ret = lan937x_pread32(dev, port,
+					      REG_PORT_RX_QCI_FS_FD,
+					      &drops);
+			if (ret)
+				return ret;
+
+			/* Hardware Counters are 20bit counters
+			 * Counter overflow cases are handled.
+			 */
+			cls->stats.pkts = 0;
+			cls->stats.drops = 0;
+
+			stats.pkts = (res->psfp_match_cntr_bkup[i] +
+				      pkts - rule->stats.pkts);
+			stats.drops = (res->psfp_drop_cntr_bkup[i] +
+				       drops - rule->stats.drops);
+
+			rule->stats.pkts = res->psfp_match_cntr_bkup[i] + pkts;
+			rule->stats.drops = res->psfp_drop_cntr_bkup[i] + drops;
+		}
+	} else {
+		return 0;
+	}
+
+	flow_stats_update(&cls->stats, 0x0, stats.pkts, stats.drops,
+			  stats.lastused, FLOW_ACTION_HW_STATS_IMMEDIATE);
+
+	return 0;
+}
+
+irqreturn_t lan937x_qci_cntr_isr(struct ksz_device *dev, int port)
+{
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u8 sf_cntr_sts;
+	u8 sf_int_sts;
+	int ret;
+	u8 i;
+
+	/* Identify from which instance of Stream filter the Intr is raised */
+	ret = lan937x_pread8(dev, port, REG_PORT_RX_CNT_OVR_INT_STS,
+			     &sf_int_sts);
+	if (ret)
+		return IRQ_NONE;
+
+	for (i = 0; i < LAN937X_NUM_STREAM_FILTERS; i++) {
+		if (sf_int_sts & BIT(i)) {
+			ret = lan937x_pwrite32(dev, port,
+					       REG_PORT_RX_QCI_PTR, i);
+			if (ret)
+				return IRQ_NONE;
+
+			/* Identify from which counter overflowed */
+			ret = lan937x_pread8(dev, port,
+					     REG_PORT_STREAM_CNT_STS,
+					     &sf_cntr_sts);
+			if (ret)
+				return IRQ_NONE;
+
+			/* Check whether Frame Match counter overflowed */
+			if (sf_cntr_sts & FILT_STR_FR_MATCH_CNT_OVR) {
+				u64 *cntr = &res->psfp_match_cntr_bkup[i];
+
+				*cntr += FR_MATCH_CNTR_MAX;
+				*cntr &= ~((u64)FR_MATCH_CNTR_MAX);
+			}
+			/* Check whether Flow Meter Drop counter overflowed */
+			if (sf_cntr_sts & FILT_STR_FR_FAIL_DROP_CNT_OVR) {
+				u64 *cntr = &res->psfp_drop_cntr_bkup[i];
+
+				*cntr += FR_DROP_CNTR_MAX;
+				*cntr &= ~((u64)FR_DROP_CNTR_MAX);
+			}
+
+			/* Clear the interrupt */
+			ret =  lan937x_pwrite8(dev, port,
+					       REG_PORT_STREAM_CNT_STS,
+					       sf_cntr_sts);
+			if (ret)
+				return IRQ_NONE;
+		}
+	}
+	return IRQ_HANDLED;
+}
diff --git a/drivers/net/dsa/microchip/lan937x_flower.h b/drivers/net/dsa/microchip/lan937x_flower.h
new file mode 100644
index 000000000000..0dc4f4073855
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_flower.h
@@ -0,0 +1,240 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip switch driver common header
+ *
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#ifndef _NET_DSA_DRIVERS_LAN937X_FLOWER_H
+#define _NET_DSA_DRIVERS_LAN937X_FLOWER_H
+
+#include "lan937x_tc.h"
+#include "lan937x_acl.h"
+
+#define LAN937X_NUM_TCAM_ENTRIES	MAX_ACL_ENTRIES
+#define LAN937x_NUM_TCAM_COUNTERS	4
+#define LAN937X_NUM_STREAM_FILTERS	8
+#define LAN937X_NUM_GATES		8
+#define LAN937X_NUM_DISSECTORS_SUPPORTED acl_num_dissectors_supported
+#define STATS_COUNTER_NOT_ASSIGNED	0xFF
+
+struct lan937x_p_res {
+	bool tcam_entries_used[LAN937X_NUM_TCAM_ENTRIES];
+	bool tcam_frm_counters[LAN937x_NUM_TCAM_COUNTERS];
+	bool stream_filters_used[LAN937X_NUM_STREAM_FILTERS];
+	bool gate_used[LAN937X_NUM_GATES];
+	bool tc_policers_used[LAN937X_NUM_TC];
+	bool broadcast_pol_used;
+
+	/* The following memebers are used to maintain the Counter Value when
+	 * there is a overflow condition
+	 */
+	u64 tcam_match_cntr_bkup[LAN937x_NUM_TCAM_COUNTERS];
+	u64 psfp_match_cntr_bkup[LAN937X_NUM_STREAM_FILTERS];
+	u64 psfp_drop_cntr_bkup[LAN937X_NUM_STREAM_FILTERS];
+};
+
+/* struct lan937x_flr_blk :
+ * Flower Rule and Hw Resource Management data structure.
+ *	rules- List for holding already implemented TC Flower Rules. Each Node
+ *		is of type lan937x_flower_rule.
+ *	res - Data Structure for tracking allocated and available hardware
+ *	      resources.
+ * Memory for this data structure is allocated through dev->port->priv member.
+ */
+struct lan937x_flr_blk {
+	struct list_head rules;	/**Element type: lan937x_flower_rule*/
+	struct lan937x_p_res res;
+};
+
+enum lan937x_filter_type {
+	LAN937x_BCAST_FILTER,
+	LAN937x_VLAN_UNAWARE_FILTER,
+	LAN937x_VLAN_AWARE_FILTER,
+};
+
+enum lan937x_actions_id {
+	LAN937X_ACT_TRAFFIC_CLASS_ASSIGN,
+	LAN937X_ACT_REDIRECT_FLOW,
+	LAN937X_ACT_BCAST_POLICE,
+	LAN937X_ACT_TC_POLICE,
+	LAN937X_ACT_STREAM_POLICE,
+	LAN937X_ACT_STREAM_GATE,
+	LAN937X_ACT_DROP,
+	LAN937X_ACT_PRIORITY,
+	LAN937X_NUM_ACTIONS_SUPPORTED,
+};
+
+struct lan937x_val_mask_u64 {
+	u64 value;
+	u64 mask;
+};
+
+struct lan937x_val_mask_u16 {
+	u16 value;
+	u16 mask;
+};
+
+struct lan937x_val_mask_u8 {
+	u8 value;
+	u8 mask;
+};
+
+struct lan937x_ipv4_addr {
+	u8 value[4];
+	u8 mask[4];
+};
+
+struct lan937x_ipv6_addr {
+	u8 value[16];
+	u8 mask[16];
+};
+
+struct	lan937x_ipv4 {
+	struct lan937x_ipv4_addr sip;
+	struct lan937x_ipv4_addr dip;
+	struct lan937x_val_mask_u8 ttl;
+	struct lan937x_val_mask_u8 tos;
+	struct lan937x_val_mask_u8 proto;
+};
+
+struct	lan937x_ipv6 {
+	struct lan937x_ipv6_addr sip;
+	struct lan937x_ipv6_addr dip;
+	struct lan937x_val_mask_u8 hop;
+	struct lan937x_val_mask_u8 tc;
+	struct lan937x_val_mask_u8 next_hdr;
+};
+
+struct lan937x_key {
+	/*Bits follow lan937x_dissector_id order.*/
+	u32 acl_dissector_map;
+
+	struct {
+		struct lan937x_val_mask_u64 dst_mac;
+		struct lan937x_val_mask_u64 src_mac;
+		struct lan937x_val_mask_u16 vlan_id;
+		struct lan937x_val_mask_u16 vlan_prio;
+		struct lan937x_val_mask_u16 ethtype;
+		union{
+			struct lan937x_ipv4 ipv4;
+			struct lan937x_ipv6 ipv6;
+		};
+		struct lan937x_val_mask_u16 src_port;
+		struct lan937x_val_mask_u16 dst_port;
+	};
+};
+
+struct lan937x_flower_filter {
+	enum	lan937x_filter_type type;
+	struct  lan937x_key key;
+};
+
+struct lan937x_flower_action {
+	u8 n_actions;
+	u32 actions_presence_mask; /**bits in lan937x_actions_id order*/
+
+	struct {
+		u64 rate_bytes_per_sec;
+		u32 burst;
+		u32 mtu;
+	} police;
+
+	struct {
+		int ipv;
+		u64 base_time;
+		u64 cycle_time;
+		int n_entries;
+		struct action_gate_entry *entries;
+		struct flow_stats stats;
+	} gate;
+
+	u8 redirect_port_mask;
+	u8 skbedit_prio;
+};
+
+enum lan937x_resource_id {
+	LAN937X_TCAM_ENTRIES,
+	LAN937X_STREAM_FILTER,
+	LAN937X_PSFP_GATE,
+	LAN937X_TC_POLICER,
+	LAN937X_BROADCAST_POLICER,
+
+	LAN937X_NUM_RESOURCES,
+};
+
+struct lan937x_resrc_alloc {
+	/*Bits assigned in lan937x_resource_id order*/
+	u16 resrc_used_mask;
+
+	struct {
+		struct {
+			u8 parser;
+			u8 n_entries;
+			u8 index;
+			u8 cntr;
+		} tcam;
+
+		struct {
+			bool en;
+			u8 index;
+		} strm_flt;
+
+		struct {
+			bool en;
+			u8 index;
+		} gate;
+
+		u8 tc_pol_used;
+		u8 broadcast_pol_en;
+	} type;
+};
+
+struct lan937x_flower {
+	struct lan937x_flower_filter filter;
+	struct lan937x_flower_action action;
+};
+
+struct lan937x_stats {
+	u64 pkts;
+	u64 drops;
+};
+
+struct lan937x_flower_rule {
+	struct list_head list;
+	unsigned long cookie;
+	struct lan937x_flower *flower;
+	struct lan937x_resrc_alloc *resrc;
+	struct lan937x_stats stats;
+};
+
+/** TC Flower APIs */
+int lan937x_flower_setup(struct dsa_switch *ds);
+int lan937x_cls_flower_add(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress);
+int lan937x_init_acl_parsers(struct ksz_device *dev, int port);
+int lan937x_acl_program_entry(struct ksz_device *dev, int port,
+			      struct lan937x_flower_rule *rule);
+int lan937x_get_acl_req(enum lan937x_filter_type type,
+			u8 *parser_idx, u8 *num_entries);
+struct lan937x_flr_blk *lan937x_get_flr_blk(struct ksz_device *dev,
+					    int port);
+struct lan937x_p_res *lan937x_get_flr_res(struct ksz_device *dev,
+					  int port);
+int lan937x_assign_tcam_entries(struct ksz_device *dev,
+				int port, u8 num_entry_reqd,
+				u8 *tcam_idx);
+int lan937x_tc_pol_rate_to_reg(u64 rate_bytes_per_sec, u8 *regval);
+
+/* APIs to support TC Flower rule deletion */
+int lan937x_cls_flower_del(struct dsa_switch *ds, int port,
+			   struct flow_cls_offload *cls, bool ingress);
+int lan937x_acl_free_entry(struct ksz_device *dev, int port,
+			   struct lan937x_flower_rule *rule);
+
+/* APIs to support TC Flower statistics */
+int lan937x_cls_flower_stats(struct dsa_switch *ds, int port,
+			     struct flow_cls_offload *cls, bool ingress);
+irqreturn_t lan937x_acl_isr(struct ksz_device *dev, int port);
+irqreturn_t lan937x_qci_cntr_isr(struct ksz_device *dev, int port);
+
+#endif
+
diff --git a/drivers/net/dsa/microchip/lan937x_main.c b/drivers/net/dsa/microchip/lan937x_main.c
new file mode 100644
index 000000000000..d641b9d41676
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_main.c
@@ -0,0 +1,1588 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip LAN937X switch driver main logic
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/iopoll.h>
+#include <linux/phy.h>
+#include <linux/of_net.h>
+#include <linux/if_bridge.h>
+#include <linux/if_vlan.h>
+#include <linux/math.h>
+#include <net/dsa.h>
+#include <net/switchdev.h>
+#include "lan937x_reg.h"
+#include "lan937x_ptp.h"
+#include "ksz_common.h"
+#include "lan937x_dev.h"
+#include "lan937x_tc.h"
+#include "lan937x_devlink.h"
+#include "lan937x_flower.h"
+
+static int lan937x_wait_vlan_ctrl_ready(struct ksz_device *dev)
+{
+	unsigned int val;
+
+	return regmap_read_poll_timeout(dev->regmap[0], REG_SW_VLAN_CTRL, val,
+					!(val & VLAN_START), 10, 1000);
+}
+
+static u8 lan937x_get_fid(u16 vid)
+{
+	if (vid > ALU_FID_SIZE)
+		return LAN937X_GET_FID(vid);
+	else
+		return vid;
+}
+
+static int lan937x_get_vlan_table(struct ksz_device *dev, u16 vid,
+				  struct lan937x_vlan *vlan_entry)
+{
+	u32 data;
+	int ret;
+
+	mutex_lock(&dev->vlan_mutex);
+
+	ret = ksz_write16(dev, REG_SW_VLAN_ENTRY_INDEX__2, vid & VLAN_INDEX_M);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write8(dev, REG_SW_VLAN_CTRL, VLAN_READ | VLAN_START);
+	if (ret < 0)
+		goto exit;
+
+	/* wait to be cleared */
+	ret = lan937x_wait_vlan_ctrl_ready(dev);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_read32(dev, REG_SW_VLAN_ENTRY__4, &data);
+	if (ret < 0)
+		goto exit;
+
+	vlan_entry->valid = !!(data & VLAN_VALID);
+	vlan_entry->fid	= data & VLAN_FID_M;
+
+	ret = ksz_read32(dev, REG_SW_VLAN_ENTRY_UNTAG__4,
+			 &vlan_entry->untag_prtmap);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_read32(dev, REG_SW_VLAN_ENTRY_PORTS__4,
+			 &vlan_entry->fwd_map);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write8(dev, REG_SW_VLAN_CTRL, 0);
+	if (ret < 0)
+		goto exit;
+
+exit:
+	mutex_unlock(&dev->vlan_mutex);
+
+	return ret;
+}
+
+static int lan937x_set_vlan_table(struct ksz_device *dev, u16 vid,
+				  struct lan937x_vlan *vlan_entry)
+{
+	u32 data;
+	int ret;
+
+	mutex_lock(&dev->vlan_mutex);
+
+	data = vlan_entry->valid ? VLAN_VALID : 0;
+	data |= vlan_entry->fid;
+
+	ret = ksz_write32(dev, REG_SW_VLAN_ENTRY__4, data);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write32(dev, REG_SW_VLAN_ENTRY_UNTAG__4,
+			  vlan_entry->untag_prtmap);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write32(dev, REG_SW_VLAN_ENTRY_PORTS__4, vlan_entry->fwd_map);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write16(dev, REG_SW_VLAN_ENTRY_INDEX__2, vid & VLAN_INDEX_M);
+	if (ret < 0)
+		goto exit;
+
+	ret = ksz_write8(dev, REG_SW_VLAN_CTRL, VLAN_START | VLAN_WRITE);
+	if (ret < 0)
+		goto exit;
+
+	/* wait to be cleared */
+	ret = lan937x_wait_vlan_ctrl_ready(dev);
+	if (ret < 0)
+		goto exit;
+
+exit:
+	mutex_unlock(&dev->vlan_mutex);
+
+	return ret;
+}
+
+static int lan937x_read_table(struct ksz_device *dev, u32 *table)
+{
+	int ret;
+
+	/* read alu table */
+	ret = ksz_read32(dev, REG_SW_ALU_VAL_A, &table[0]);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_read32(dev, REG_SW_ALU_VAL_B, &table[1]);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_read32(dev, REG_SW_ALU_VAL_C, &table[2]);
+	if (ret < 0)
+		return ret;
+
+	return ksz_read32(dev, REG_SW_ALU_VAL_D, &table[3]);
+}
+
+static int lan937x_write_table(struct ksz_device *dev, u32 *table)
+{
+	int ret;
+
+	/* write alu table */
+	ret = ksz_write32(dev, REG_SW_ALU_VAL_A, table[0]);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_ALU_VAL_B, table[1]);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_ALU_VAL_C, table[2]);
+	if (ret < 0)
+		return ret;
+
+	return ksz_write32(dev, REG_SW_ALU_VAL_D, table[3]);
+}
+
+static int lan937x_wait_alu_ready(int alu, struct ksz_device *dev)
+{
+	unsigned int val;
+
+	return regmap_read_poll_timeout(dev->regmap[2], REG_SW_ALU_CTRL(alu),
+					val, !(val & ALU_START), 10, 1000);
+}
+
+static int lan937x_wait_alu_sta_ready(struct ksz_device *dev)
+{
+	unsigned int val;
+
+	return regmap_read_poll_timeout(dev->regmap[2], REG_SW_ALU_STAT_CTRL__4,
+					val, !(val & ALU_STAT_START), 10, 1000);
+}
+
+static enum dsa_tag_protocol lan937x_get_tag_protocol(struct dsa_switch *ds,
+						      int port,
+						      enum dsa_tag_protocol mp)
+{
+	if (ds->dst->last_switch)
+		return DSA_TAG_PROTO_LAN937X_CASCADE_VALUE;
+	else
+		return DSA_TAG_PROTO_LAN937X_VALUE;
+}
+
+static int lan937x_phy_read16(struct dsa_switch *ds, int addr, int reg)
+{
+	struct ksz_device *dev = ds->priv;
+	u16 val;
+	int ret;
+
+	ret = lan937x_internal_phy_read(dev, addr, reg, &val);
+	if (ret < 0)
+		return ret;
+
+	return val;
+}
+
+static int lan937x_phy_write16(struct dsa_switch *ds, int addr, int reg,
+			       u16 val)
+{
+	struct ksz_device *dev = ds->priv;
+
+	return lan937x_internal_phy_write(dev, addr, reg, val);
+}
+
+static void lan937x_port_stp_state_set(struct dsa_switch *ds, int port,
+				       u8 state)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port *p = &dev->ports[port];
+	u8 data;
+
+	lan937x_pread8(dev, port, P_STP_CTRL, &data);
+	data &= ~(PORT_TX_ENABLE | PORT_RX_ENABLE | PORT_LEARN_DISABLE);
+
+	switch (state) {
+	case BR_STATE_DISABLED:
+		data |= PORT_LEARN_DISABLE;
+		break;
+	case BR_STATE_BLOCKING:
+	case BR_STATE_LISTENING:
+		data |= PORT_LEARN_DISABLE;
+		break;
+	case BR_STATE_LEARNING:
+		break;
+	case BR_STATE_FORWARDING:
+		data |= (PORT_TX_ENABLE | PORT_RX_ENABLE);
+		break;
+	default:
+		dev_err(ds->dev, "invalid STP state: %d\n", state);
+		return;
+	}
+
+	lan937x_pwrite8(dev, port, P_STP_CTRL, data);
+
+	p->stp_state = state;
+
+	ksz_update_port_member(dev, port);
+}
+
+static int lan937x_port_vlan_filtering(struct dsa_switch *ds, int port,
+				       bool flag,
+				       struct netlink_ext_ack *extack)
+{
+	struct ksz_device *dev = ds->priv;
+
+	/* enable/disable VLAN mode, once enabled, look up process starts
+	 * and then forwarding and discarding are done based on port
+	 * membership of the VLAN table
+	 */
+	return lan937x_cfg(dev, REG_SW_LUE_CTRL_0, SW_VLAN_ENABLE, flag);
+}
+
+static int lan937x_port_vlan_add(struct dsa_switch *ds, int port,
+				 const struct switchdev_obj_port_vlan *vlan,
+				 struct netlink_ext_ack *extack)
+{
+	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_vlan vlan_entry;
+	int ret;
+
+	ret = lan937x_get_vlan_table(dev, vlan->vid, &vlan_entry);
+	if (ret < 0) {
+		NL_SET_ERR_MSG_MOD(extack, "Failed to get vlan table");
+		return ret;
+	}
+
+	vlan_entry.fid = lan937x_get_fid(vlan->vid);
+	vlan_entry.valid = true;
+
+	/* set/clear switch port when updating vlan table registers */
+	if (untagged)
+		vlan_entry.untag_prtmap |= BIT(port);
+	else
+		vlan_entry.untag_prtmap &= ~BIT(port);
+
+	vlan_entry.fwd_map |= BIT(port);
+
+	ret = lan937x_set_vlan_table(dev, vlan->vid, &vlan_entry);
+	if (ret < 0) {
+		NL_SET_ERR_MSG_MOD(extack, "Failed to set vlan table");
+		return ret;
+	}
+
+	/* change PVID */
+	if (vlan->flags & BRIDGE_VLAN_INFO_PVID) {
+		ret = lan937x_pwrite16(dev, port, REG_PORT_DEFAULT_VID,
+				       vlan->vid);
+		if (ret < 0) {
+			NL_SET_ERR_MSG_MOD(extack, "Failed to set pvid");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int lan937x_port_vlan_del(struct dsa_switch *ds, int port,
+				 const struct switchdev_obj_port_vlan *vlan)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_vlan vlan_entry;
+	int ret;
+
+	ret = lan937x_get_vlan_table(dev, vlan->vid, &vlan_entry);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to get vlan table\n");
+		return ret;
+	}
+
+	/* clear port fwd map & untag entries*/
+	vlan_entry.fwd_map &= ~BIT(port);
+	vlan_entry.untag_prtmap &= ~BIT(port);
+
+	ret = lan937x_set_vlan_table(dev, vlan->vid, &vlan_entry);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to set vlan table\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int lan937x_port_fdb_add(struct dsa_switch *ds, int port,
+				const unsigned char *addr, u16 vid,
+				struct dsa_db db)
+{
+	struct ksz_device *dev = ds->priv;
+	u8 fid = lan937x_get_fid(vid);
+	u32 alu_table[4];
+	int ret, i;
+	u32 data;
+	u8 val;
+
+	mutex_lock(&dev->alu_mutex);
+
+	/* Accessing two ALU tables through loop */
+	for (i = 0; i < ALU_STA_DYN_CNT; i++) {
+		/* find any entry with mac & fid */
+		data = fid << ALU_FID_INDEX_S;
+		data |= ((addr[0] << 8) | addr[1]);
+
+		ret = ksz_write32(dev, REG_SW_ALU_INDEX_0, data);
+		if (ret < 0)
+			break;
+
+		data = ((addr[2] << 24) | (addr[3] << 16));
+		data |= ((addr[4] << 8) | addr[5]);
+
+		ret = ksz_write32(dev, REG_SW_ALU_INDEX_1, data);
+		if (ret < 0)
+			break;
+
+		/* start read operation */
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i),
+				  ALU_READ | ALU_START);
+		if (ret < 0)
+			break;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_ready(i, dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to read ALU\n");
+			break;
+		}
+
+		/* read ALU entry */
+		ret = lan937x_read_table(dev, alu_table);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to read ALU\n");
+			break;
+		}
+
+		/* update ALU entry */
+		alu_table[0] = ALU_V_STATIC_VALID;
+
+		/* update port number */
+		alu_table[1] |= BIT(port);
+
+		if (fid)
+			alu_table[1] |= ALU_V_USE_FID;
+
+		alu_table[2] = (fid << ALU_V_FID_S);
+		alu_table[2] |= ((addr[0] << 8) | addr[1]);
+		alu_table[3] = ((addr[2] << 24) | (addr[3] << 16));
+		alu_table[3] |= ((addr[4] << 8) | addr[5]);
+
+		ret = lan937x_write_table(dev, alu_table);
+		if (ret < 0)
+			break;
+
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i),
+				  (ALU_WRITE | ALU_START));
+		if (ret < 0)
+			break;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_ready(i, dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to write ALU\n");
+			break;
+		}
+
+		ret = ksz_read8(dev, REG_SW_LUE_INT_STATUS__1, &val);
+		if (ret < 0)
+			break;
+
+		/* ALU2 write failed */
+		if (val & WRITE_FAIL_INT && i == 1)
+			dev_err(dev->dev, "Failed to write ALU\n");
+
+		/* if ALU1 write is failed and attempt to write ALU2,
+		 * otherwise exit. Clear Write fail for both ALU1 & ALU2
+		 */
+		if (val & WRITE_FAIL_INT) {
+			/* Write to clear the Write Fail */
+			ret = ksz_write8(dev, REG_SW_LUE_INT_STATUS__1,
+					 WRITE_FAIL_INT);
+			if (ret < 0)
+				break;
+		} else {
+			break;
+		}
+	}
+
+	mutex_unlock(&dev->alu_mutex);
+
+	return ret;
+}
+
+static int lan937x_port_fdb_del(struct dsa_switch *ds, int port,
+				const unsigned char *addr, u16 vid,
+				struct dsa_db db)
+{
+	struct ksz_device *dev = ds->priv;
+	u8 fid = lan937x_get_fid(vid);
+	u32 alu_table[4];
+	int ret, i;
+	u32 data;
+
+	mutex_lock(&dev->alu_mutex);
+
+	/* Accessing two ALU tables through loop */
+	for (i = 0; i < ALU_STA_DYN_CNT; i++) {
+		/* read any entry with mac & fid */
+		data = fid << ALU_FID_INDEX_S;
+		data |= ((addr[0] << 8) | addr[1]);
+		ret = ksz_write32(dev, REG_SW_ALU_INDEX_0, data);
+		if (ret < 0)
+			break;
+
+		data = ((addr[2] << 24) | (addr[3] << 16));
+		data |= ((addr[4] << 8) | addr[5]);
+		ret = ksz_write32(dev, REG_SW_ALU_INDEX_1, data);
+		if (ret < 0)
+			break;
+
+		/* start read operation */
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i),
+				  (ALU_READ | ALU_START));
+		if (ret < 0)
+			break;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_ready(i, dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to read ALU\n");
+			break;
+		}
+
+		ret = ksz_read32(dev, REG_SW_ALU_VAL_A, &alu_table[0]);
+		if (ret < 0)
+			break;
+
+		if (alu_table[0] & ALU_V_STATIC_VALID) {
+			/* read ALU entry */
+			ret = lan937x_read_table(dev, alu_table);
+			if (ret < 0) {
+				dev_err(dev->dev, "Failed to read ALU table\n");
+				break;
+			}
+
+			/* clear forwarding port */
+			alu_table[1] &= ~BIT(port);
+
+			/* if there is no port to forward, clear table */
+			if ((alu_table[1] & ALU_V_PORT_MAP) == 0)
+				memset(&alu_table, 0, sizeof(alu_table));
+		} else {
+			memset(&alu_table, 0, sizeof(alu_table));
+		}
+
+		ret = lan937x_write_table(dev, alu_table);
+		if (ret < 0)
+			break;
+
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i),
+				  (ALU_WRITE | ALU_START));
+		if (ret < 0)
+			break;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_ready(i, dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to delete ALU Entries\n");
+			break;
+		}
+	}
+
+	mutex_unlock(&dev->alu_mutex);
+
+	return ret;
+}
+
+static void lan937x_convert_alu(struct lan_alu_struct *alu, u32 *alu_table)
+{
+	alu->is_static = !!(alu_table[0] & ALU_V_STATIC_VALID);
+	alu->is_src_filter = !!(alu_table[0] & ALU_V_SRC_FILTER);
+	alu->is_dst_filter = !!(alu_table[0] & ALU_V_DST_FILTER);
+	alu->prio_age = (alu_table[0] >> ALU_V_PRIO_AGE_CNT_S) &
+			 ALU_V_PRIO_AGE_CNT_M;
+	alu->mstp = alu_table[0] & ALU_V_MSTP_M;
+
+	alu->is_override = !!(alu_table[1] & ALU_V_OVERRIDE);
+	alu->is_use_fid = !!(alu_table[1] & ALU_V_USE_FID);
+	alu->port_forward = alu_table[1] & ALU_V_PORT_MAP;
+
+	alu->fid = (alu_table[2] >> ALU_V_FID_S) & ALU_V_FID_M;
+
+	alu->mac[0] = (alu_table[2] >> 8) & 0xFF;
+	alu->mac[1] = alu_table[2] & 0xFF;
+	alu->mac[2] = (alu_table[3] >> 24) & 0xFF;
+	alu->mac[3] = (alu_table[3] >> 16) & 0xFF;
+	alu->mac[4] = (alu_table[3] >> 8) & 0xFF;
+	alu->mac[5] = alu_table[3] & 0xFF;
+}
+
+static int lan937x_port_fdb_dump(struct dsa_switch *ds, int port,
+				 dsa_fdb_dump_cb_t *cb, void *data)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan_alu_struct alu;
+	u32 lan937x_data;
+	u32 alu_table[4];
+	int timeout;
+	int ret, i;
+
+	mutex_lock(&dev->alu_mutex);
+
+	/* Accessing two ALU tables through loop */
+	for (i = 0; i < ALU_STA_DYN_CNT; i++) {
+		/* start ALU search */
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i),
+				  (ALU_START | ALU_SEARCH));
+		if (ret < 0)
+			goto exit;
+
+		do {
+			timeout = 1000;
+			do {
+				ret = ksz_read32(dev, REG_SW_ALU_CTRL(i),
+						 &lan937x_data);
+				if (ret < 0)
+					goto exit;
+
+				if ((lan937x_data & ALU_VALID) ||
+				    !(lan937x_data & ALU_START))
+					break;
+				usleep_range(1, 10);
+			} while (timeout-- > 0);
+
+			if (!timeout) {
+				dev_err(dev->dev, "Failed to search ALU\n");
+				ret = -ETIMEDOUT;
+				goto exit;
+			}
+
+			/* read ALU table */
+			ret = lan937x_read_table(dev, alu_table);
+			if (ret < 0)
+				goto exit;
+
+			lan937x_convert_alu(&alu, alu_table);
+
+			if (alu.port_forward & BIT(port)) {
+				ret = cb(alu.mac, alu.fid, alu.is_static, data);
+				if (ret)
+					goto exit;
+			}
+		} while (lan937x_data & ALU_START);
+
+exit:
+		/* stop ALU search & continue to next ALU if available */
+		ret = ksz_write32(dev, REG_SW_ALU_CTRL(i), 0);
+	}
+
+	mutex_unlock(&dev->alu_mutex);
+
+	return ret;
+}
+
+static int lan937x_port_mdb_add(struct dsa_switch *ds, int port,
+				const struct switchdev_obj_port_mdb *mdb,
+				struct dsa_db db)
+{
+	struct ksz_device *dev = ds->priv;
+	u8 fid = lan937x_get_fid(mdb->vid);
+	u32 static_table[4];
+	u32 mac_hi, mac_lo;
+	int index, ret;
+	u32 data;
+
+	mac_hi = ((mdb->addr[0] << 8) | mdb->addr[1]);
+	mac_lo = ((mdb->addr[2] << 24) | (mdb->addr[3] << 16));
+	mac_lo |= ((mdb->addr[4] << 8) | mdb->addr[5]);
+
+	mutex_lock(&dev->alu_mutex);
+
+	/* Access the entries in the table */
+	for (index = 0; index < dev->info->num_statics; index++) {
+		/* find empty slot first */
+		data = (index << ALU_STAT_INDEX_S) |
+			ALU_STAT_READ | ALU_STAT_START;
+
+		ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);
+		if (ret < 0)
+			goto exit;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_sta_ready(dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to read ALU STATIC\n");
+			goto exit;
+		}
+
+		/* read ALU static table */
+		ret = lan937x_read_table(dev, static_table);
+		if (ret < 0)
+			goto exit;
+
+		if (static_table[0] & ALU_V_STATIC_VALID) {
+			/* check this has same fid & mac address */
+			if (((static_table[2] >> ALU_V_FID_S) == fid) &&
+			    ((static_table[2] & ALU_V_MAC_ADDR_HI) == mac_hi) &&
+			    static_table[3] == mac_lo) {
+				/* found matching one */
+				break;
+			}
+		} else {
+			/* found empty one */
+			break;
+		}
+	}
+
+	/* no available entry */
+	if (index == dev->info->num_statics) {
+		ret = -ENOSPC;
+		goto exit;
+	}
+
+	/* add entry */
+	static_table[0] = ALU_V_STATIC_VALID;
+
+	static_table[1] |= BIT(port);
+	if (fid)
+		static_table[1] |= ALU_V_USE_FID;
+	static_table[2] = (fid << ALU_V_FID_S);
+	static_table[2] |= mac_hi;
+	static_table[3] = mac_lo;
+
+	ret = lan937x_write_table(dev, static_table);
+	if (ret < 0)
+		goto exit;
+
+	data = (index << ALU_STAT_INDEX_S) | ALU_STAT_START;
+	ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);
+	if (ret < 0)
+		goto exit;
+
+	/* wait to be finished */
+	ret = lan937x_wait_alu_sta_ready(dev);
+	if (ret < 0)
+		dev_err(dev->dev, "Failed to read ALU STATIC\n");
+
+exit:
+	mutex_unlock(&dev->alu_mutex);
+	return ret;
+}
+
+static int lan937x_port_mdb_del(struct dsa_switch *ds, int port,
+				const struct switchdev_obj_port_mdb *mdb,
+				struct dsa_db db)
+{
+	struct ksz_device *dev = ds->priv;
+	u8 fid = lan937x_get_fid(mdb->vid);
+	u32 static_table[4];
+	u32 mac_hi, mac_lo;
+	int index, ret;
+	u32 data;
+
+	mac_hi = ((mdb->addr[0] << 8) | mdb->addr[1]);
+	mac_lo = ((mdb->addr[2] << 24) | (mdb->addr[3] << 16));
+	mac_lo |= ((mdb->addr[4] << 8) | mdb->addr[5]);
+
+	mutex_lock(&dev->alu_mutex);
+
+	/* Access the entries in the table */
+	for (index = 0; index < dev->info->num_statics; index++) {
+		data = (index << ALU_STAT_INDEX_S) |
+			ALU_STAT_READ | ALU_STAT_START;
+		ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);
+		if (ret < 0)
+			goto exit;
+
+		/* wait to be finished */
+		ret = lan937x_wait_alu_sta_ready(dev);
+		if (ret < 0) {
+			dev_err(dev->dev, "Failed to read ALU STATIC\n");
+			goto exit;
+		}
+
+		/* read ALU static table */
+		ret = lan937x_read_table(dev, static_table);
+		if (ret < 0)
+			goto exit;
+
+		if (static_table[0] & ALU_V_STATIC_VALID) {
+			/* check this has same fid & mac address */
+			if (((static_table[2] >> ALU_V_FID_S) == fid) &&
+			    ((static_table[2] & ALU_V_MAC_ADDR_HI) == mac_hi) &&
+			    static_table[3] == mac_lo) {
+				/* found matching one */
+				break;
+			}
+		}
+	}
+
+	/* no available entry */
+	if (index == dev->info->num_statics)
+		goto exit;
+
+	/* clear port based on port arg */
+	static_table[1] &= ~BIT(port);
+
+	if ((static_table[1] & ALU_V_PORT_MAP) == 0) {
+		/* delete entry */
+		memset(&static_table, 0, sizeof(static_table));
+	}
+
+	ret = lan937x_write_table(dev, static_table);
+	if (ret < 0)
+		goto exit;
+
+	data = (index << ALU_STAT_INDEX_S) | ALU_STAT_START;
+	ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);
+	if (ret < 0)
+		goto exit;
+
+	/* wait to be finished */
+	ret = lan937x_wait_alu_sta_ready(dev);
+	if (ret < 0)
+		dev_err(dev->dev, "Failed to read ALU STATIC\n");
+
+exit:
+	mutex_unlock(&dev->alu_mutex);
+
+	return ret;
+}
+
+static int lan937x_port_mirror_add(struct dsa_switch *ds, int port,
+				   struct dsa_mall_mirror_tc_entry *mirror,
+				   bool ingress, struct netlink_ext_ack *extack)
+{
+	struct ksz_device *dev = ds->priv;
+	int ret, p;
+	u8 data;
+
+	/* Limit to one sniffer port
+	 * Check if any of the port is already set for sniffing
+	 * If yes, instruct the user to remove the previous entry & exit
+	 */
+	for (p = 0; p < dev->info->port_cnt; p++) {
+		/* Skip the current sniffing port */
+		if (p == mirror->to_local_port)
+			continue;
+
+		ret = lan937x_pread8(dev, p, P_MIRROR_CTRL, &data);
+		if (ret < 0)
+			return ret;
+
+		if (data & PORT_MIRROR_SNIFFER) {
+			NL_SET_ERR_MSG_MOD(extack,
+					   "Sniffer port is already configured, delete existing rules & retry");
+			return -EBUSY;
+		}
+	}
+
+	/* Configure ingress/egress mirroring */
+	if (ingress)
+		ret = lan937x_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX,
+				       true);
+	else
+		ret = lan937x_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX,
+				       true);
+	if (ret < 0)
+		return ret;
+
+	/* Configure sniffer port as other ports do not have
+	 * PORT_MIRROR_SNIFFER is set
+	 */
+	ret = lan937x_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,
+			       PORT_MIRROR_SNIFFER, true);
+	if (ret < 0)
+		return ret;
+
+	return lan937x_cfg(dev, S_MIRROR_CTRL, SW_MIRROR_RX_TX, false);
+}
+
+static void lan937x_port_mirror_del(struct dsa_switch *ds, int port,
+				    struct dsa_mall_mirror_tc_entry *mirror)
+{
+	struct ksz_device *dev = ds->priv;
+	bool in_use = false;
+	u8 data;
+	int p;
+
+	/* clear ingress/egress mirroring port */
+	if (mirror->ingress)
+		lan937x_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX,
+				 false);
+	else
+		lan937x_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX,
+				 false);
+
+	/* Check if any of the port is still referring to sniffer port */
+	for (p = 0; p < dev->info->port_cnt; p++) {
+		lan937x_pread8(dev, p, P_MIRROR_CTRL, &data);
+
+		if ((data & (PORT_MIRROR_RX | PORT_MIRROR_TX))) {
+			in_use = true;
+			break;
+		}
+	}
+
+	/* delete sniffing if there are no other mirroring rule exist */
+	if (!in_use)
+		lan937x_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,
+				 PORT_MIRROR_SNIFFER, false);
+}
+
+int lan937x_tc_pol_rate_to_reg(u64 rate_bytes_per_sec, u8 *regval)
+{
+	u32 rate_kbps = div_u64(8 * rate_bytes_per_sec, 1000);
+	u16 code = 0x00;
+
+	if (rate_kbps >= 2000) {
+		code = (rate_kbps / 1000);
+	} else if (rate_kbps == 1000) {
+		code = RLIMIT_REG_CODE_1MBPS;
+	} else if (rate_kbps <= 1280) {
+		code = RLIMIT_REG_CODE_1280KBPS;
+	} else if (rate_kbps <= 1920) {
+		code = RLIMIT_REG_CODE_1920KBPS;
+	} else {
+		/* All values in rate_boundaries are in kbps*/
+		const u16 rate_boundaries[] = {
+			/* [0]*/	256,	320,	384,	448,	512,
+			/* [5]*/	576,	640,	804,	768,	832,
+			/* [10]*/	896,	960,
+		};
+		u8 i;
+
+		for (i = 0; i < 12; i++) {
+			if (rate_kbps < rate_boundaries[i]) {
+				/* 256 kbps is the lowest limited rate.
+				 * Incrementing reg value by one step results in
+				 * setting the rate to next subsequent boundary
+				 */
+				code = RLIMIT_REG_CODE_256KBPS + i;
+				break;
+			}
+		}
+	}
+
+	if (!code)
+		return -EINVAL;
+
+	*regval = code;
+
+	return 0;
+}
+
+static int lan937x_port_policer_add(struct dsa_switch *ds, int port,
+				    struct dsa_mall_policer_tc_entry *policer)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	u8 code = 0;
+	int ret, i;
+
+	/* Port Policing and Traffic class Policing is mutually exclusive
+	 * behavior of one Ingress Rate Limiting Hw
+	 */
+	for (i = 0; i < LAN937X_NUM_TC; i++) {
+		if (res->tc_policers_used[i])
+			return -ENOSPC;
+	}
+
+	ret = lan937x_tc_pol_rate_to_reg(policer->rate_bytes_per_sec, &code);
+	if (ret)
+		return ret;
+
+	ret = lan937x_port_cfg(dev, port, REG_PORT_MAC_IN_RATE_LIMIT,
+			       PORT_RATE_LIMIT, true);
+	if (ret)
+		return ret;
+
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI0_IN_RLIMIT_CTL, code);
+	if (ret)
+		return ret;
+
+	/* Note that the update will not take effect until the Port Queue 7
+	 * Ingress Limit ctrl Register is written. When port-based rate limiting
+	 * is used a value of 0h should be written to Port Queue 7 Egress Limit
+	 * Control Register.
+	 */
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI7_IN_RLIMIT_CTL, 0x00);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < LAN937X_NUM_TC; i++)
+		res->tc_policers_used[i] = true;
+
+	return 0;
+}
+
+static void lan937x_port_policer_del(struct dsa_switch *ds, int port)
+{
+	struct ksz_device *dev = ds->priv;
+	struct lan937x_p_res *res = lan937x_get_flr_res(dev, port);
+	int ret;
+	u8 i;
+
+	/*Update Default Value to Rate Limit : 00*/
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI0_IN_RLIMIT_CTL, 0x00);
+	if (ret)
+		return;
+
+	/* Note that the update will not take effect until the Port Queue 7
+	 * Ingress Limit ctrl Register is written. When port-based rate limiting
+	 * is used a value of 0h should be written to Port Queue 7 Egress Limit
+	 * Control Register
+	 */
+	ret = lan937x_pwrite8(dev, port, REG_PORT_PRI7_IN_RLIMIT_CTL, 0x00);
+	if (ret)
+		return;
+
+	for (i = 0; i < LAN937X_NUM_TC; i++)
+		res->tc_policers_used[i] = false;
+}
+
+static int lan937x_enable_phy_int(struct ksz_device *dev, int port,
+				  bool enable)
+{
+	u32 addr = PORT_CTRL_ADDR(port, REG_PORT_INT_MASK);
+	u8 data;
+	int ret;
+
+	ret = ksz_read8(dev, addr, &data);
+	if (ret)
+		return ret;
+
+	/* PORT_PTP_INT bit is active low */
+	if (enable)
+		data &= ~PORT_PHY_INT;
+	else
+		data |= PORT_PHY_INT;
+
+	return ksz_write8(dev, addr, data);
+}
+
+static void lan937x_config_cpu_port(struct dsa_switch *ds)
+{
+	struct ksz_device *dev = ds->priv;
+	u32 cascade_cfg = 0;
+	int i;
+
+	/* Moving cpu_port parameter into invalid value */
+	dev->cpu_port = 0xFF;
+	dev->dsa_port = 0xFF;
+
+	ds->num_ports = dev->info->port_cnt;
+
+	for (i = 0; i < dev->info->port_cnt; i++) {
+		if (dsa_is_cpu_port(ds, i) && (dev->info->cpu_ports & (1 << i))) {
+			dev->cpu_port = i;
+
+			/* enable cpu port */
+			lan937x_port_setup(dev, i, true);
+		}
+		if (dsa_is_dsa_port(ds, i)) {
+			ksz_read32(dev, REG_SW_CASCADE_MODE_CTL, &cascade_cfg);
+			cascade_cfg &= ~CASCADE_PORT_SEL;
+			cascade_cfg |= i;
+			ksz_write32(dev, REG_SW_CASCADE_MODE_CTL, cascade_cfg);
+			dev->dsa_port = i;
+			if (dev->ds->index == 1) {
+			        lan937x_port_cfg(dev, i, REG_PORT_CTRL_0,
+				     PORT_TAIL_TAG_ENABLE, true);
+			}
+		}
+	}
+
+	for (i = 0; i < dev->info->port_cnt; i++) {
+		if (i == dev->cpu_port)
+			continue;
+
+		lan937x_port_stp_state_set(ds, i, BR_STATE_DISABLED);
+
+		lan937x_enable_phy_int(dev, i, true);
+	}
+}
+
+static int lan937x_set_rgmii_delay(struct ksz_device *dev, int port,
+				   u32 val, bool is_tx)
+{
+	struct ksz_port *p = &dev->ports[port];
+	const char *name[2] = { "rx", "tx" };
+
+	/* alert if delay is out of range */
+	if (val != 0 && val != 2000) {
+		dev_err(dev->dev,
+			"rgmii %s delay %d is out of range for the port %d\n",
+			name[is_tx], val, port);
+		return -EOPNOTSUPP;
+	}
+
+	/* get the valid value & store it for delay calculation */
+	if (is_tx)
+		p->rgmii_tx_val = val;
+	else
+		p->rgmii_rx_val = val;
+
+	return 0;
+}
+
+static int lan937x_parse_dt_rgmii_delay(struct ksz_device *dev)
+{
+	struct device_node *ports, *port;
+	int err, p;
+	u32 val;
+
+	ports = of_get_child_by_name(dev->dev->of_node, "ports");
+	if (!ports)
+		ports = of_get_child_by_name(dev->dev->of_node,
+					     "ethernet-ports");
+	if (!ports) {
+		dev_err(dev->dev, "no ports child node found\n");
+		return -EINVAL;
+	}
+
+	for_each_available_child_of_node(ports, port) {
+		err = of_property_read_u32(port, "reg", &p);
+		if (err) {
+			dev_err(dev->dev, "Port num not defined in the DT, \"reg\" property\n");
+			of_node_put(ports);
+			of_node_put(port);
+			return err;
+		}
+
+		/* Apply only for rgmii port */
+		if (!lan937x_is_rgmii_port(dev, p))
+			continue;
+
+		if (of_property_read_u32(port, "rx-internal-delay-ps", &val))
+			val = 0;
+
+		err = lan937x_set_rgmii_delay(dev, p, val, false);
+		if (err)
+			break;
+
+		if (of_property_read_u32(port, "tx-internal-delay-ps", &val))
+			val = 0;
+
+		err = lan937x_set_rgmii_delay(dev, p, val, true);
+		if (err)
+			break;
+	}
+
+	of_node_put(ports);
+	return err;
+}
+
+static int lan937x_enable_rsvd__multicast(struct ksz_device *dev)
+{
+	u32 fwd_port = BIT(dev->cpu_port);
+	int ret;
+
+	/* Enable Reserved multicast table */
+	lan937x_cfg(dev, REG_SW_LUE_CTRL_0, SW_RESV_MCAST_ENABLE, true);
+
+	/* Set the Override bit for forwarding BPDU packet to CPU */
+	ret = ksz_write32(dev, REG_SW_ALU_VAL_B,
+			ALU_V_OVERRIDE | BIT(dev->cpu_port));
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4,
+		       	ALU_STAT_START | ALU_RESV_MCAST_ADDR | ALU_STAT_WRITE);
+	if (ret < 0)
+		return ret;
+
+	/* wait to be finished */
+	ret = lan937x_wait_alu_sta_ready(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to update Reserved Multicast table\n");
+		return ret;
+	}
+
+	/* Change forwarding port for second switch */
+	if (dev->ds->index == 1)
+		fwd_port = BIT(dev->dsa_port);
+
+	/* Update Port to which mcast packets forwarded */
+	ret = ksz_write32(dev, REG_SW_ALU_VAL_B, fwd_port);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, (6 << ALU_STAT_INDEX_S) |
+					ALU_RESV_MCAST_ADDR | ALU_STAT_WRITE |
+					ALU_STAT_START);
+
+	if (ret < 0)
+		return ret;
+
+	/* wait to be finished */
+	ret = lan937x_wait_alu_sta_ready(dev);
+	if (ret < 0) {
+		dev_err(dev->dev, "Failed to update Reserved Multicast table\n");
+		return ret;
+	}
+	/* FIXME */
+
+	return 0;
+}
+
+static int lan937x_enable_port_interrupts(struct ksz_device *dev, bool enable)
+{
+	u32 data, mask;
+	int ret;
+
+	ret = ksz_read32(dev, REG_SW_PORT_INT_MASK__4, &data);
+	if (ret)
+		return ret;
+
+	/* 0 means enabling the interrupts */
+	mask = ((1 << dev->info->port_cnt) - 1);
+
+	if (enable)
+		data &= ~mask;
+	else
+		data |= mask;
+
+	ret = ksz_write32(dev, REG_SW_PORT_INT_MASK__4, data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_setup(struct dsa_switch *ds)
+{
+	struct ksz_device *dev = ds->priv;
+	u32 data32;
+	u8 data8;
+	int ret;
+
+	ret = ksz_read8(dev, REG_SW_LUE_CTRL_1, &data8);
+	if (ret < 0)
+		return ret;
+
+	/* Enable Auto Aging */
+	ret = ksz_write8(dev, REG_SW_LUE_CTRL_1, data8 | SW_LINK_AUTO_AGING);
+	if (ret < 0)
+		return ret;
+
+	ds->ageing_time_min = 1000;
+	ds->ageing_time_max = 1048575000;
+
+	/* disable interrupts */
+	ret = ksz_write32(dev, REG_SW_INT_MASK__4, SWITCH_INT_MASK);
+	if (ret < 0)
+		return ret;
+
+	ret = ksz_write32(dev, REG_SW_PORT_INT_MASK__4, 0xFF);
+	if (ret < 0)
+		return ret;
+
+	/* Read interrupt status register */
+	ret = ksz_read32(dev, REG_SW_PORT_INT_STATUS__4, &data32);
+	if (ret < 0)
+		return ret;
+
+	/* Apply rgmii internal delay for the mac based on device tree */
+	ret = lan937x_parse_dt_rgmii_delay(dev);
+	if (ret < 0)
+		return ret;
+
+	/* The VLAN aware is a global setting. Mixed vlan
+	 * filterings are not supported.
+	 */
+	ds->vlan_filtering_is_global = true;
+
+	/* Configure cpu port */
+	lan937x_config_cpu_port(ds);
+
+	/* Enable aggressive back off for half duplex & UNH mode */
+	lan937x_cfg(dev, REG_SW_MAC_CTRL_0,
+		    (SW_PAUSE_UNH_MODE | SW_NEW_BACKOFF | SW_AGGR_BACKOFF),
+		    true);
+
+	/* If NO_EXC_COLLISION_DROP bit is set, the switch will not drop
+	 * packets when 16 or more collisions occur
+	 */
+	lan937x_cfg(dev, REG_SW_MAC_CTRL_1, NO_EXC_COLLISION_DROP, true);
+
+	/* Enable reserved multicast table */
+	lan937x_enable_rsvd__multicast(dev);
+
+	/* enable global MIB counter freeze function */
+	lan937x_cfg(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FREEZE, true);
+
+	/* disable CLK125 & CLK25, 1: disable, 0: enable */
+	lan937x_cfg(dev, REG_SW_GLOBAL_OUTPUT_CTRL__1,
+		    (SW_CLK125_ENB | SW_CLK25_ENB), true);
+
+	lan937x_enable_spi_indirect_access(dev);
+
+	/* Look into the device tree for some configuration values. */
+	/* If we have valid pointers to get into the device tree, ... */
+	if (dev->dev && dev->dev->of_node) {
+		const int *val;
+
+		val = of_get_property(dev->dev->of_node, "led-t1-sel", NULL);
+		/* if an entry was found for led-t1-sel, use it. */
+		if (val) {
+			pr_info("led-t1-sel: 0x%x", be32_to_cpu(*val));
+			ksz_write32(dev, REG32_SW_GLOBAL_LED_T1_SEL,
+				    be32_to_cpu(*val));
+		}
+	}
+
+	ret = lan937x_enable_port_interrupts(dev, true);
+	if (ret)
+		return ret;
+
+	ret = lan937x_ptp_init(dev);
+	if (ret)
+		return ret;
+
+	lan937x_tc_queue_init(ds);
+
+	ret = lan937x_devlink_init(ds);
+	if (ret)
+		goto error_ptp_deinit;
+
+	ret = lan937x_flower_setup(ds);
+	if (ret)
+		return ret;
+	/* start switch */
+	lan937x_cfg(dev, REG_SW_OPERATION, SW_START, true);
+
+	ksz_init_mib_timer(dev);
+
+	return 0;
+
+error_ptp_deinit:
+	lan937x_ptp_deinit(dev);
+	return ret;
+}
+
+static void lan937x_teardown(struct dsa_switch *ds)
+{
+	struct ksz_device *dev = ds->priv;
+
+	lan937x_devlink_exit(ds);
+	lan937x_ptp_deinit(dev);
+}
+
+static int lan937x_change_mtu(struct dsa_switch *ds, int port, int new_mtu)
+{
+	struct ksz_device *dev = ds->priv;
+	int ret;
+
+	new_mtu += VLAN_ETH_HLEN + ETH_FCS_LEN;
+
+	if (dsa_is_cpu_port(ds, port)) {
+		new_mtu += LAN937X_TAG_LEN;
+		if (ds->dst->last_switch)
+			new_mtu += 1;
+	}
+
+	if (dsa_is_dsa_port(ds, port))
+		new_mtu += LAN937X_CASCADE_TAG_LEN;
+
+	if (new_mtu >= FR_MIN_SIZE)
+		ret = lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_0,
+				       PORT_JUMBO_EN, true);
+	else
+		ret = lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_0,
+				       PORT_JUMBO_EN, false);
+	if (ret < 0) {
+		dev_err(ds->dev, "failed to enable jumbo\n");
+		return ret;
+	}
+
+	/* Write the frame size in PORT_MAX_FR_SIZE register */
+	ret = lan937x_pwrite16(dev, port, PORT_MAX_FR_SIZE, new_mtu);
+	if (ret < 0) {
+		dev_err(ds->dev, "failed to change the mtu\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int lan937x_get_max_mtu(struct dsa_switch *ds, int port)
+{
+	/* Frame max size is 9000 (= 0x2328) if
+	 * jumbo frame support is enabled, PORT_JUMBO_EN bit will be enabled
+	 * based on mtu in lan937x_change_mtu() API
+	 */
+	return (FR_MAX_SIZE - VLAN_ETH_HLEN - ETH_FCS_LEN);
+}
+
+static void lan937x_phylink_mac_config(struct dsa_switch *ds, int port,
+				       unsigned int mode,
+				       const struct phylink_link_state *state)
+{
+	struct ksz_device *dev = ds->priv;
+
+	/* Internal PHYs */
+	if (lan937x_is_internal_phy_port(dev, port))
+		return;
+
+	if (phylink_autoneg_inband(mode)) {
+		dev_err(ds->dev, "In-band AN not supported!\n");
+		return;
+	}
+
+	lan937x_mac_config(dev, port, state->interface);
+}
+
+static void lan937x_phylink_mac_link_up(struct dsa_switch *ds, int port,
+					unsigned int mode,
+					phy_interface_t interface,
+					struct phy_device *phydev,
+					int speed, int duplex,
+					bool tx_pause, bool rx_pause)
+{
+	struct ksz_device *dev = ds->priv;
+
+	/* Internal PHYs */
+	if (lan937x_is_internal_phy_port(dev, port))
+		return;
+
+	lan937x_config_interface(dev, port, speed, duplex,
+				 tx_pause, rx_pause);
+}
+
+static void lan937x_phylink_get_caps(struct dsa_switch *ds, int port,
+				     struct phylink_config *config)
+{
+	struct ksz_device *dev = ds->priv;
+
+	/* non legacy driver */
+	config->legacy_pre_march2020 = false;
+
+	config->mac_capabilities = MAC_100FD;
+
+	/* internal T1 PHY */
+	if (lan937x_is_internal_phy_port(dev, port)) {
+		__set_bit(PHY_INTERFACE_MODE_INTERNAL,
+				config->supported_interfaces);
+	} else if (lan937x_is_rgmii_port(dev, port)) {
+		/* MII/RMII/RGMII ports */
+		config->mac_capabilities |= MAC_ASYM_PAUSE | MAC_SYM_PAUSE |
+			MAC_100HD | MAC_10 | MAC_1000FD;
+		phy_interface_set_rgmii(config->supported_interfaces);
+
+		__set_bit(PHY_INTERFACE_MODE_MII,
+				config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_RMII,
+				config->supported_interfaces);
+	}
+}
+
+static void lan937x_get_eth_phy_stats(struct dsa_switch *ds, int port,
+				      struct ethtool_eth_phy_stats *phy_stats)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+	u64 *cnt;
+
+	mutex_lock(&mib->cnt_mutex);
+
+	cnt = &mib->counters[lan937x_mib_rx_sym_err];
+	lan937x_r_mib_pkt(dev, port, lan937x_mib_rx_sym_err, NULL, cnt);
+
+	phy_stats->SymbolErrorDuringCarrier = *cnt;
+
+	mutex_unlock(&mib->cnt_mutex);
+}
+
+static void lan937x_get_eth_mac_stats(struct dsa_switch *ds, int port,
+                                     struct ethtool_eth_mac_stats *mac_stats)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+	u64 *ctr = mib->counters;
+
+	mutex_lock(&mib->cnt_mutex);
+
+	while (mib->cnt_ptr < dev->info->mib_cnt) {
+		lan937x_r_mib_pkt(dev, port, mib->cnt_ptr,
+				NULL, &mib->counters[mib->cnt_ptr]);
+		++mib->cnt_ptr;
+	}
+
+	mac_stats->FramesTransmittedOK = ctr[lan937x_mib_tx_mcast] +
+		ctr[lan937x_mib_tx_bcast] +
+		ctr[lan937x_mib_tx_ucast] +
+		ctr[lan937x_mib_tx_pause];
+
+	mac_stats->SingleCollisionFrames = ctr[lan937x_mib_tx_single_col];
+	mac_stats->MultipleCollisionFrames = ctr[lan937x_mib_tx_mult_col];
+
+	mac_stats->FramesReceivedOK = ctr[lan937x_mib_rx_mcast] +
+		ctr[lan937x_mib_rx_bcast] +
+		ctr[lan937x_mib_rx_ucast] +
+		ctr[lan937x_mib_rx_pause];
+
+	mac_stats->FrameCheckSequenceErrors = ctr[lan937x_mib_rx_crc_err];
+	mac_stats->AlignmentErrors = ctr[lan937x_mib_rx_align_err];
+	mac_stats->OctetsTransmittedOK = ctr[lan937x_mib_tx_total];
+	mac_stats->FramesWithDeferredXmissions = ctr[lan937x_mib_tx_deferred];
+	mac_stats->LateCollisions = ctr[lan937x_mib_tx_late_col];
+	mac_stats->FramesAbortedDueToXSColls = ctr[lan937x_mib_tx_exc_col];
+	mac_stats->FramesLostDueToIntMACXmitError = ctr[lan937x_mib_tx_discard];
+
+	mac_stats->OctetsReceivedOK = ctr[lan937x_mib_rx_total];
+	mac_stats->FramesLostDueToIntMACRcvError = ctr[lan937x_mib_rx_discard];
+	mac_stats->MulticastFramesXmittedOK = ctr[lan937x_mib_tx_mcast];
+	mac_stats->BroadcastFramesXmittedOK = ctr[lan937x_mib_tx_bcast];
+
+	mac_stats->MulticastFramesReceivedOK = ctr[lan937x_mib_rx_mcast];
+	mac_stats->BroadcastFramesReceivedOK = ctr[lan937x_mib_rx_bcast];
+	mac_stats->InRangeLengthErrors = ctr[lan937x_mib_rx_fragments];
+
+	mib->cnt_ptr = 0;
+	mutex_unlock(&mib->cnt_mutex);
+}
+
+static void lan937x_get_eth_ctrl_stats(struct dsa_switch *ds, int port,
+				       struct ethtool_eth_ctrl_stats *ctrl_sts)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+	u64 *cnt;
+
+	mutex_lock(&mib->cnt_mutex);
+
+	cnt = &mib->counters[lan937x_mib_rx_pause];
+	lan937x_r_mib_pkt(dev, port, lan937x_mib_rx_pause, NULL, cnt);
+	ctrl_sts->MACControlFramesReceived = *cnt;
+
+	cnt = &mib->counters[lan937x_mib_tx_pause];
+	lan937x_r_mib_pkt(dev, port, lan937x_mib_tx_pause, NULL, cnt);
+	ctrl_sts->MACControlFramesTransmitted = *cnt;
+
+	mutex_unlock(&mib->cnt_mutex);
+}
+
+static void lan937x_get_stats64(struct dsa_switch *ds, int port,
+				struct rtnl_link_stats64 *s)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port_mib *mib = &dev->ports[port].mib;
+
+	spin_lock(&mib->stats64_lock);
+	memcpy(s, &mib->stats64, sizeof(*s));
+	spin_unlock(&mib->stats64_lock);
+}
+
+static int lan937x_set_ageing_time(struct dsa_switch *ds,
+				   unsigned int msecs)
+{
+	struct ksz_device *dev = ds->priv;
+	u32 secs = msecs / 1000;
+	u32 value;
+	int ret;
+
+	value = FIELD_GET(SW_AGE_PERIOD_7_0_M, secs);
+
+	ret = ksz_write8(dev, REG_SW_AGE_PERIOD__1, value);
+	if (ret < 0)
+		return ret;
+
+	value = FIELD_GET(SW_AGE_PERIOD_19_8_M, secs);
+
+	ret = ksz_write16(dev, REG_SW_AGE_PERIOD__2, value);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+const struct dsa_switch_ops lan937x_switch_ops = {
+	.get_tag_protocol = lan937x_get_tag_protocol,
+	.setup = lan937x_setup,
+	.teardown = lan937x_teardown,
+	.phy_read = lan937x_phy_read16,
+	.phy_write = lan937x_phy_write16,
+	.port_enable = ksz_enable_port,
+	.set_ageing_time = lan937x_set_ageing_time,
+	.get_strings = ksz_get_strings,
+	.get_ethtool_stats = ksz_get_ethtool_stats,
+	.get_sset_count = ksz_sset_count,
+	.get_eth_ctrl_stats = lan937x_get_eth_ctrl_stats,
+	.get_eth_mac_stats = lan937x_get_eth_mac_stats,
+	.get_eth_phy_stats = lan937x_get_eth_phy_stats,
+	.get_stats64 = lan937x_get_stats64,
+	.port_bridge_join = ksz_port_bridge_join,
+	.port_bridge_leave = ksz_port_bridge_leave,
+	.port_stp_state_set = lan937x_port_stp_state_set,
+	.port_fast_age = ksz_port_fast_age,
+	.port_vlan_filtering = lan937x_port_vlan_filtering,
+	.port_vlan_add = lan937x_port_vlan_add,
+	.port_vlan_del = lan937x_port_vlan_del,
+	.port_fdb_dump = lan937x_port_fdb_dump,
+	.port_fdb_add = lan937x_port_fdb_add,
+	.port_fdb_del = lan937x_port_fdb_del,
+	.port_mdb_add = lan937x_port_mdb_add,
+	.port_mdb_del = lan937x_port_mdb_del,
+	.port_mirror_add = lan937x_port_mirror_add,
+	.port_mirror_del = lan937x_port_mirror_del,
+	.port_max_mtu = lan937x_get_max_mtu,
+	.port_change_mtu = lan937x_change_mtu,
+	.phylink_get_caps = lan937x_phylink_get_caps,
+	.phylink_mac_link_down = ksz_mac_link_down,
+	.phylink_mac_config = lan937x_phylink_mac_config,
+	.phylink_mac_link_up = lan937x_phylink_mac_link_up,
+	.port_hwtstamp_get      = lan937x_hwtstamp_get,
+	.port_hwtstamp_set      = lan937x_hwtstamp_set,
+	.port_txtstamp		= lan937x_port_txtstamp,
+	.get_ts_info            = lan937x_get_ts_info,
+	.port_setup_tc          = lan937x_setup_tc,
+	.devlink_param_get	= lan937x_devlink_param_get,
+	.devlink_param_set	= lan937x_devlink_param_set,
+	.devlink_info_get	= lan937x_devlink_info_get,
+	.port_policer_add = lan937x_port_policer_add,
+	.port_policer_del = lan937x_port_policer_del,
+	.cls_flower_add	= lan937x_cls_flower_add,
+	.cls_flower_del	= lan937x_cls_flower_del,
+	.cls_flower_stats = lan937x_cls_flower_stats
+};
+
+int lan937x_switch_register(struct ksz_device *dev)
+{
+	return ksz_switch_register(dev, &lan937x_dev_ops);
+}
+EXPORT_SYMBOL(lan937x_switch_register);
+
+MODULE_AUTHOR("Prasanna Vengateshan Varadharajan <Prasanna.Vengateshan@microchip.com>");
+MODULE_DESCRIPTION("Microchip LAN937x Series Switch DSA Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/dsa/microchip/lan937x_ptp.c b/drivers/net/dsa/microchip/lan937x_ptp.c
new file mode 100644
index 000000000000..2ba7d1266fec
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_ptp.c
@@ -0,0 +1,1250 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip LAN937X PTP Implementation
+ * Copyright (C) 2019-2020 Microchip Technology Inc.
+ */
+
+#include <linux/kernel.h>
+#include "ksz_common.h"
+#include "lan937x_reg.h"
+#include "lan937x_dev.h"
+#include "lan937x_ptp.h"
+#include "ksz_common.h"
+#include <linux/ptp_classify.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/irqreturn.h>
+
+#define ptp_clock_info_to_dev(d) \
+	container_of((d), struct ksz_device, ptp_caps)
+#define sync_to_port(work) \
+		container_of((work), struct lan937x_port_ptp_shared, sync_work)
+#define pdelayreq_to_port(work) \
+	   container_of((work), struct lan937x_port_ptp_shared, pdelayreq_work)
+#define pdelayrsp_to_port(work) \
+	   container_of((work), struct lan937x_port_ptp_shared, pdelayrsp_work)
+#define ptp_shared_to_ksz_port(t) \
+		container_of((t), struct ksz_port, ptp_shared)
+#define ptp_shared_to_ksz_device(t) \
+		container_of((t), struct ksz_device, ptp_shared)
+
+#define MAX_DRIFT_CORR 6250000
+
+#define KSZ_PTP_INC_NS 40  /* HW clock is incremented every 40 ns (by 40) */
+#define KSZ_PTP_SUBNS_BITS 32  /* Number of bits in sub-nanoseconds counter */
+
+static int _lan937x_ptp_gettime(struct ksz_device *dev, struct timespec64 *ts);
+
+/* PPS Support */
+#define PPS_LED_1	0
+#define PPS_LED_2	1
+
+#define LAN937x_PPS_TOU 2   /* currently fixed to trigger output unit 2 */
+
+static int lan937x_ptp_tou_index(struct ksz_device *dev, u8 index,
+				 u32 pps_led_index)
+{
+	u32 data;
+	int ret;
+
+	data = ((index << PTP_TOU_INDEX_S) |
+		(pps_led_index << PTP_GPIO_INDEX_S));
+
+	ret = lan937x_cfg32(dev, REG_PTP_UNIT_INDEX__4, data, true);
+
+	return ret;
+}
+
+static int lan937x_ptp_tou_reset(struct ksz_device *dev)
+{
+	int ret;
+
+	/* Reset trigger unit */
+	ret = lan937x_cfg32(dev, REG_PTP_CTRL_STAT__4, TRIG_RESET, true);
+	if (ret)
+		return ret;
+
+	/* Clear reset */
+	ret = lan937x_cfg32(dev, REG_PTP_CTRL_STAT__4,
+			    (TRIG_RESET | TRIG_ENABLE), false);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_ptp_tou_cycle_count_set(struct ksz_device *dev, u16 count)
+{
+	u32 data;
+	int ret;
+
+	ret = ksz_read32(dev, REG_TRIG_CYCLE_CNT, &data);
+	if (ret)
+		return ret;
+
+	data &= ~(TRIG_CYCLE_CNT_M << TRIG_CYCLE_CNT_S);
+	data |= (count & TRIG_CYCLE_CNT_M) << TRIG_CYCLE_CNT_S;
+
+	ret = ksz_write32(dev, REG_TRIG_CYCLE_CNT, data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_set_tou_target_time(struct ksz_device *dev)
+{
+	struct timespec64 now, pps_start, diff;
+	int ret;
+
+	/* Read current time */
+	ret = _lan937x_ptp_gettime(dev, &now);
+	if (ret)
+		return ret;
+
+	/* Determine and write start time of PPS */
+	pps_start.tv_sec = now.tv_sec + 1;
+	pps_start.tv_nsec = 0;
+	diff = timespec64_sub(pps_start, now);
+
+	/* Reserve at least 1ms for programming and activating */
+	if (diff.tv_nsec < 1000000)
+		pps_start.tv_sec++;
+
+	ret = ksz_write32(dev, REG_TRIG_TARGET_NANOSEC, pps_start.tv_nsec);
+	if (ret)
+		return ret;
+
+	ret = ksz_write32(dev, REG_TRIG_TARGET_SEC, pps_start.tv_sec);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_ptp_tou_gpio(struct ksz_device *dev, u32 pps_led_index)
+{
+	u32 data;
+	int ret;
+
+	/* Set the Led Override register */
+	ret = ksz_read32(dev, REG_SW_GLOBAL_LED_OVR__4, &data);
+	if (ret)
+		return ret;
+
+	if (pps_led_index == PPS_LED_2)
+		data |= LED_OVR_2;
+	else
+		data |= LED_OVR_1;
+
+	ret = ksz_write32(dev, REG_SW_GLOBAL_LED_OVR__4, data);
+	if (ret)
+		return ret;
+
+	/* Set the Led Source register */
+	ret = ksz_read32(dev, REG_SW_GLOBAL_LED_SRC__4, &data);
+	if (ret)
+		return ret;
+
+	if (pps_led_index == PPS_LED_2)
+		data |= LED_SRC_PTP_GPIO_2;
+	else
+		data |= LED_SRC_PTP_GPIO_1;
+
+	ret = ksz_write32(dev, REG_SW_GLOBAL_LED_SRC__4, data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_ptp_enable_pps(struct ksz_device *dev, int on)
+{
+	u32 pps_led_index = 0;
+	u32 data;
+	int ret;
+
+	if (dev->ptp_tou_mode != KSZ_PTP_TOU_PPS &&
+	    dev->ptp_tou_mode != KSZ_PTP_TOU_IDLE)
+		return -EBUSY;
+
+	//get the pps led no, numbering is -1 from dts tree
+	if (!(of_property_read_u32(dev->dev->of_node, "pps_led_index",
+				   &pps_led_index))) {
+		if (pps_led_index == 1 || pps_led_index == 2)
+			pps_led_index -= 1;
+		else
+			return -EINVAL;
+	}
+
+	/* Set the tou index register */
+	ret = lan937x_ptp_tou_index(dev, LAN937x_PPS_TOU, pps_led_index);
+	if (ret)
+		return ret;
+
+	/* Reset trigger unit  */
+	ret = lan937x_ptp_tou_reset(dev);
+	if (ret)
+		return ret;
+
+	if (!on) {
+		dev->ptp_tou_mode = KSZ_PTP_TOU_IDLE;
+		return 0; /* success */
+	}
+
+	/* set periodic pulse pattern */
+	data = (TRIG_POS_PERIOD << TRIG_PATTERN_S) |
+	       (pps_led_index << TRIG_GPO_S);
+	ret = ksz_write32(dev, REG_TRIG_CTRL__4, data);
+	if (ret)
+		return ret;
+
+	/* Set cycle width (1 s) */
+	ret = ksz_write32(dev, REG_TRIG_CYCLE_WIDTH, NSEC_PER_SEC);
+	if (ret)
+		return ret;
+
+	/* Set cycle count (infinite) */
+	ret = lan937x_ptp_tou_cycle_count_set(dev, 0);
+	if (ret)
+		return ret;
+
+	/* Set pulse with (20 ms / 8 ns) */
+	data = (20000000 / 8);
+	ret = ksz_write32(dev, REG_TRIG_PULSE_WIDTH__4, data);
+	if (ret)
+		return ret;
+
+	/* Set target time */
+	ret = lan937x_set_tou_target_time(dev);
+	if (ret)
+		return ret;
+
+	/* Configure GPIO pins */
+	ret = lan937x_ptp_tou_gpio(dev, pps_led_index);
+	if (ret)
+		return ret;
+
+	/* Activate trigger unit */
+	ret = lan937x_cfg32(dev, REG_PTP_CTRL_STAT__4, (GPIO_OUT | TRIG_ENABLE),
+			    true);
+	if (ret)
+		return ret;
+
+	dev->ptp_tou_mode = KSZ_PTP_TOU_PPS;
+	return 0;
+}
+
+/*Time Stamping support - accessing the register */
+static int lan937x_ptp_enable_mode(struct ksz_device *dev, bool enable)
+{
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, REG_PTP_MSG_CONF1, &data);
+	if (ret)
+		return ret;
+
+	/* Enable PTP mode */
+	if (enable)
+		data |= PTP_ENABLE;
+	else
+		data &= ~PTP_ENABLE;
+
+	ret = ksz_write16(dev, REG_PTP_MSG_CONF1, data);
+	if (ret)
+		return ret;
+
+	if (enable) {
+		/* Schedule cyclic call of ksz_ptp_do_aux_work() */
+		ret = ptp_schedule_worker(dev->ptp_clock, 0);
+		if (ret)
+			goto error_disable_mode;
+	} else {
+		ptp_cancel_worker_sync(dev->ptp_clock);
+	}
+
+	return 0;
+
+error_disable_mode:
+	ksz_write16(dev, REG_PTP_MSG_CONF1, data & ~PTP_ENABLE);
+	return ret;
+}
+
+/* The function is return back the capability of timestamping feature when
+ * requested through ethtool -T <interface> utility
+ */
+int lan937x_get_ts_info(struct dsa_switch *ds, int port,
+			struct ethtool_ts_info *ts)
+{
+	struct ksz_device *dev = ds->priv;
+
+	ts->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+			      SOF_TIMESTAMPING_RX_HARDWARE |
+			      SOF_TIMESTAMPING_RAW_HARDWARE;
+
+	ts->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
+
+	ts->rx_filters =
+		(1 << HWTSTAMP_FILTER_NONE) | (1 << HWTSTAMP_FILTER_ALL);
+
+	ts->phc_index = ptp_clock_index(dev->ptp_clock);
+
+	return 0;
+}
+
+int lan937x_hwtstamp_get(struct dsa_switch *ds, int port, struct ifreq *ifr)
+{
+	struct ksz_device *dev = ds->priv;
+	struct hwtstamp_config config;
+
+	config.flags = 0;
+
+	if (dev->ports[port].hwts_tx_en)
+		config.tx_type = HWTSTAMP_TX_ON;
+	else
+		config.tx_type = HWTSTAMP_TX_OFF;
+
+	if (test_bit(LAN937X_HWTS_EN, &dev->ptp_shared.state))
+		config.rx_filter = HWTSTAMP_FILTER_ALL;
+	else
+		config.rx_filter = HWTSTAMP_FILTER_NONE;
+
+	return copy_to_user(ifr->ifr_data, &config,
+			    sizeof(struct hwtstamp_config)) ?
+		       -EFAULT :
+		       0;
+}
+
+static int lan937x_set_hwtstamp_config(struct ksz_device *dev, int port,
+				       struct hwtstamp_config *config)
+{
+	struct ksz_device_ptp_shared *ptp_shared = &dev->ptp_shared;
+	struct ksz_port *prt = &dev->ports[port];
+	bool rx_on;
+
+	/* reserved for future extensions */
+	if (config->flags)
+		return -EINVAL;
+
+	switch (config->tx_type) {
+	case HWTSTAMP_TX_OFF:
+		prt->hwts_tx_en = false;
+		break;
+	case HWTSTAMP_TX_ON:
+		prt->hwts_tx_en = true;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (config->rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		rx_on = false;
+		break;
+	default:
+		rx_on = true;
+		break;
+	}
+
+	if (rx_on != test_bit(LAN937X_HWTS_EN, &ptp_shared->state)) {
+		int ret;
+
+		clear_bit(LAN937X_HWTS_EN, &dev->ptp_shared.state);
+
+		ret = lan937x_ptp_enable_mode(dev, rx_on);
+		if (ret)
+			return ret;
+
+		if (rx_on)
+			set_bit(LAN937X_HWTS_EN, &ptp_shared->state);
+	}
+
+	return 0;
+}
+
+int lan937x_hwtstamp_set(struct dsa_switch *ds, int port, struct ifreq *ifr)
+{
+	struct ksz_device *dev = ds->priv;
+	struct hwtstamp_config config;
+	int ret;
+
+	mutex_lock(&dev->ptp_mutex);
+
+	ret = copy_from_user(&config, ifr->ifr_data, sizeof(config));
+	if (ret)
+		goto error_return;
+
+	ret = lan937x_set_hwtstamp_config(dev, port, &config);
+	if (ret)
+		goto error_return;
+
+	/* Save the chosen configuration to be returned later. */
+	ret = copy_to_user(ifr->ifr_data, &config, sizeof(config));
+
+error_return:
+	mutex_unlock(&dev->ptp_mutex);
+	return ret;
+}
+
+void lan937x_port_txtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)
+{
+	struct ksz_device *dev = ds->priv;
+	struct ksz_port *prt = &dev->ports[port];
+	struct ptp_header *hdr;
+	struct sk_buff *clone;
+	unsigned int type;
+	u8 ptp_msg_type;
+
+	if (!prt->hwts_tx_en)
+		return;
+
+	type = ptp_classify_raw(skb);
+	if (type == PTP_CLASS_NONE)
+		return;
+
+	hdr = ptp_parse_header(skb, type);
+	if (!hdr)
+		return;
+
+	ptp_msg_type = ptp_get_msgtype(hdr, type);
+
+	switch (ptp_msg_type) {
+	case PTP_MSGTYPE_PDELAY_REQ:
+	case PTP_MSGTYPE_PDELAY_RESP:
+	case PTP_MSGTYPE_SYNC:
+		break;
+
+	default:
+		return;
+	}
+
+	clone = skb_clone_sk(skb);
+	if (!clone)
+		return;
+
+	KSZ_SKB_CB(skb)->clone = clone;
+	KSZ_SKB_CB(clone)->ptp_type = type;
+	KSZ_SKB_CB(clone)->ptp_msg_type = ptp_msg_type;
+}
+
+//These are function related to the ptp clock info
+static int lan937x_ptp_enable(struct ptp_clock_info *ptp,
+			      struct ptp_clock_request *req, int on)
+{
+	struct ksz_device *dev = ptp_clock_info_to_dev(ptp);
+	int ret;
+
+	switch (req->type) {
+	case PTP_CLK_REQ_PPS:
+		mutex_lock(&dev->ptp_mutex);
+		ret = lan937x_ptp_enable_pps(dev, on);
+		mutex_unlock(&dev->ptp_mutex);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int _lan937x_ptp_gettime(struct ksz_device *dev, struct timespec64 *ts)
+{
+	u32 nanoseconds;
+	u32 seconds;
+	u16 data16;
+	u8 phase;
+	int ret;
+
+	/* Copy current PTP clock into shadow registers */
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data16);
+	if (ret)
+		return ret;
+
+	data16 |= PTP_READ_TIME;
+
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data16);
+	if (ret)
+		return ret;
+
+	/* Read from shadow registers */
+	ret = ksz_read8(dev, REG_PTP_RTC_SUB_NANOSEC__2, &phase);
+	if (ret)
+		return ret;
+
+	ret = ksz_read32(dev, REG_PTP_RTC_NANOSEC, &nanoseconds);
+	if (ret)
+		return ret;
+
+	ret = ksz_read32(dev, REG_PTP_RTC_SEC, &seconds);
+	if (ret)
+		return ret;
+
+	ts->tv_sec = seconds;
+	ts->tv_nsec = nanoseconds + phase * 8;
+
+	return 0;
+}
+
+int lan937x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
+{
+	struct ksz_device *dev = ptp_clock_info_to_dev(ptp);
+	int ret;
+
+	mutex_lock(&dev->ptp_mutex);
+	ret = _lan937x_ptp_gettime(dev, ts);
+	mutex_unlock(&dev->ptp_mutex);
+
+	return ret;
+}
+
+static int lan937x_ptp_settime(struct ptp_clock_info *ptp,
+			       const struct timespec64 *ts)
+{
+	struct ksz_device *dev = container_of(ptp, struct ksz_device, ptp_caps);
+	struct ksz_device_ptp_shared *ptp_shared = &dev->ptp_shared;
+	u16 data16;
+	int ret;
+
+	mutex_lock(&dev->ptp_mutex);
+
+	/* Write to shadow registers */
+
+	/* clock phase */
+	ret = ksz_read16(dev, REG_PTP_RTC_SUB_NANOSEC__2, &data16);
+	if (ret)
+		goto error_return;
+
+	data16 &= ~PTP_RTC_SUB_NANOSEC_M;
+
+	ret = ksz_write16(dev, REG_PTP_RTC_SUB_NANOSEC__2, data16);
+	if (ret)
+		goto error_return;
+
+	/* nanoseconds */
+	ret = ksz_write32(dev, REG_PTP_RTC_NANOSEC, ts->tv_nsec);
+	if (ret)
+		goto error_return;
+
+	/* seconds */
+	ret = ksz_write32(dev, REG_PTP_RTC_SEC, ts->tv_sec);
+	if (ret)
+		goto error_return;
+
+	/* Load PTP clock from shadow registers */
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data16);
+	if (ret)
+		goto error_return;
+
+	data16 |= PTP_LOAD_TIME;
+
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data16);
+	if (ret)
+		goto error_return;
+
+	switch (dev->ptp_tou_mode) {
+	case KSZ_PTP_TOU_IDLE:
+		break;
+
+	case KSZ_PTP_TOU_PPS:
+		ret = lan937x_ptp_enable_pps(dev, true);
+		if (ret)
+			goto error_return;
+		break;
+	}
+
+	spin_lock_bh(&ptp_shared->ptp_clock_lock);
+	ptp_shared->ptp_clock_time = *ts;
+	spin_unlock_bh(&ptp_shared->ptp_clock_lock);
+
+error_return:
+	mutex_unlock(&dev->ptp_mutex);
+
+	return ret;
+}
+
+static int lan937x_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)
+{
+	struct ksz_device *dev = ptp_clock_info_to_dev(ptp);
+	u16 data16;
+	int ret;
+
+	mutex_lock(&dev->ptp_mutex);
+
+	if (scaled_ppm) {
+		/* basic calculation:
+		 * s32 ppb = scaled_ppm_to_ppb(scaled_ppm);
+		 * s64 adj = div_s64(((s64)ppb * KSZ_PTP_INC_NS) << KSZ_PTP_SUBNS_BITS,
+		 * NSEC_PER_SEC);
+		 */
+
+		/* more precise calculation (avoids shifting out precision) */
+		s64 ppb, adj;
+		u32 data32;
+
+		/* see scaled_ppm_to_ppb() in ptp_clock.c for details */
+		ppb = 1 + scaled_ppm;
+		ppb *= 125;
+		ppb *= KSZ_PTP_INC_NS;
+		ppb <<= KSZ_PTP_SUBNS_BITS - 13;
+		adj = div_s64(ppb, NSEC_PER_SEC);
+
+		data32 = abs(adj);
+		data32 &= BIT_MASK(30) - 1;
+		if (adj >= 0)
+			data32 |= PTP_RATE_DIR;
+
+		ret = ksz_write32(dev, REG_PTP_SUBNANOSEC_RATE, data32);
+		if (ret)
+			goto error_return;
+	}
+
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data16);
+	if (ret)
+		goto error_return;
+
+	if (scaled_ppm)
+		data16 |= PTP_CLK_ADJ_ENABLE;
+	else
+		data16 &= ~PTP_CLK_ADJ_ENABLE;
+
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data16);
+	if (ret)
+		goto error_return;
+
+error_return:
+	mutex_unlock(&dev->ptp_mutex);
+	return ret;
+}
+
+static int lan937x_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	struct ksz_device *dev = container_of(ptp, struct ksz_device, ptp_caps);
+	struct ksz_device_ptp_shared *ptp_shared = &dev->ptp_shared;
+	struct timespec64 delta64 = ns_to_timespec64(delta);
+	s32 sec, nsec;
+	u16 data16;
+	int ret;
+
+	mutex_lock(&dev->ptp_mutex);
+
+	/* do not use ns_to_timespec64(),
+	 * both sec and nsec are subtracted by hw
+	 */
+	sec = div_s64_rem(delta, NSEC_PER_SEC, &nsec);
+
+	ret = ksz_write32(dev, REG_PTP_RTC_NANOSEC, abs(nsec));
+	if (ret)
+		goto error_return;
+
+	/* contradictory to the data sheet, seconds are also considered */
+	ret = ksz_write32(dev, REG_PTP_RTC_SEC, abs(sec));
+	if (ret)
+		goto error_return;
+
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data16);
+	if (ret)
+		goto error_return;
+
+	data16 |= PTP_STEP_ADJ;
+	if (delta < 0)
+		data16 &= ~PTP_STEP_DIR; /* 0: subtract */
+	else
+		data16 |= PTP_STEP_DIR; /* 1: add */
+
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data16);
+	if (ret)
+		goto error_return;
+
+	switch (dev->ptp_tou_mode) {
+	case KSZ_PTP_TOU_IDLE:
+		break;
+
+	case KSZ_PTP_TOU_PPS:
+		ret = lan937x_ptp_enable_pps(dev, true);
+		if (ret)
+			goto error_return;
+		break;
+	}
+
+	spin_lock_bh(&ptp_shared->ptp_clock_lock);
+	ptp_shared->ptp_clock_time = timespec64_add(ptp_shared->ptp_clock_time,
+						    delta64);
+	spin_unlock_bh(&ptp_shared->ptp_clock_lock);
+
+error_return:
+	mutex_unlock(&dev->ptp_mutex);
+	return ret;
+}
+
+/*  Function is pointer to the do_aux_work in the ptp_clock capability */
+static long lan937x_ptp_do_aux_work(struct ptp_clock_info *ptp)
+{
+	struct ksz_device *dev = container_of(ptp, struct ksz_device, ptp_caps);
+	struct ksz_device_ptp_shared *ptp_shared = &dev->ptp_shared;
+	struct timespec64 ts;
+
+	mutex_lock(&dev->ptp_mutex);
+	_lan937x_ptp_gettime(dev, &ts);
+	mutex_unlock(&dev->ptp_mutex);
+
+	spin_lock_bh(&ptp_shared->ptp_clock_lock);
+	ptp_shared->ptp_clock_time = ts;
+	spin_unlock_bh(&ptp_shared->ptp_clock_lock);
+
+	return HZ; /* reschedule in 1 second */
+}
+
+static int lan937x_ptp_start_clock(struct ksz_device *dev)
+{
+	struct ksz_device_ptp_shared *ptp_shared = &dev->ptp_shared;
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data);
+	if (ret)
+		return ret;
+
+	/* Enable PTP clock */
+	data |= PTP_CLK_ENABLE;
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data);
+	if (ret)
+		return ret;
+
+	spin_lock_bh(&ptp_shared->ptp_clock_lock);
+	ptp_shared->ptp_clock_time.tv_sec = 0;
+	ptp_shared->ptp_clock_time.tv_nsec = 0;
+	spin_unlock_bh(&ptp_shared->ptp_clock_lock);
+
+	return 0;
+}
+
+static int lan937x_ptp_stop_clock(struct ksz_device *dev)
+{
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data);
+	if (ret)
+		return ret;
+
+	/* Disable PTP clock */
+	data &= ~PTP_CLK_ENABLE;
+	ret = ksz_write16(dev, REG_PTP_CLK_CTRL, data);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int lan937x_ptp_8021as(struct ksz_device *dev, bool enable)
+{
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, REG_PTP_MSG_CONF1, &data);
+	if (ret)
+		return ret;
+
+	if (enable)
+		data |= PTP_802_1AS;
+	else
+		data &= ~PTP_802_1AS;
+
+	return ksz_write16(dev, REG_PTP_MSG_CONF1, data);
+}
+
+/* Function to enable/disable Port PTP interrupt */
+static int lan937x_ptp_enable_ptp_int(struct ksz_device *dev, int port,
+				      bool enable)
+{
+	u32 addr = PORT_CTRL_ADDR(port, REG_PORT_INT_MASK);
+	u8 data;
+	int ret;
+
+	ret = ksz_read8(dev, addr, &data);
+	if (ret)
+		return ret;
+
+	/* PORT_PTP_INT bit is active low */
+	if (enable)
+		data &= ~PORT_PTP_INT;
+	else
+		data |= PORT_PTP_INT;
+
+	return ksz_write8(dev, addr, data);
+}
+
+/* Function to enable/disable Individual message interrupt */
+static int lan937x_ptp_enable_msg_int(struct ksz_device *dev, int port,
+				      u16 mask, bool enable)
+{
+	u32 addr = PORT_CTRL_ADDR(port, REG_PTP_PORT_TX_INT_ENABLE__2);
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, addr, &data);
+	if (ret)
+		return ret;
+
+	/* PTP msg interrupts are active high (1 means enabled)*/
+	if (enable)
+		data |= mask;
+	else
+		data &= ~mask;
+
+	return ksz_write16(dev, addr, data);
+}
+
+static void lan937x_sync_txtstamp_skb(struct ksz_device *dev,
+				      struct ksz_port *prt, struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps hwtstamps = {};
+	int ret;
+
+	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+	/* timeout must include tstamp latency, IRQ latency and time for
+	 * reading the time stamp.
+	 */
+	ret = wait_for_completion_timeout(&prt->tstamp_sync_comp,
+					  msecs_to_jiffies(100));
+	if (!ret)
+		return;
+
+	hwtstamps.hwtstamp = prt->tstamp_sync;
+	skb_complete_tx_timestamp(skb, &hwtstamps);
+}
+
+static void lan937x_pdelayreq_txtstamp_skb(struct ksz_device *dev,
+					   struct ksz_port *prt,
+					   struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps hwtstamps = {};
+	int ret;
+
+	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+	/* timeout must include tstamp latency, IRQ latency and time for
+	 * reading the time stamp.
+	 */
+	ret = wait_for_completion_timeout(&prt->tstamp_pdelayreq_comp,
+					  msecs_to_jiffies(100));
+	if (!ret)
+		return;
+
+	hwtstamps.hwtstamp = prt->tstamp_pdelayreq;
+	skb_complete_tx_timestamp(skb, &hwtstamps);
+}
+
+static void lan937x_pdelayrsp_txtstamp_skb(struct ksz_device *dev,
+					   struct ksz_port *prt,
+					   struct sk_buff *skb)
+{
+	struct skb_shared_hwtstamps hwtstamps = {};
+	int ret;
+
+	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+	/* timeout must include tstamp latency, IRQ latency and time for
+	 * reading the time stamp.
+	 */
+	ret = wait_for_completion_timeout(&prt->tstamp_pdelayrsp_comp,
+					  msecs_to_jiffies(100));
+	if (!ret)
+		return;
+
+	hwtstamps.hwtstamp = prt->tstamp_pdelayrsp;
+	skb_complete_tx_timestamp(skb, &hwtstamps);
+}
+
+/* Deferred work is necessary for time stamped messages. This cannot
+ * be done from atomic context as we have to wait for the hardware interrupt.
+ */
+static void lan937x_sync_deferred_xmit(struct kthread_work *work)
+{
+	struct lan937x_port_ptp_shared *prt_ptp_shared = sync_to_port(work);
+	struct ksz_port *prt = ptp_shared_to_ksz_port(prt_ptp_shared);
+	struct ksz_device_ptp_shared *ptp_shared = prt_ptp_shared->dev;
+	struct ksz_device *dev = ptp_shared_to_ksz_device(ptp_shared);
+	int port = prt - dev->ports;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&prt_ptp_shared->sync_queue)) != NULL) {
+		struct sk_buff *clone = KSZ_SKB_CB(skb)->clone;
+
+		reinit_completion(&prt->tstamp_sync_comp);
+
+		/* Transfer skb to the host port. */
+		dsa_enqueue_skb(skb, dsa_to_port(dev->ds, port)->slave);
+
+		lan937x_sync_txtstamp_skb(dev, prt, clone);
+	}
+}
+
+static void lan937x_pdelayreq_deferred_xmit(struct kthread_work *work)
+{
+	struct lan937x_port_ptp_shared *prt_ptp_shared =
+		pdelayreq_to_port(work);
+	struct ksz_port *prt = ptp_shared_to_ksz_port(prt_ptp_shared);
+	struct ksz_device_ptp_shared *ptp_shared = prt_ptp_shared->dev;
+	struct ksz_device *dev = ptp_shared_to_ksz_device(ptp_shared);
+	int port = prt - dev->ports;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&prt_ptp_shared->pdelayreq_queue)) != NULL) {
+		struct sk_buff *clone = KSZ_SKB_CB(skb)->clone;
+
+		reinit_completion(&prt->tstamp_pdelayreq_comp);
+
+		/* Transfer skb to the host port. */
+		dsa_enqueue_skb(skb, dsa_to_port(dev->ds, port)->slave);
+
+		lan937x_pdelayreq_txtstamp_skb(dev, prt, clone);
+	}
+}
+
+static void lan937x_pdelayrsp_deferred_xmit(struct kthread_work *work)
+{
+	struct lan937x_port_ptp_shared *prt_ptp_shared =
+		pdelayrsp_to_port(work);
+	struct ksz_port *prt = ptp_shared_to_ksz_port(prt_ptp_shared);
+	struct ksz_device_ptp_shared *ptp_shared = prt_ptp_shared->dev;
+	struct ksz_device *dev = ptp_shared_to_ksz_device(ptp_shared);
+	int port = prt - dev->ports;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&prt_ptp_shared->pdelayrsp_queue)) != NULL) {
+		struct sk_buff *clone = KSZ_SKB_CB(skb)->clone;
+
+		reinit_completion(&prt->tstamp_pdelayrsp_comp);
+
+		/* Transfer skb to the host port. */
+		dsa_enqueue_skb(skb, dsa_to_port(dev->ds, port)->slave);
+
+		lan937x_pdelayrsp_txtstamp_skb(dev, prt, clone);
+	}
+}
+
+/* Function is to  enable the Message Interrupt and initialize the worker queue
+ * for processing the Interrupt routine
+ */
+static int lan937x_ptp_sync_msg_en(struct ksz_device *dev, int port)
+{
+	struct ksz_port *prt = &dev->ports[port];
+	struct lan937x_port_ptp_shared *ptp_shared = &prt->ptp_shared;
+	struct dsa_port *dp = dsa_to_port(dev->ds, port);
+	int ret;
+
+	ret = lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_SYNC_INT, true);
+	if (ret)
+		return ret;
+
+	init_completion(&prt->tstamp_sync_comp);
+	skb_queue_head_init(&ptp_shared->sync_queue);
+	kthread_init_work(&ptp_shared->sync_work, lan937x_sync_deferred_xmit);
+	ptp_shared->sync_worker =
+		kthread_create_worker(0, "%s_sync", dp->slave->name);
+
+	if (IS_ERR(ptp_shared->sync_worker)) {
+		ret = PTR_ERR(ptp_shared->sync_worker);
+		goto error_disable_interrupt;
+	}
+
+	return 0;
+
+error_disable_interrupt:
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_SYNC_INT, false);
+	return ret;
+}
+
+static int lan937x_ptp_xdelayreq_msg_en(struct ksz_device *dev, int port)
+{
+	struct ksz_port *prt = &dev->ports[port];
+	struct lan937x_port_ptp_shared *ptp_shared = &prt->ptp_shared;
+	struct dsa_port *dp = dsa_to_port(dev->ds, port);
+	int ret;
+
+	ret = lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_XDELAY_REQ_INT,
+					 true);
+	if (ret)
+		return ret;
+
+	init_completion(&prt->tstamp_pdelayreq_comp);
+	skb_queue_head_init(&ptp_shared->pdelayreq_queue);
+	kthread_init_work(&ptp_shared->pdelayreq_work,
+			  lan937x_pdelayreq_deferred_xmit);
+
+	ptp_shared->pdelayreq_worker =
+		kthread_create_worker(0, "%s_req_xmit", dp->slave->name);
+
+	if (IS_ERR(ptp_shared->pdelayreq_worker)) {
+		ret = PTR_ERR(ptp_shared->pdelayreq_worker);
+		goto error_disable_interrupt;
+	}
+
+	return 0;
+
+error_disable_interrupt:
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_XDELAY_REQ_INT, false);
+	return ret;
+}
+
+static int lan937x_ptp_pdelayresp_msg_en(struct ksz_device *dev, int port)
+{
+	struct ksz_port *prt = &dev->ports[port];
+	struct lan937x_port_ptp_shared *ptp_shared = &prt->ptp_shared;
+	struct dsa_port *dp = dsa_to_port(dev->ds, port);
+	int ret;
+
+	ret = lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_PDELAY_RESP_INT,
+					 true);
+	if (ret)
+		return ret;
+
+	init_completion(&prt->tstamp_pdelayrsp_comp);
+	skb_queue_head_init(&ptp_shared->pdelayrsp_queue);
+	kthread_init_work(&ptp_shared->pdelayrsp_work,
+			  lan937x_pdelayrsp_deferred_xmit);
+
+	ptp_shared->pdelayrsp_worker =
+		kthread_create_worker(0, "%s_rsp_xmit", dp->slave->name);
+
+	if (IS_ERR(ptp_shared->pdelayrsp_worker)) {
+		ret = PTR_ERR(ptp_shared->pdelayrsp_worker);
+		goto error_disable_interrupt;
+	}
+
+	return 0;
+
+error_disable_interrupt:
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_PDELAY_RESP_INT, false);
+	return ret;
+}
+
+static int lan937x_ptp_port_init(struct ksz_device *dev, int port)
+{
+	struct dsa_port *dp = dsa_to_port(dev->ds, port);
+	struct lan937x_port_ptp_shared *ptp_shared;
+	struct ksz_port *prt = &dev->ports[port];
+	int ret;
+
+	ptp_shared = &prt->ptp_shared;
+
+	if (port == dev->cpu_port)
+		return 0;
+
+	/* Set rx and tx latency to 0 (will be handled by user space) */
+	ret = ksz_write16(dev, PORT_CTRL_ADDR(port, REG_PTP_PORT_RX_DELAY__2),
+			  0);
+	if (ret)
+		return ret;
+
+	ret = ksz_write16(dev, PORT_CTRL_ADDR(port, REG_PTP_PORT_TX_DELAY__2),
+			  0);
+	if (ret)
+		return ret;
+
+	ret = lan937x_ptp_enable_ptp_int(dev, port, true);
+	if (ret)
+		return ret;
+
+	/* ksz_port::ptp_shared is used in tagging driver */
+	ptp_shared->dev = &dev->ptp_shared;
+	dp->priv = ptp_shared;
+
+	ret = lan937x_ptp_sync_msg_en(dev, port);
+	if (ret)
+		goto error_disable_ptp_int;
+
+	ret = lan937x_ptp_xdelayreq_msg_en(dev, port);
+	if (ret)
+		goto error_disable_ptp_int;
+
+	ret = lan937x_ptp_pdelayresp_msg_en(dev, port);
+	if (ret)
+		goto error_disable_ptp_int;
+
+	return 0;
+
+error_disable_ptp_int:
+	lan937x_ptp_enable_ptp_int(dev, port, false);
+	return ret;
+}
+
+static void lan937x_ptp_port_deinit(struct ksz_device *dev, int port)
+{
+	struct lan937x_port_ptp_shared *ptp_shared =
+		&dev->ports[port].ptp_shared;
+
+	if (port == dev->cpu_port)
+		return;
+
+	kthread_destroy_worker(ptp_shared->sync_worker);
+	kthread_destroy_worker(ptp_shared->pdelayreq_worker);
+	kthread_destroy_worker(ptp_shared->pdelayrsp_worker);
+
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_PDELAY_RESP_INT, false);
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_XDELAY_REQ_INT, false);
+	lan937x_ptp_enable_msg_int(dev, port, PTP_PORT_SYNC_INT, false);
+	lan937x_ptp_enable_ptp_int(dev, port, false);
+}
+
+static int lan937x_ptp_ports_init(struct ksz_device *dev)
+{
+	int port;
+	int ret;
+
+	for (port = 0; port < dev->info->port_cnt; port++) {
+		ret = lan937x_ptp_port_init(dev, port);
+		if (ret)
+			goto error_deinit;
+	}
+
+	return 0;
+
+error_deinit:
+	while (port-- > 0)
+		lan937x_ptp_port_deinit(dev, port);
+	return ret;
+}
+
+static void lan937x_ptp_ports_deinit(struct ksz_device *dev)
+{
+	int port;
+
+	for (port = 0; port < dev->info->port_cnt; port++)
+		lan937x_ptp_port_deinit(dev, port);
+}
+
+int lan937x_ptp_init(struct ksz_device *dev)
+{
+	int ret;
+
+	mutex_init(&dev->ptp_mutex);
+	spin_lock_init(&dev->ptp_shared.ptp_clock_lock);
+
+	dev->ptp_caps = (struct ptp_clock_info) {
+		.owner		= THIS_MODULE,
+		.name		= "Microchip Clock",
+		.max_adj	= MAX_DRIFT_CORR,
+		.enable		= lan937x_ptp_enable,
+		.gettime64	= lan937x_ptp_gettime,
+		.settime64	= lan937x_ptp_settime,
+		.adjfine	= lan937x_ptp_adjfine,
+		.adjtime	= lan937x_ptp_adjtime,
+		.do_aux_work	= lan937x_ptp_do_aux_work,
+		.n_alarm	= 0,
+		.n_ext_ts	= 0,
+		.n_per_out	= 0,
+		.pps		= 1
+	};
+
+	/* Start hardware counter (will overflow after 136 years) */
+	ret = lan937x_ptp_start_clock(dev);
+	if (ret)
+		return ret;
+
+	/* Register the PTP Clock */
+	dev->ptp_clock = ptp_clock_register(&dev->ptp_caps, dev->dev);
+	if (IS_ERR_OR_NULL(dev->ptp_clock)) {
+		ret = PTR_ERR(dev->ptp_clock);
+		goto error_stop_clock;
+	}
+
+	/* Init switch ports */
+	ret = lan937x_ptp_ports_init(dev);
+	if (ret)
+		goto error_unregister_clock;
+
+	/*Enable 802.1as mode */
+	ret = lan937x_ptp_8021as(dev, true);
+	if (ret)
+		goto error_ports_deinit;
+
+	return 0;
+
+error_ports_deinit:
+	lan937x_ptp_ports_deinit(dev);
+error_unregister_clock:
+	ptp_clock_unregister(dev->ptp_clock);
+error_stop_clock:
+	lan937x_ptp_stop_clock(dev);
+	return ret;
+}
+
+void lan937x_ptp_deinit(struct ksz_device *dev)
+{
+	lan937x_ptp_ports_deinit(dev);
+	lan937x_ptp_enable_mode(dev, false);
+	ptp_clock_unregister(dev->ptp_clock);
+	lan937x_ptp_stop_clock(dev);
+}
+
+/* Interrupt Service Routine for PTP
+ * It reads the 32 bit timestamp value from the register and reconstruct it to
+ * timestamp and post the complete signal
+ */
+irqreturn_t lan937x_ptp_port_interrupt(struct ksz_device *dev, int port)
+{
+	u32 addr = PORT_CTRL_ADDR(port, REG_PTP_PORT_TX_INT_STATUS__2);
+	struct ksz_port *prt = &dev->ports[port];
+	u32 tstamp_raw;
+	ktime_t tstamp;
+	u32 regaddr;
+	u16 data;
+	int ret;
+
+	ret = ksz_read16(dev, addr, &data);
+	if (ret)
+		return IRQ_NONE;
+
+	if (data & PTP_PORT_XDELAY_REQ_INT) {
+		regaddr = PORT_CTRL_ADDR(port, REG_PTP_PORT_XDELAY_TS);
+
+		ret = ksz_read32(dev, regaddr, &tstamp_raw);
+		if (ret)
+			return IRQ_NONE;
+
+		tstamp = ksz_decode_tstamp(tstamp_raw);
+
+		prt->tstamp_pdelayreq =
+			ksz_tstamp_reconstruct(&dev->ptp_shared, tstamp);
+		complete(&prt->tstamp_pdelayreq_comp);
+	}
+
+	if (data & PTP_PORT_PDELAY_RESP_INT) {
+		regaddr = PORT_CTRL_ADDR(port, REG_PTP_PORT_PDRESP_TS);
+
+		ret = ksz_read32(dev, regaddr, &tstamp_raw);
+		if (ret)
+			return IRQ_NONE;
+
+		tstamp = ksz_decode_tstamp(tstamp_raw);
+
+		prt->tstamp_pdelayrsp =
+			ksz_tstamp_reconstruct(&dev->ptp_shared, tstamp);
+		complete(&prt->tstamp_pdelayrsp_comp);
+	}
+
+	if (data & PTP_PORT_SYNC_INT) {
+		regaddr = PORT_CTRL_ADDR(port, REG_PTP_PORT_SYNC_TS);
+
+		ret = ksz_read32(dev, regaddr, &tstamp_raw);
+		if (ret)
+			return IRQ_NONE;
+
+		tstamp = ksz_decode_tstamp(tstamp_raw);
+
+		prt->tstamp_sync =
+			ksz_tstamp_reconstruct(&dev->ptp_shared, tstamp);
+		complete(&prt->tstamp_sync_comp);
+	}
+
+	//Clear the interrupts W1C
+	ret = ksz_write16(dev, addr, data);
+	if (ret)
+		return IRQ_NONE;
+
+	return IRQ_HANDLED;
+}
diff --git a/drivers/net/dsa/microchip/lan937x_ptp.h b/drivers/net/dsa/microchip/lan937x_ptp.h
new file mode 100644
index 000000000000..5e2473f4196b
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_ptp.h
@@ -0,0 +1,74 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip LAN937X PTP Implementation
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+
+#ifndef _NET_DSA_DRIVERS_LAN937X_PTP_H
+#define _NET_DSA_DRIVERS_LAN937X_PTP_H
+
+#include <linux/irqreturn.h>
+#include <linux/types.h>
+#include "ksz_common.h"
+
+#if IS_ENABLED(CONFIG_NET_DSA_MICROCHIP_LAN937X_PTP)
+
+#include <linux/ptp_clock_kernel.h>
+
+int lan937x_get_ts_info(struct dsa_switch *ds, int port,
+			struct ethtool_ts_info *ts);
+int lan937x_hwtstamp_get(struct dsa_switch *ds, int port, struct ifreq *ifr);
+int lan937x_hwtstamp_set(struct dsa_switch *ds, int port, struct ifreq *ifr);
+void lan937x_port_txtstamp(struct dsa_switch *ds, int port,
+			   struct sk_buff *skb);
+irqreturn_t lan937x_ptp_port_interrupt(struct ksz_device *dev, int port);
+int lan937x_ptp_init(struct ksz_device *dev);
+void lan937x_ptp_deinit(struct ksz_device *dev);
+int lan937x_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts);
+
+#else
+
+struct lan937x_ptp_data {
+	struct mutex lock; //dummy data
+};
+
+static inline irqreturn_t lan937x_ptp_port_interrupt(struct ksz_device *dev,
+						     int port)
+{
+	return IRQ_NONE;
+}
+
+static inline int lan937x_ptp_init(struct ksz_device *dev)
+{
+	return 0;
+}
+
+static inline void lan937x_ptp_deinit(struct ksz_device *dev)
+{
+}
+
+static inline int lan937x_get_ts_info(struct dsa_switch *ds, int port,
+				      struct ethtool_ts_info *ts)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int lan937x_hwtstamp_get(struct dsa_switch *ds, int port,
+				       struct ifreq *ifr)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int lan937x_hwtstamp_set(struct dsa_switch *ds, int port,
+				       struct ifreq *ifr)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void lan937x_port_txtstamp(struct dsa_switch *ds, int port,
+					 struct sk_buff *skb)
+{
+}
+
+#endif /* End of CONFIG_NET_DSA_MICROCHIOP_LAN937X_PTP */
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_reg.h b/drivers/net/dsa/microchip/lan937x_reg.h
new file mode 100644
index 000000000000..7edad9c5be93
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_reg.h
@@ -0,0 +1,1104 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip LAN937X switch register definitions
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#ifndef __LAN937X_REG_H
+#define __LAN937X_REG_H
+
+/* 0 - Operation */
+#define REG_CHIP_ID0__1			0x0000
+#define REG_CHIP_ID1__1			0x0001
+#define REG_CHIP_ID2__1			0x0002
+
+#define CHIP_ID_74			0x74
+#define CHIP_ID_73			0x73
+#define CHIP_ID_72			0x72
+#define CHIP_ID_71			0x71
+#define CHIP_ID_70			0x70
+
+#define REG_CHIP_ID3__1			0x0003
+
+#define REG_GLOBAL_CTRL_0		0x0007
+
+#define SW_PHY_REG_BLOCK		BIT(7)
+#define SW_FAST_MODE			BIT(3)
+#define SW_FAST_MODE_OVERRIDE		BIT(2)
+
+#define REG_GLOBAL_OPTIONS		0x000F
+
+#define REG_SW_INT_STATUS__4		0x0010
+#define REG_SW_INT_MASK__4		0x0014
+
+#define LUE_INT				BIT(31)
+#define TRIG_TS_INT			BIT(30)
+#define APB_TIMEOUT_INT			BIT(29)
+#define OVER_TEMP_INT			BIT(28)
+#define HSR_INT				BIT(27)
+#define PIO_INT				BIT(26)
+#define POR_READY_INT			BIT(25)
+
+#define SWITCH_INT_MASK			\
+	(LUE_INT | TRIG_TS_INT | APB_TIMEOUT_INT | OVER_TEMP_INT | HSR_INT | \
+	 PIO_INT | POR_READY_INT)
+
+#define REG_SW_PORT_INT_STATUS__4	0x0018
+#define REG_SW_PORT_INT_MASK__4		0x001C
+
+#define REG_SW_CASCADE_MODE_CTL		0x0030
+#define CASCADE_PORT_SEL		7
+
+/* 1 - Global */
+#define REG_SW_GLOBAL_SERIAL_CTRL_0	0x0100
+
+#define SW_LITTLE_ENDIAN		BIT(4)
+#define SPI_AUTO_EDGE_DETECTION		BIT(1)
+#define SPI_CLOCK_OUT_RISING_EDGE	BIT(0)
+
+#define REG_SW_GLOBAL_OUTPUT_CTRL__1	0x0103
+#define SW_CLK125_ENB			BIT(1)
+#define SW_CLK25_ENB			BIT(0)
+
+#define REG_SW_GLOBAL_LED_OVR__4	0x0120
+#define LED_OVR_2			BIT(1)
+#define LED_OVR_1			BIT(0)
+
+#define REG_SW_GLOBAL_LED_SRC__4	0x0128
+#define LED_SRC_PTP_GPIO_1		BIT(3)
+#define LED_SRC_PTP_GPIO_2		BIT(2)
+
+#define REG32_SW_GLOBAL_LED_T1_SEL	0x013C
+
+/* 2 - PHY */
+#define REG_SW_POWER_MANAGEMENT_CTRL	0x0201
+
+/* 3 - Operation Control */
+#define REG_SW_OPERATION		0x0300
+
+#define SW_DOUBLE_TAG			BIT(7)
+#define SW_OVER_TEMP_ENABLE		BIT(2)
+#define SW_RESET			BIT(1)
+#define SW_START			BIT(0)
+
+#define REG_SW_LUE_CTRL_0		0x0310
+#define SW_VLAN_ENABLE			BIT(7)
+#define SW_DROP_INVALID_VID		BIT(6)
+#define SW_AGE_CNT_M			0x7
+#define SW_AGE_CNT_S			3
+#define SW_RESV_MCAST_ENABLE		BIT(2)
+
+#define REG_SW_LUE_CTRL_1		0x0311
+
+#define UNICAST_LEARN_DISABLE		BIT(7)
+#define SW_FLUSH_STP_TABLE		BIT(5)
+#define SW_FLUSH_MSTP_TABLE		BIT(4)
+#define SW_SRC_ADDR_FILTER		BIT(3)
+#define SW_AGING_ENABLE			BIT(2)
+#define SW_FAST_AGING			BIT(1)
+#define SW_LINK_AUTO_AGING		BIT(0)
+
+#define REG_SW_LUE_CTRL_2		0x0312
+
+#define SW_MID_RANGE_AGE		BIT(7)
+#define SW_LINK_DOWN_FLUSH		BIT(6)
+#define SW_EGRESS_VLAN_FILTER_DYN	BIT(5)
+#define SW_EGRESS_VLAN_FILTER_STA	BIT(4)
+#define SW_FLUSH_OPTION_M		0x3
+#define SW_FLUSH_OPTION_S		2
+#define SW_FLUSH_OPTION_DYN_MAC		1
+#define SW_FLUSH_OPTION_STA_MAC		2
+#define SW_FLUSH_OPTION_BOTH		3
+
+#define REG_SW_LUE_CTRL_3		0x0313
+#define REG_SW_AGE_PERIOD__1		0x0313
+#define SW_AGE_PERIOD_7_0_M		GENMASK( 7, 0)
+
+#define REG_SW_LUE_INT_STATUS__1	0x0314
+#define REG_SW_LUE_INT_MASK__1		0x0315
+
+#define LEARN_FAIL_INT			BIT(2)
+#define WRITE_FAIL_INT			BIT(0)
+
+#define LUE_INT_MASK			(LEARN_FAIL_INT | WRITE_FAIL_INT)
+
+#define REG_SW_LUE_INDEX_0__2		0x0316
+
+#define ENTRY_INDEX_M			0x0FFF
+
+#define REG_SW_LUE_INDEX_1__2		0x0318
+
+#define FAIL_INDEX_M			0x03FF
+
+#define REG_SW_LUE_INDEX_2__2		0x031A
+
+#define REG_SW_STATIC_AVAIL_ENTRY__4	0x031C
+
+#define SW_INGRESS_FILTERING_NO_LEARN	BIT(15)
+#define SW_STATIC_AVAIL_CNT		0x1FF
+
+#define REG_SW_AGE_PERIOD__2		0x0320
+#define SW_AGE_PERIOD_M			0xFFF
+#define SW_AGE_PERIOD_19_8_M		GENMASK( 19, 8)
+
+#define REG_SW_LUE_UNK_UCAST_CTRL__2	0x0322
+#define REG_SW_LUE_UNK_CTRL_0__4	0x0322
+
+#define SW_UNK_UCAST_ENABLE		BIT(15)
+#define SW_UNK_PORTS_M			0xFF
+
+#define REG_SW_LUE_UNK_MCAST_CTRL__2	0x0324
+#define SW_UNK_MCAST_ENABLE		BIT(15)
+
+#define REG_SW_LUE_UNK_VID_CTRL__2	0x0326
+#define SW_UNK_VID_ENABLE		BIT(15)
+
+#define SW_VLAN_FLUSH_PORTS_M		0xFF
+
+#define REG_SW_STATIC_ENTRY_LIMIT__4	0x032C
+
+#define REG_SW_MAC_CTRL_0		0x0330
+#define SW_NEW_BACKOFF			BIT(7)
+#define SW_PAUSE_UNH_MODE		BIT(1)
+#define SW_AGGR_BACKOFF			BIT(0)
+
+#define REG_SW_MAC_CTRL_1		0x0331
+#define SW_SHORT_IFG			BIT(7)
+#define MULTICAST_STORM_DISABLE		BIT(6)
+#define SW_BACK_PRESSURE		BIT(5)
+#define FAIR_FLOW_CTRL			BIT(4)
+#define NO_EXC_COLLISION_DROP		BIT(3)
+#define SW_LEGAL_PACKET_DISABLE		BIT(1)
+#define SW_PASS_SHORT_FRAME		BIT(0)
+
+#define REG_SW_MAC_CTRL_2		0x0332
+#define SW_REPLACE_VID			BIT(3)
+#define BROADCAST_STORM_RATE_HI		0x07
+
+#define REG_SW_MAC_CTRL_3		0x0333
+#define BROADCAST_STORM_RATE_LO		0xFF
+#define BR_STORM_RATE			0x07FF
+
+#define REG_SW_MAC_CTRL_4		0x0334
+#define SW_PASS_PAUSE			BIT(3)
+
+#define REG_SW_MAC_CTRL_5		0x0335
+#define SW_OUT_RATE_LIMIT_QUEUE_BASED	BIT(3)
+
+#define REG_SW_MAC_CTRL_6		0x0336
+#define SW_MIB_COUNTER_FLUSH		BIT(7)
+#define SW_MIB_COUNTER_FREEZE		BIT(6)
+
+#define REG_SW_MRI_CTRL_0		0x0370
+#define SW_IGMP_SNOOP			BIT(6)
+#define SW_IPV6_MLD_OPTION		BIT(3)
+#define SW_IPV6_MLD_SNOOP		BIT(2)
+#define SW_MIRROR_RX_TX			BIT(0)
+
+#define REG_SW_MRI_CTRL_1__4		0x0374
+#define REG_SW_MRI_CTRL_2__4		0x0378
+#define REG_SW_CLASS_D_IP_CTRL__4	0x0374
+
+#define SW_CLASS_D_IP_ENABLE		BIT(31)
+
+#define REG_SW_MRI_CTRL_8		0x0378
+#define SW_RED_COLOR_S			4
+#define SW_YELLOW_COLOR_S		2
+#define SW_GREEN_COLOR_S		0
+#define SW_COLOR_M			0x3
+
+#define REG_PTP_EVENT_PRIO_CTRL		0x037C
+#define REG_PTP_GENERAL_PRIO_CTRL	0x037D
+#define PTP_PRIO_ENABLE			BIT(7)
+
+#define REG_SW_QM_CTRL__4		0x0390
+#define PRIO_SCHEME_SELECT_M		KS_PRIO_M
+#define PRIO_SCHEME_SELECT_S		6
+#define PRIO_MAP_3_HI			0
+#define PRIO_MAP_2_HI			2
+#define PRIO_MAP_0_LO			3
+#define UNICAST_VLAN_BOUNDARY		BIT(1)
+
+#define REG_SW_EEE_QM_CTRL__2		0x03C0
+#define REG_SW_EEE_TXQ_WAIT_TIME__2	0x03C2
+
+/* 4 - */
+#define REG_SW_VLAN_ENTRY__4		0x0400
+#define VLAN_VALID			BIT(31)
+#define VLAN_FORWARD_OPTION		BIT(27)
+#define VLAN_PRIO_M			KS_PRIO_M
+#define VLAN_PRIO_S			24
+#define VLAN_MSTP_M			0x7
+#define VLAN_MSTP_S			12
+#define VLAN_FID_M			0x7F
+
+#define REG_SW_VLAN_ENTRY_UNTAG__4	0x0404
+#define REG_SW_VLAN_ENTRY_PORTS__4	0x0408
+#define REG_SW_VLAN_ENTRY_INDEX__2	0x040C
+
+#define VLAN_INDEX_M			0x0FFF
+
+#define REG_SW_VLAN_CTRL		0x040E
+#define VLAN_START			BIT(7)
+#define VLAN_ACTION			0x3
+#define VLAN_WRITE			1
+#define VLAN_READ			2
+#define VLAN_CLEAR			3
+
+#define REG_SW_ALU_INDEX_0		0x0410
+#define ALU_FID_INDEX_S			16
+#define ALU_FID_SIZE			127
+#define ALU_MAC_ADDR_HI			0xFFFF
+
+#define REG_SW_ALU_INDEX_1		0x0414
+#define ALU_DIRECT_INDEX_M		(BIT(12) - 1)
+
+#define REG_SW_ALU_CTRL__4		0x0418
+#define REG_SW_ALU_CTRL(num)	(REG_SW_ALU_CTRL__4 + ((num) * 4))
+
+#define ALU_STA_DYN_CNT			2
+#define ALU_VALID_CNT_M			(BIT(14) - 1)
+#define ALU_VALID_CNT_S			16
+#define ALU_START			BIT(7)
+#define ALU_VALID			BIT(6)
+#define ALU_VALID_OR_STOP		BIT(5)
+#define ALU_DIRECT			BIT(2)
+#define ALU_ACTION			0x3
+#define ALU_WRITE			1
+#define ALU_READ			2
+#define ALU_SEARCH			3
+
+#define REG_SW_ALU_STAT_CTRL__4		0x041C
+#define ALU_STAT_VALID_CNT_M		(BIT(9) - 1)
+#define ALU_STAT_VALID_CNT_S		20
+#define ALU_STAT_INDEX_M		(BIT(8) - 1)
+#define ALU_STAT_INDEX_S		8
+#define ALU_RESV_MCAST_INDEX_M		(BIT(6) - 1)
+#define ALU_STAT_START			BIT(7)
+#define ALU_STAT_VALID			BIT(6)
+#define ALU_STAT_VALID_OR_STOP		BIT(5)
+#define ALU_STAT_USE_FID		BIT(4)
+#define ALU_STAT_DIRECT			BIT(3)
+#define ALU_RESV_MCAST_ADDR		BIT(2)
+#define ALU_STAT_ACTION			0x3
+#define ALU_STAT_WRITE			1
+#define ALU_STAT_READ			2
+#define ALU_STAT_SEARCH			3
+
+#define REG_SW_ALU_VAL_A		0x0420
+#define ALU_V_STATIC_VALID		BIT(31)
+#define ALU_V_SRC_FILTER		BIT(30)
+#define ALU_V_DST_FILTER		BIT(29)
+#define ALU_V_PRIO_AGE_CNT_M		(BIT(3) - 1)
+#define ALU_V_PRIO_AGE_CNT_S		26
+#define ALU_V_MSTP_M			0x7
+
+#define REG_SW_ALU_VAL_B		0x0424
+#define ALU_V_OVERRIDE			BIT(31)
+#define ALU_V_USE_FID			BIT(30)
+#define ALU_V_PORT_MAP			0xFF
+
+#define REG_SW_ALU_VAL_C		0x0428
+#define ALU_V_FID_M			(BIT(16) - 1)
+#define ALU_V_FID_S			16
+#define ALU_V_MAC_ADDR_HI		0xFFFF
+
+#define REG_SW_ALU_VAL_D		0x042C
+
+#define PORT_CTRL_ADDR(port, addr)	((addr) | (((port) + 1)  << 12))
+
+#define REG_GLOBAL_RR_INDEX__1		0x0600
+
+/* VPHY */
+#define REG_VPHY_CTRL__2		0x0700
+#define REG_VPHY_STAT__2		0x0704
+#define REG_VPHY_ID_HI__2		0x0708
+#define REG_VPHY_ID_LO__2		0x070C
+#define REG_VPHY_AUTO_NEG__2		0x0710
+#define REG_VPHY_REMOTE_CAP__2		0x0714
+
+#define REG_VPHY_EXPANSION__2		0x0718
+
+#define REG_VPHY_M_CTRL__2		0x0724
+#define REG_VPHY_M_STAT__2		0x0728
+
+#define REG_VPHY_EXT_STAT__2		0x073C
+#define VPHY_EXT_1000_X_FULL		BIT(15)
+#define VPHY_EXT_1000_X_HALF		BIT(14)
+#define VPHY_EXT_1000_T_FULL		BIT(13)
+#define VPHY_EXT_1000_T_HALF		BIT(12)
+
+#define REG_VPHY_DEVAD_0__2		0x0740
+#define REG_VPHY_DEVAD_1__2		0x0744
+#define REG_VPHY_DEVAD_2__2		0x0748
+#define REG_VPHY_DEVAD_3__2		0x074C
+
+#define VPHY_DEVAD_UPDATE		BIT(7)
+#define VPHY_DEVAD_M			0x1F
+#define VPHY_DEVAD_S			8
+
+#define REG_VPHY_SMI_ADDR__2		0x0750
+#define REG_VPHY_SMI_DATA_LO__2		0x0754
+#define REG_VPHY_SMI_DATA_HI__2		0x0758
+
+#define REG_VPHY_IND_ADDR__2		0x075C
+#define REG_VPHY_IND_DATA__2		0x0760
+#define REG_VPHY_IND_CTRL__2		0x0768
+
+#define VPHY_IND_WRITE			BIT(1)
+#define VPHY_IND_BUSY			BIT(0)
+
+#define REG_VPHY_SPECIAL_CTRL__2	0x077C
+#define VPHY_SMI_INDIRECT_ENABLE	BIT(15)
+#define VPHY_SW_LOOPBACK		BIT(14)
+#define VPHY_MDIO_INTERNAL_ENABLE	BIT(13)
+#define VPHY_SPI_INDIRECT_ENABLE	BIT(12)
+#define VPHY_PORT_MODE_M		0x3
+#define VPHY_PORT_MODE_S		8
+#define VPHY_MODE_RGMII			0
+#define VPHY_MODE_MII_PHY		1
+#define VPHY_MODE_SGMII			2
+#define VPHY_MODE_RMII_PHY		3
+#define VPHY_SW_COLLISION_TEST		BIT(7)
+#define VPHY_SPEED_DUPLEX_STAT_M	0x7
+#define VPHY_SPEED_DUPLEX_STAT_S	2
+#define VPHY_SPEED_1000			BIT(4)
+#define VPHY_SPEED_100			BIT(3)
+#define VPHY_FULL_DUPLEX		BIT(2)
+
+/* 0 - Operation */
+#define REG_PORT_DEFAULT_VID		0x0000
+
+#define REG_PORT_CUSTOM_VID		0x0002
+#define REG_PORT_PME_STATUS		0x0013
+
+#define REG_PORT_PME_CTRL		0x0017
+#define PME_WOL_MAGICPKT		BIT(2)
+#define PME_WOL_LINKUP			BIT(1)
+#define PME_WOL_ENERGY			BIT(0)
+
+#define REG_PORT_INT_STATUS		0x001B
+#define REG_PORT_INT_MASK		0x001F
+
+#define PORT_TAS_INT			BIT(5)
+#define PORT_QCI_INT			BIT(4)
+#define PORT_SGMII_INT			BIT(3)
+#define PORT_PTP_INT			BIT(2)
+#define PORT_PHY_INT			BIT(1)
+#define PORT_ACL_INT			BIT(0)
+
+#define PORT_INT_MASK			\
+	(				\
+	PORT_TAS_INT |			\
+	PORT_SGMII_INT | PORT_PTP_INT | PORT_PHY_INT | PORT_ACL_INT)
+
+#define REG_PORT_CTRL_0			0x0020
+
+#define PORT_MAC_LOOPBACK		BIT(7)
+#define PORT_MAC_REMOTE_LOOPBACK	BIT(6)
+#define PORT_K2L_INSERT_ENABLE		BIT(5)
+#define PORT_K2L_DEBUG_ENABLE		BIT(4)
+#define PORT_TAIL_TAG_ENABLE		BIT(2)
+#define PORT_QUEUE_SPLIT_ENABLE		0x3
+
+#define REG_PORT_CTRL_1			0x0021
+#define PORT_SRP_ENABLE			0x3
+
+#define REG_PORT_STATUS_0		0x0030
+#define PORT_INTF_SPEED_M		0x3
+#define PORT_INTF_SPEED_S		3
+#define PORT_INTF_FULL_DUPLEX		BIT(2)
+
+#define REG_PORT_STATUS_1		0x0034
+
+/* 1 - PHY */
+#define REG_VPHY_SMI_ADDR		0x14
+#define REG_VPHY_SMI_DATA_LO		0x15
+#define REG_VPHY_SMI_DATA_HI		0x16
+
+#define REG_VPHY_SPECIAL_CTRL_STAT	0x1F
+
+#define REG_PORT_T1_PHY_CTRL_BASE	0x0100
+#define REG_PORT_TX_PHY_CTRL_BASE	0x0280
+#define REG_TX_PHY_CTRL_BASE		0x0980
+
+#define REG_PORT_PHY_1000_CTRL		0x0112
+#define PORT_AUTO_NEG_MANUAL		BIT(12)
+#define PORT_AUTO_NEG_M			BIT(11)
+#define PORT_AUTO_NEG_M_PREFERRED	BIT(10)
+#define PORT_AUTO_NEG_1000BT_FD		BIT(9)
+#define PORT_AUTO_NEG_1000BT		BIT(8)
+
+#define REG_PORT_PHY_1000_STATUS	0x0114
+
+#define REG_PORT_PHY_RXER_COUNTER	0x012A
+#define REG_PORT_PHY_INT_ENABLE		0x0136
+#define REG_PORT_PHY_INT_STATUS		0x0137
+
+/* Same as PORT_PHY_LOOPBACK */
+#define PORT_PHY_PCS_LOOPBACK		BIT(0)
+
+#define REG_PORT_PHY_DIGITAL_DEBUG_2	0x013A
+
+#define REG_PORT_PHY_DIGITAL_DEBUG_3	0x013C
+#define PORT_100BT_FIXED_LATENCY	BIT(15)
+
+#define REG_PORT_PHY_PHY_CTRL		0x013E
+#define PORT_INT_PIN_HIGH		BIT(14)
+#define PORT_ENABLE_JABBER		BIT(9)
+#define PORT_STAT_SPEED_1000MBIT	BIT(6)
+#define PORT_STAT_SPEED_100MBIT		BIT(5)
+#define PORT_STAT_SPEED_10MBIT		BIT(4)
+#define PORT_STAT_FULL_DUPLEX		BIT(3)
+
+/* Same as PORT_PHY_STAT_M */
+#define PORT_STAT_M		BIT(2)
+#define PORT_RESET			BIT(1)
+#define PORT_LINK_STATUS_FAIL		BIT(0)
+
+/* 3 - xMII */
+#define REG_PORT_XMII_CTRL_0		0x0300
+#define PORT_SGMII_SEL			BIT(7)
+#define PORT_MII_FULL_DUPLEX		BIT(6)
+#define PORT_MII_TX_FLOW_CTRL		BIT(5)
+#define PORT_MII_100MBIT		BIT(4)
+#define PORT_MII_RX_FLOW_CTRL		BIT(3)
+#define PORT_GRXC_ENABLE		BIT(0)
+
+#define REG_PORT_XMII_CTRL_1		0x0301
+#define PORT_MII_NOT_1GBIT		BIT(6)
+#define PORT_MII_SEL_EDGE		BIT(5)
+#define PORT_RGMII_ID_IG_ENABLE		BIT(4)
+#define PORT_RGMII_ID_EG_ENABLE		BIT(3)
+#define PORT_MII_MAC_MODE		BIT(2)
+#define PORT_MII_SEL_M			0x3
+#define PORT_RGMII_SEL			0x0
+#define PORT_RMII_SEL			0x1
+#define PORT_MII_SEL			0x2
+
+#define REG_PORT_XMII_CTRL_2		0x0302
+#define PORT_RGMII_RX_STS_ENABLE	BIT(0)
+
+#define REG_PORT_XMII_CTRL_3		0x0303
+#define PORT_DUPLEX_STATUS_FULL		BIT(3)
+
+#define REG_PORT_XMII_CTRL_4		0x0304
+#define PORT_TX_TUNE_ADJ		0x3F80
+
+#define REG_PORT_XMII_CTRL_5		0x0306
+#define PORT_DLL_RESET			BIT(15)
+#define PORT_TUNE_ADJ			0x3F80
+
+/* 4 - MAC */
+#define REG_PORT_MAC_CTRL_0		0x0400
+#define PORT_CHECK_LENGTH		BIT(2)
+#define PORT_BROADCAST_STORM		BIT(1)
+#define PORT_JUMBO_PACKET		BIT(0)
+
+#define REG_PORT_MAC_CTRL_1		0x0401
+#define PORT_BACK_PRESSURE		BIT(3)
+#define PORT_PASS_ALL			BIT(0)
+
+#define REG_PORT_MAC_CTRL_2		0x0402
+#define PORT_100BT_EEE_DISABLE		BIT(7)
+#define PORT_1000BT_EEE_DISABLE		BIT(6)
+
+#define REG_PORT_MAC_IN_RATE_LIMIT	0x0403
+#define PORT_RATE_LIMIT			BIT(6)
+
+#define REG_PORT_MTU__2			0x0404
+#define PORT_RATE_LIMIT_M		(BIT(7) - 1)
+
+#define REG_PORT_PRI0_IN_RLIMIT_CTL	0x0410
+#define REG_PORT_PRI7_IN_RLIMIT_CTL	0x0417
+
+#define RLIMIT_REG_CODE_256KBPS		104
+#define RLIMIT_REG_CODE_1MBPS		1
+#define RLIMIT_REG_CODE_1280KBPS	102
+#define RLIMIT_REG_CODE_1920KBPS	103
+
+/* 5 - MIB Counters */
+#define REG_PORT_MIB_CTRL_STAT		0x0500
+#define MIB_COUNTER_OVERFLOW		BIT(31)
+#define MIB_COUNTER_VALID		BIT(30)
+#define MIB_COUNTER_READ		BIT(25)
+#define MIB_COUNTER_FLUSH_FREEZE	BIT(24)
+#define MIB_COUNTER_INDEX_M		(BIT(8) - 1)
+#define MIB_COUNTER_INDEX_S		16
+#define MIB_COUNTER_DATA_HI_M		0xF
+
+#define REG_PORT_MIB_DATA		0x0504
+
+/* 8 - Classification and Policing */
+#define REG_PORT_MRI_MIRROR_CTRL	0x0800
+#define PORT_MIRROR_RX			BIT(6)
+#define PORT_MIRROR_TX			BIT(5)
+#define PORT_MIRROR_SNIFFER		BIT(1)
+
+#define REG_PORT_MRI_PRIO_CTRL		0x0801
+#define PORT_HIGHEST_PRIO		BIT(7)
+#define PORT_OR_PRIO			BIT(6)
+#define PORT_MAC_PRIO_ENABLE		BIT(4)
+#define PORT_VLAN_PRIO_ENABLE		BIT(3)
+#define PORT_802_1P_PRIO_ENABLE		BIT(2)
+#define PORT_DIFFSERV_PRIO_ENABLE	BIT(1)
+#define PORT_ACL_PRIO_ENABLE		BIT(0)
+
+#define REG_PORT_MRI_MAC_CTRL		0x0802
+#define PORT_USER_PRIO_CEILING		BIT(7)
+#define PORT_DROP_NON_VLAN		BIT(4)
+#define PORT_DROP_TAG			BIT(3)
+#define PORT_BASED_PRIO_M		KS_PRIO_M
+#define PORT_BASED_PRIO_S		0
+
+#define REG_PORT_MRI_TC_MAP__4		0x0808
+
+/* 9 - Shaping */
+#define REG_PORT_MTI_QUEUE_INDEX__4	0x0900
+
+#define REG_PORT_MTI_QUEUE_CTRL_0__4	0x0904
+#define MTI_PVID_REPLACE		BIT(0)
+
+#define REG_PORT_MTI_QUEUE_CTRL_0	0x0914
+
+#define MTI_SCHEDULE_MODE_M		0x3
+#define MTI_SCHEDULE_MODE_S		6
+#define MTI_SCHEDULE_STRICT_PRIO	0
+#define MTI_SCHEDULE_WRR		2
+#define MTI_SHAPING_M			0x3
+#define MTI_SHAPING_S			4
+#define MTI_SHAPING_OFF			0
+#define MTI_SHAPING_SRP			1
+#define MTI_SHAPING_TIME_AWARE		2
+
+#define REG_PORT_MTI_QUEUE_CTRL_1	0x0915
+
+#define MTI_TX_RATIO_M			(BIT(7) - 1)
+
+#define REG_PORT_MTI_QUEUE_CTRL_2__2	0x0916
+#define REG_PORT_MTI_HI_WATER_MARK	0x0916
+#define REG_PORT_MTI_QUEUE_CTRL_3__2	0x0918
+#define REG_PORT_MTI_LO_WATER_MARK	0x0918
+#define REG_PORT_MTI_QUEUE_CTRL_4__2	0x091A
+#define REG_PORT_MTI_CREDIT_INCREMENTA0	0x091A
+#define REG_PORT_MTI_CREDIT_INCREMENT	0x091C
+#define REG_PORT_TAS_CTL__1		0x0920
+
+#define TAS_CUT_THROUGH			BIT(7)
+
+#define REG_PORT_TAS_EVENT_INDEX__1	0x0923
+
+#define REG_PORT_TAS_EVENT__4		0x0924
+
+#define TAS_GATE_CMD_S			24
+#define TAS_GATE_CYCLE_M		((1 << TAS_GATE_CMD_S) - 1)
+
+#define REG_PORT_TAS_TRIG_NSEC__4	0x0928
+#define REG_PORT_TAS_TRIG_SEC__4	0x092C
+#define REG_PORT_TAS_CYCLE_TIME__4	0x0930
+
+#define REG_PORT_TAS_GCL_LAST_INDEX__2	0x0934
+
+#define REG_PORT_TAS_GATE_CTRL__1	0x0936
+
+#define TAS_CFG_CHANGE			BIT(7)
+#define TAS_GATE_ENABLE			BIT(6)
+#define TAS_OPER_GCL_READ		BIT(5)
+
+/* A - QM */
+#define REG_PORT_QM_CTRL__4		0x0A00
+#define PORT_QM_DROP_PRIO_M		0x3
+
+#define REG_PORT_VLAN_MEMBERSHIP__4	0x0A04
+
+#define REG_PORT_QM_QUEUE_INDEX__4	0x0A08
+#define PORT_QM_QUEUE_INDEX_S		24
+#define PORT_QM_BURST_SIZE_S		16
+#define PORT_QM_MIN_RESV_SPACE_M	(BIT(11) - 1)
+
+#define REG_PORT_QM_WATER_MARK__4	0x0A0C
+#define PORT_QM_HI_WATER_MARK_S		16
+#define PORT_QM_LO_WATER_MARK_S		0
+#define PORT_QM_WATER_MARK_M		(BIT(11) - 1)
+
+#define REG_PORT_QM_TX_CNT_0__4		0x0A10
+#define PORT_QM_TX_CNT_USED_S		0
+#define PORT_QM_TX_CNT_M		(BIT(11) - 1)
+
+#define REG_PORT_QM_TX_CNT_1__4		0x0A14
+#define PORT_QM_TX_CNT_CALCULATED_S	16
+#define PORT_QM_TX_CNT_AVAIL_S		0
+
+/* B - LUE */
+#define REG_PORT_LUE_CTRL		0x0B00
+
+#define PORT_VLAN_LOOKUP_VID_0		BIT(7)
+#define PORT_INGRESS_FILTER		BIT(6)
+#define PORT_DISCARD_NON_VID		BIT(5)
+#define PORT_MAC_BASED_802_1X		BIT(4)
+#define PORT_SRC_ADDR_FILTER		BIT(3)
+
+#define REG_PORT_LUE_MSTP_INDEX		0x0B01
+
+#define REG_PORT_LUE_MSTP_STATE		0x0B04
+
+#define PORT_TX_ENABLE			BIT(2)
+#define PORT_RX_ENABLE			BIT(1)
+#define PORT_LEARN_DISABLE		BIT(0)
+
+#define REG_PORT_LUE_LEARN_CNT__2	0x0B08
+
+#define REG_PORT_LUE_UNK_CTL0		0x0B0E
+#define REG_PORT_LUE_UNK_CTL1		0x0B10
+#define REG_PORT_LUE_UNK_VID_CTRL__2	0x0B12
+
+#define PORT_UNK_UCAST_MCAST_ENABLE	BIT(15)
+#define PORT_UCAST_MCAST_MASK		0xFF
+#define PORT_UNK_VID_ENABLE		BIT(15)
+
+#define PRIO_QUEUES			8
+#define RX_PRIO_QUEUES			8
+#define KS_PRIO_IN_REG			2
+#define TOTAL_PORT_NUM			8
+
+#define LAN937X_COUNTER_NUM		0x20
+#define TOTAL_LAN937X_COUNTER_NUM	(LAN937X_COUNTER_NUM + 2 + 2)
+
+#define SWITCH_COUNTER_NUM		LAN937X_COUNTER_NUM
+
+#define P_BCAST_STORM_CTRL		REG_PORT_MAC_CTRL_0
+#define P_PRIO_CTRL			REG_PORT_MRI_PRIO_CTRL
+#define P_MIRROR_CTRL			REG_PORT_MRI_MIRROR_CTRL
+#define P_STP_CTRL			REG_PORT_LUE_MSTP_STATE
+#define P_PHY_CTRL			REG_PORT_PHY_CTRL
+#define P_NEG_RESTART_CTRL		REG_PORT_PHY_CTRL
+#define P_LINK_STATUS			REG_PORT_PHY_STATUS
+#define P_SPEED_STATUS			REG_PORT_PHY_PHY_CTRL
+#define P_RATE_LIMIT_CTRL		REG_PORT_MAC_IN_RATE_LIMIT
+
+#define S_LINK_AGING_CTRL		REG_SW_LUE_CTRL_1
+#define S_MIRROR_CTRL			REG_SW_MRI_CTRL_0
+#define S_REPLACE_VID_CTRL		REG_SW_MAC_CTRL_2
+#define S_802_1P_PRIO_CTRL		REG_SW_MAC_802_1P_MAP_0
+#define S_TOS_PRIO_CTRL			REG_SW_MAC_TOS_PRIO_0
+#define S_FLUSH_TABLE_CTRL		REG_SW_LUE_CTRL_1
+
+#define REG_SWITCH_RESET		REG_RESET_CTRL
+
+#define SW_FLUSH_DYN_MAC_TABLE		SW_FLUSH_MSTP_TABLE
+
+#define MAX_TIMESTAMP_UNIT		2
+#define MAX_TRIG_UNIT			3
+#define MAX_TIMESTAMP_EVENT_UNIT	8
+#define MAX_GPIO			2
+#define MAX_CLOCK			2
+
+#define PTP_TRIG_UNIT_M			(BIT(MAX_TRIG_UNIT) - 1)
+#define PTP_TS_UNIT_M			(BIT(MAX_TIMESTAMP_UNIT) - 1)
+
+#define TAIL_TAG_PTP			BIT(7)
+#define TAIL_TAG_NEXT_CHIP		BIT(6)
+#define TAIL_TAG_K2L			BIT(5)
+#define TAIL_TAG_PTP_1_STEP		BIT(4)
+#define TAIL_TAG_PTP_P2P		BIT(3)
+#define TAIL_TAG_RX_PORTS_M		0x7
+
+/* 148,800 frames * 67 ms / 100 */
+#define BR_STORM_VALUE			9969
+
+#define SW_CHECK_LENGTH			BIT(3)
+
+#define FR_MIN_SIZE		1522
+#define FR_MAX_SIZE		9000
+
+#define PORT_JUMBO_EN			BIT(0)
+#define PORT_FR_CHK_LENGTH		BIT(2)
+#define PORT_MAX_FR_SIZE		0x404
+
+#define FR_SIZE_CPU_PORT		1540
+
+#define REG_PORT_CTRL_0			0x0020
+#define PORT_FULL_DUPLEX		BIT(6)
+#define PORT_TX_FLOW_CTRL		BIT(5)
+#define PORT_RX_FLOW_CTRL		BIT(3)
+#define PORT_MAC_SPEED_100		BIT(4)
+
+#define PORT_QUEUE_SPLIT_ENABLE		0x3
+
+/* Get fid from vid, fid 0 is not used if vid is greater than 127 */
+#define LAN937X_GET_FID(vid)	(((vid) % ALU_FID_SIZE) + 1)
+
+/* Driver set switch broadcast storm protection at 10% rate */
+#define BR_STORM_PROT_RATE	10
+
+#define MII_BMSR_100BASE_TX_FD		BIT(14)
+
+#define PHY_LINK_UP				1
+#define PHY_LINK_DOWN				0
+
+/* The port number as per the datasheet */
+#define RGMII_2_PORT_NUM		5
+#define RGMII_1_PORT_NUM		6
+#define SGMII_PORT_NUM			4
+#define TXPHY_PORT_NUM			4
+
+#define GET_CHIP_ID_LSB(chip_id)	(((chip_id) >> 8) & 0xff)
+#define LAN937X_RGMII_2_PORT		(RGMII_2_PORT_NUM - 1)
+#define LAN937X_RGMII_1_PORT		(RGMII_1_PORT_NUM - 1)
+#define LAN937X_SGMII_PORT		(SGMII_PORT_NUM - 1)
+#define LAN937X_TXPHY_PORT		(TXPHY_PORT_NUM - 1)
+#define LAN937X_TAG_LEN			2
+#define LAN937X_CASCADE_TAG_LEN		3
+
+/* 5 - PTP Clock */
+#define REG_PTP_CLK_CTRL		0x0500
+
+#define PTP_STEP_ADJ			BIT(6)
+#define PTP_STEP_DIR			BIT(5)
+#define PTP_READ_TIME			BIT(4)
+#define PTP_LOAD_TIME			BIT(3)
+#define PTP_CLK_ADJ_ENABLE		BIT(2)
+#define PTP_CLK_ENABLE			BIT(1)
+#define PTP_CLK_RESET			BIT(0)
+
+#define REG_PTP_RTC_SUB_NANOSEC__2	0x0502
+
+#define PTP_RTC_SUB_NANOSEC_M		0x0007
+
+#define REG_PTP_RTC_NANOSEC		0x0504
+#define REG_PTP_RTC_NANOSEC_H		0x0504
+#define REG_PTP_RTC_NANOSEC_L		0x0506
+
+#define REG_PTP_RTC_SEC			0x0508
+#define REG_PTP_RTC_SEC_H		0x0508
+#define REG_PTP_RTC_SEC_L		0x050A
+
+#define REG_PTP_SUBNANOSEC_RATE		0x050C
+#define REG_PTP_SUBNANOSEC_RATE_H	0x050C
+
+#define PTP_RATE_DIR			BIT(31)
+#define PTP_TMP_RATE_ENABLE		BIT(30)
+
+#define REG_PTP_SUBNANOSEC_RATE_L	0x050E
+
+#define REG_PTP_RATE_DURATION		0x0510
+#define REG_PTP_RATE_DURATION_H		0x0510
+#define REG_PTP_RATE_DURATION_L		0x0512
+
+#define REG_PTP_MSG_CONF1		0x0514
+
+#define PTP_802_1AS			BIT(7)
+#define PTP_ENABLE			BIT(6)
+#define PTP_ETH_ENABLE			BIT(5)
+#define PTP_IPV4_UDP_ENABLE		BIT(4)
+#define PTP_IPV6_UDP_ENABLE		BIT(3)
+#define PTP_TC_P2P			BIT(2)
+#define PTP_MASTER			BIT(1)
+#define PTP_1STEP			BIT(0)
+
+#define REG_PTP_MSG_CONF2		0x0516
+
+#define PTP_UNICAST_ENABLE		BIT(12)
+#define PTP_ALTERNATE_MASTER		BIT(11)
+#define PTP_ALL_HIGH_PRIO		BIT(10)
+#define PTP_SYNC_CHECK			BIT(9)
+#define PTP_DELAY_CHECK			BIT(8)
+#define PTP_PDELAY_CHECK		BIT(7)
+#define PTP_DROP_SYNC_DELAY_REQ		BIT(5)
+#define PTP_DOMAIN_CHECK		BIT(4)
+#define PTP_UDP_CHECKSUM		BIT(2)
+
+#define REG_PTP_DOMAIN_VERSION		0x0518
+#define PTP_VERSION_M			0xFF00
+#define PTP_DOMAIN_M			0x00FF
+
+#define REG_PTP_UNIT_INDEX__4		0x0520
+
+#define PTP_UNIT_M			0xF
+
+#define PTP_GPIO_INDEX_S		16
+#define PTP_TSI_INDEX_S			8
+#define PTP_TOU_INDEX_S			0
+
+#define REG_PTP_TRIG_STATUS__4		0x0524
+
+#define TRIG_ERROR_S			16
+#define TRIG_DONE_S			0
+
+#define REG_PTP_INT_STATUS__4		0x0528
+
+#define TRIG_INT_S			16
+#define TS_INT_S			0
+
+#define TRIG_UNIT_M			0x7
+#define TS_UNIT_M			0x3
+
+#define REG_PTP_CTRL_STAT__4		0x052C
+
+#define GPIO_IN				BIT(7)
+#define GPIO_OUT			BIT(6)
+#define TS_INT_ENABLE			BIT(5)
+#define TRIG_ACTIVE			BIT(4)
+#define TRIG_ENABLE			BIT(3)
+#define TRIG_RESET			BIT(2)
+#define TS_ENABLE			BIT(1)
+#define TS_RESET			BIT(0)
+
+#define GPIO_CTRL_M			(GPIO_IN | GPIO_OUT)
+
+#define TRIG_CTRL_M			\
+	(TRIG_ACTIVE | TRIG_ENABLE | TRIG_RESET)
+
+#define TS_CTRL_M			\
+	(TS_INT_ENABLE | TS_ENABLE | TS_RESET)
+
+#define REG_TRIG_TARGET_NANOSEC		0x0530
+#define REG_TRIG_TARGET_SEC		0x0534
+
+#define REG_TRIG_CTRL__4		0x0538
+
+#define TRIG_CASCADE_ENABLE		BIT(31)
+#define TRIG_CASCADE_TAIL		BIT(30)
+#define TRIG_CASCADE_UPS_M		0xF
+#define TRIG_CASCADE_UPS_S		26
+#define TRIG_NOW			BIT(25)
+#define TRIG_NOTIFY			BIT(24)
+#define TRIG_EDGE			BIT(23)
+#define TRIG_PATTERN_S			20
+#define TRIG_PATTERN_M			0x7
+#define TRIG_NEG_EDGE			0
+#define TRIG_POS_EDGE			1
+#define TRIG_NEG_PULSE			2
+#define TRIG_POS_PULSE			3
+#define TRIG_NEG_PERIOD			4
+#define TRIG_POS_PERIOD			5
+#define TRIG_REG_OUTPUT			6
+#define TRIG_GPO_S			16
+#define TRIG_GPO_M			0xF
+#define TRIG_CASCADE_ITERATE_CNT_M	0xFFFF
+
+#define REG_TRIG_CYCLE_WIDTH		0x053C
+
+#define REG_TRIG_CYCLE_CNT		0x0540
+
+#define TRIG_CYCLE_CNT_M		0xFFFF
+#define TRIG_CYCLE_CNT_S		16
+#define TRIG_BIT_PATTERN_M		0xFFFF
+
+#define REG_TRIG_ITERATE_TIME		0x0544
+
+#define REG_TRIG_PULSE_WIDTH__4		0x0548
+
+#define TRIG_PULSE_WIDTH_M		0x00FFFFFF
+
+#define REG_TS_CTRL_STAT__4		0x0550
+
+#define TS_EVENT_DETECT_M		0xF
+#define TS_EVENT_DETECT_S		17
+#define TS_EVENT_OVERFLOW		BIT(16)
+#define TS_GPI_M			0xF
+#define TS_GPI_S			8
+#define TS_DETECT_RISE			BIT(7)
+#define TS_DETECT_FALL			BIT(6)
+#define TS_DETECT_S			6
+#define TS_CASCADE_TAIL			BIT(5)
+#define TS_CASCADE_UPS_M		0xF
+#define TS_CASCADE_UPS_S		1
+#define TS_CASCADE_ENABLE		BIT(0)
+
+#define DETECT_RISE			(TS_DETECT_RISE >> TS_DETECT_S)
+#define DETECT_FALL			(TS_DETECT_FALL >> TS_DETECT_S)
+
+#define REG_TS_EVENT_0_NANOSEC		0x0554
+#define REG_TS_EVENT_0_SEC		0x0558
+#define REG_TS_EVENT_0_SUB_NANOSEC	0x055C
+
+#define REG_TS_EVENT_1_NANOSEC		0x0560
+#define REG_TS_EVENT_1_SEC		0x0564
+#define REG_TS_EVENT_1_SUB_NANOSEC	0x0568
+
+#define REG_TS_EVENT_2_NANOSEC		0x056C
+#define REG_TS_EVENT_2_SEC		0x0570
+#define REG_TS_EVENT_2_SUB_NANOSEC	0x0574
+
+#define REG_TS_EVENT_3_NANOSEC		0x0578
+#define REG_TS_EVENT_3_SEC		0x057C
+#define REG_TS_EVENT_3_SUB_NANOSEC	0x0580
+
+#define REG_TS_EVENT_4_NANOSEC		0x0584
+#define REG_TS_EVENT_4_SEC		0x0588
+#define REG_TS_EVENT_4_SUB_NANOSEC	0x058C
+
+#define REG_TS_EVENT_5_NANOSEC		0x0590
+#define REG_TS_EVENT_5_SEC		0x0594
+#define REG_TS_EVENT_5_SUB_NANOSEC	0x0598
+
+#define REG_TS_EVENT_6_NANOSEC		0x059C
+#define REG_TS_EVENT_6_SEC		0x05A0
+#define REG_TS_EVENT_6_SUB_NANOSEC	0x05A4
+
+#define REG_TS_EVENT_7_NANOSEC		0x05A8
+#define REG_TS_EVENT_7_SEC		0x05AC
+#define REG_TS_EVENT_7_SUB_NANOSEC	0x05B0
+
+#define TS_EVENT_EDGE_M			0x1
+#define TS_EVENT_EDGE_S			30
+#define TS_EVENT_NANOSEC_M		(BIT(30) - 1)
+
+#define TS_EVENT_SUB_NANOSEC_M		0x7
+
+#define TS_EVENT_SAMPLE			\
+	(REG_TS_EVENT_1_NANOSEC - REG_TS_EVENT_0_NANOSEC)
+
+#define PORT_CTRL_ADDR(port, addr)	((addr) | (((port) + 1) << 12))
+
+#define REG_GLOBAL_RR_INDEX__1		0x0600
+
+/* C - PTP */
+
+#define REG_PTP_PORT_RX_DELAY__2	0x0C00
+#define REG_PTP_PORT_TX_DELAY__2	0x0C02
+#define REG_PTP_PORT_ASYM_DELAY__2	0x0C04
+
+#define REG_PTP_PORT_XDELAY_TS		0x0C08
+#define REG_PTP_PORT_XDELAY_TS_H	0x0C08
+#define REG_PTP_PORT_XDELAY_TS_L	0x0C0A
+
+#define REG_PTP_PORT_SYNC_TS		0x0C0C
+#define REG_PTP_PORT_SYNC_TS_H		0x0C0C
+#define REG_PTP_PORT_SYNC_TS_L		0x0C0E
+
+#define REG_PTP_PORT_PDRESP_TS		0x0C10
+#define REG_PTP_PORT_PDRESP_TS_H	0x0C10
+#define REG_PTP_PORT_PDRESP_TS_L	0x0C12
+
+#define REG_PTP_PORT_TX_INT_STATUS__2	0x0C14
+#define REG_PTP_PORT_TX_INT_ENABLE__2	0x0C16
+
+#define PTP_PORT_SYNC_INT		BIT(15)
+#define PTP_PORT_XDELAY_REQ_INT		BIT(14)
+#define PTP_PORT_PDELAY_RESP_INT	BIT(13)
+
+#define REG_PTP_PORT_LINK_DELAY__4	0x0C18
+
+/* Port Switch Ingress Control Memory Map*/
+#define REG_PORT_RX_MIRROR_CTL			0x0800
+#define REG_PORT_RX_PRI_CTL			0x0801
+#define REG_PORT_RX_MAC_CTL1			0x0802
+#define REG_PORT_RX_AUTH_CTL			0x0803
+#define REG_PORT_RX_MAC_CTL2			0x0804
+#define REG_PORT_RX_TC_MAP			0x0808
+#define REG_PORT_RX_QCI_PTR			0x0850
+#define REG_PORT_RX_PSFP			0x0854
+#define REG_PORT_RX_QCI_METER_CTL		0x0860
+#define REG_PORT_RX_QCI_METER_SR		0x0864
+#define REG_PORT_RX_QCI_METER_BS		0x0868
+#define REG_PORT_RX_QCI_FS_CTL			0x0870
+#define REG_PORT_RX_QCI_FS_FM			0x0874
+#define REG_PORT_RX_QCI_FS_FPG			0x0878
+#define REG_PORT_RX_QCI_FS_FNPG			0x087C
+#define REG_PORT_RX_QCI_FS_FPMAX		0x0880
+#define REG_PORT_RX_QCI_FS_FNPMAX		0x0884
+#define REG_PORT_RX_QCI_FS_FD			0x0888
+#define REG_PORT_STREAM_CNT_STS			0x088C
+#define REG_PORT_METER_RED_INT_MSK		0x08C7
+#define REG_PORT_RX_CNT_OVR_INT_STS		0x08C1
+#define REG_PORT_RX_CNT_OVR_INT_MSK		0x08C2
+
+#define EN_ALL_STREAM_CNTR_INTR			0x00
+/* RX_AUTH_CTRL register defines*/
+/* 10b: Pass Mode. Authentication is disabled. When ACL is enabled, all traffic
+ * that misses the ACL rules is forwarded; otherwise ACL actions apply.
+ */
+#define AUTH_CTL_ACL_PASS_MODE				BIT(1)
+#define AUTH_CTL_ACL_ENABLE				BIT(2)
+
+/* PSFP register field defines*/
+#define FS_CTL_OVR_SIZE_FRAME_BLOCK_EN		BIT(1)
+#define FS_CTL_METER_EN				BIT(11)
+#define FS_CTL_GATE_EN				BIT(7)
+#define FS_CTL_MAX_SDU_EN			BIT(3)
+#define FS_CTL_METER_IDX_MSK			0x07
+#define FS_CTL_METER_IDX_POS			8
+#define FS_CTL_MAX_SDU_MASK			0xFFFF
+#define FS_CTL_MAX_SDU_POS			16
+#define PSFP_ENABLE				BIT(0)
+#define METER_SR_MASK				0xFFFF
+#define METER_SR_CIR_POS			16
+#define METER_BS_MASK				0xFFFF
+#define METER_BS_CBS_POS			16
+#define PORT_METER_RED_INT_MSK_ALL		0xFF
+
+/* REG_PORT_STREAM_CNT_STS access defines*/
+#define FILT_STR_FR_MATCH_CNT_OVR		BIT(5)
+#define FR_MATCH_CNTR_MAX		((1 << 20) - 1)
+
+#define FILT_STR_FR_FAIL_DROP_CNT_OVR		BIT(0)
+#define FR_DROP_CNTR_MAX		((1 << 20) - 1)
+
+/* defines to update Stream Policer Burst and Rate*/
+#define METER_SR_UPDT_RATE(C, P) ((((C) & METER_SR_MASK) << METER_SR_CIR_POS) |\
+				  ((P) & METER_SR_MASK))
+
+#define METER_SR_UPDT_BURST(C, P) ((((C) & METER_BS_MASK) << METER_BS_CBS_POS) \
+				   | ((P) & METER_BS_MASK))
+
+/* defines to update Stream filter parameters*/
+#define FS_UPDT_METER_IDX(IDX)	(((IDX) & FS_CTL_METER_IDX_MSK)\
+				 << FS_CTL_METER_IDX_POS)
+
+#define FS_UPDT_MTU(MTU)	(((MTU) & FS_CTL_MAX_SDU_MASK)\
+				 << FS_CTL_MAX_SDU_POS)
+
+/* TCAM/ACL Register space*/
+/* ACL Registers START */
+#define ACL_CTRL_BASE_ADDR  (0x600)
+#define ACL_CTRL_PORT_BASE_ADDR(port) ((port) * 0x1000)
+/* Reg Base address */						     /*size */
+#define REG_ACL_PORT_ADR		(ACL_CTRL_BASE_ADDR + 0x00)  /* 96b */
+#define REG_ACL_PORT_AAR		(ACL_CTRL_BASE_ADDR + 0x60)  /* 08b */
+#define REG_ACL_PORT_ABER		(ACL_CTRL_BASE_ADDR + 0x68)  /* 14b */
+#define REG_ACL_PORT_ARACR		(ACL_CTRL_BASE_ADDR + 0x78)  /* 04b */
+#define REG_ACL_PORT_PCTRL		(ACL_CTRL_BASE_ADDR + 0x7C)  /* 04b */
+#define REG_ACL_PORT_FR_COUNT0		(ACL_CTRL_BASE_ADDR + 0x80)  /* 04b */
+#define REG_ACL_PORT_FR_COUNT1		(ACL_CTRL_BASE_ADDR + 0x84)  /* 04b */
+#define REG_ACL_PORT_FR_COUNT2		(ACL_CTRL_BASE_ADDR + 0x88)  /* 04b */
+#define REG_ACL_PORT_FR_COUNT3		(ACL_CTRL_BASE_ADDR + 0x8C)  /* 04b */
+#define REG_ACL_PORT_NMATCH		(ACL_CTRL_BASE_ADDR + 0x94)  /* 08b */
+#define REG_ACL_PORT_INT_STS		(ACL_CTRL_BASE_ADDR + 0xA0)  /* 01b */
+#define REG_ACL_PORT_INT_MASK		(ACL_CTRL_BASE_ADDR + 0xA2)  /* 01b */
+#define REG_ACL_PORT_SPARE		(ACL_CTRL_BASE_ADDR + 0xC0)  /* 04b */
+#define REG_ACL_PORT_TCAM_BIST0		(ACL_CTRL_BASE_ADDR + 0xD0)  /* 02b */
+#define REG_ACL_PORT_TCAM_BIST1		(ACL_CTRL_BASE_ADDR + 0xD2)  /* 01b */
+#define REG_ACL_PORT_TCAM_BIST2		(ACL_CTRL_BASE_ADDR + 0xD3)  /* 01b */
+#define REG_ACL_PORT_TCAM_BIST3		(ACL_CTRL_BASE_ADDR + 0xD4)  /* 01b */
+#define REG_ACL_PORT_TCAM_BITMAP	(ACL_CTRL_BASE_ADDR + 0xE0)  /* 16b */
+
+/** REG_ACL_PORT_INT_STS register defines**/
+#define ACL_FR_COUNT_MAX_VALUE			0xFFFFFFFF
+#define ACL_FR_COUNT_OVR0			BIT(1)
+#define ACL_FR_COUNT_OVR1			BIT(2)
+#define ACL_FR_COUNT_OVR2			BIT(3)
+#define ACL_FR_COUNT_OVR3			BIT(4)
+
+#define ACL_FR_CNTR_INTR_EN			0x10
+
+/* Parser control register defines */
+#define PCTRL_TWO_FORMAT_TWO_PARSER_EACH	(BIT(29) | BIT(30))
+#define PCTRL_KEYTYPE0_MULTI_FMT		BIT(27)
+#define PCTRL_KEYTYPE1_MULTI_FMT		BIT(26)
+#define PCTRL_KEYTYPE2_MULTI_FMT		BIT(25)
+#define PCTRL_KEYTYPE3_MULTI_FMT		BIT(24)
+#define PCTRL_KEYTYPE0_UNIV_FMT			0
+#define PCTRL_KEYTYPE1_UNIV_FMT			0
+#define PCTRL_KEYTYPE2_UNIV_FMT			0
+#define PCTRL_KEYTYPE3_UNIV_FMT			0
+#define PCTRL_KEY2_VLAN_TAG_EN			BIT(17)
+#define PCTRL_KEY3_VLAN_TAG_EN			BIT(16)
+#define PCTRL_KEY1_VLAN_TAG_EN			BIT(18)
+#define PCTRL_KEY0_VLAN_TAG_EN			BIT(19)
+
+#define RGMII_1_TX_DELAY_2NS 		0x1B	
+#define RGMII_2_TX_DELAY_2NS 		0x1B
+#define RGMII_1_RX_DELAY_2NS 		0x1B
+#define RGMII_2_RX_DELAY_2NS 		0x1B
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_spi.c b/drivers/net/dsa/microchip/lan937x_spi.c
new file mode 100644
index 000000000000..17afa9b09ecb
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_spi.c
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip LAN937X switch driver register access through SPI
+ * Copyright (C) 2019-2021 Microchip Technology Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/of_device.h>
+
+#include "ksz_common.h"
+
+#define SPI_ADDR_SHIFT 24
+#define SPI_ADDR_ALIGN 3
+#define SPI_TURNAROUND_SHIFT 5
+
+KSZ_REGMAP_TABLE(lan937x, 32, SPI_ADDR_SHIFT, SPI_TURNAROUND_SHIFT,
+		 SPI_ADDR_ALIGN);
+
+static int lan937x_spi_probe(struct spi_device *spi)
+{
+	struct regmap_config rc;
+	struct ksz_device *dev;
+	int i, ret;
+
+	dev = ksz_switch_alloc(&spi->dev, spi);
+	if (!dev)
+		return -ENOMEM;
+
+	for (i = 0; i < ARRAY_SIZE(lan937x_regmap_config); i++) {
+		rc = lan937x_regmap_config[i];
+		rc.lock_arg = &dev->regmap_mutex;
+		dev->regmap[i] = devm_regmap_init_spi(spi, &rc);
+
+		if (IS_ERR(dev->regmap[i])) {
+			ret = PTR_ERR(dev->regmap[i]);
+			dev_err(&spi->dev,
+				"Failed to initialize regmap%i: %d\n",
+				lan937x_regmap_config[i].val_bits, ret);
+			return ret;
+		}
+	}
+
+	if (spi->dev.platform_data)
+		dev->pdata = spi->dev.platform_data;
+
+	dev->irq = spi->irq;
+
+	ret = lan937x_switch_register(dev);
+	/* Main DSA driver may not be started yet. */
+	if (ret)
+		return ret;
+
+	spi_set_drvdata(spi, dev);
+
+	return 0;
+}
+
+static void lan937x_spi_remove(struct spi_device *spi)
+{
+	struct ksz_device *dev = spi_get_drvdata(spi);
+
+	if (dev)
+		ksz_switch_remove(dev);
+
+	spi_set_drvdata(spi, NULL);
+}
+
+static void lan937x_spi_shutdown(struct spi_device *spi)
+{
+	struct ksz_device *dev = spi_get_drvdata(spi);
+
+	if (dev)
+		dsa_switch_shutdown(dev->ds);
+
+	spi_set_drvdata(spi, NULL);
+}
+
+static const struct of_device_id lan937x_dt_ids[] = {
+	{ .compatible = "microchip,lan9370",
+		.data = &ksz_switch_chips[LAN9370] },
+	{ .compatible = "microchip,lan9371",
+		.data = &ksz_switch_chips[LAN9371] },
+	{ .compatible = "microchip,lan9372",
+		.data = &ksz_switch_chips[LAN9372] },
+	{ .compatible = "microchip,lan9373",
+		.data = &ksz_switch_chips[LAN9373] },
+	{ .compatible = "microchip,lan9374",
+		.data = &ksz_switch_chips[LAN9374] },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lan937x_dt_ids);
+
+static const struct spi_device_id lan937x_spi_ids[] = {
+	{ .name = "lan9370" },
+	{ .name = "lan9371" },
+	{ .name = "lan9372" },
+	{ .name = "lan9373" },
+	{ .name = "lan9374" },
+	{},
+};
+MODULE_DEVICE_TABLE(spi, lan937x_spi_ids);
+
+static struct spi_driver lan937x_spi_driver = {
+	.driver = {
+		.name	= "lan937x-switch",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(lan937x_dt_ids),
+	},
+	.probe	= lan937x_spi_probe,
+	.remove	= lan937x_spi_remove,
+	.shutdown = lan937x_spi_shutdown,
+	.id_table = lan937x_spi_ids,
+};
+
+module_spi_driver(lan937x_spi_driver);
+
+MODULE_ALIAS("spi:lan937x");
+
+MODULE_AUTHOR("Prasanna Vengateshan Varadharajan <Prasanna.Vengateshan@microchip.com>");
+MODULE_DESCRIPTION("Microchip LAN937x Series Switch SPI access Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/dsa/microchip/lan937x_tas.c b/drivers/net/dsa/microchip/lan937x_tas.c
new file mode 100644
index 000000000000..f348eaaafb0e
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_tas.c
@@ -0,0 +1,131 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip lan937x dev ops functions
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+#include <net/dsa.h>
+#include <net/switchdev.h>
+#include "lan937x_reg.h"
+#include "ksz_common.h"
+#include "lan937x_dev.h"
+#include "lan937x_tc.h"
+#include "lan937x_ptp.h"
+#include "lan937x_tas.h"
+
+static bool lan937x_tas_validate_gcl(struct tc_taprio_qopt_offload *qopt)
+{
+	u8 i;
+
+	/* cycle time can only be 32bit */
+	if (qopt->cycle_time > (u32)-1)
+		return -EOPNOTSUPP;
+
+	/* Only set command is supported */
+	for (i = 0; i < qopt->num_entries; ++i)
+		if (qopt->entries[i].command != TC_TAPRIO_CMD_SET_GATES)
+			return -EOPNOTSUPP;
+
+	return 0;
+}
+
+static void lan937x_tas_set_basetime(struct ksz_device *dev, ktime_t base_time,
+				     u32 cycle_time,
+				     struct timespec64 *new_base_ts)
+{
+	ktime_t new_base_time;
+	ktime_t current_time;
+	struct timespec64 ts;
+
+	lan937x_ptp_gettime(&dev->ptp_caps, &ts);
+
+	current_time = timespec64_to_ktime(ts);
+	new_base_time = base_time;
+
+	if (base_time < current_time) {
+		u64 nr_of_cycles = current_time - base_time;
+		u32 add_cycles = 1;
+
+		/*Reserve 1ms for programming and activating */
+		if (cycle_time < 1000000)
+			add_cycles = DIV_ROUND_UP(1000000, cycle_time);
+
+		do_div(nr_of_cycles, cycle_time);
+		new_base_time += cycle_time * (nr_of_cycles + add_cycles);
+	}
+
+	*new_base_ts = ktime_to_timespec64(new_base_time);
+}
+
+int lan937x_setup_tc_taprio(struct dsa_switch *ds, int port,
+			    struct tc_taprio_qopt_offload *qopt)
+{
+	struct ksz_device *dev = ds->priv;
+	struct timespec64 base_ts;
+	u32 cycle_cnt;
+	int ret = 0;
+	u32 event;
+	u8 i;
+
+	if (!qopt->enable) {
+		ret = lan937x_port_cfg(dev, port, REG_PORT_TAS_GATE_CTRL__1,
+				       TAS_GATE_ENABLE, false);
+		return ret;
+	}
+
+	/* Validate GCL */
+	ret = lan937x_tas_validate_gcl(qopt);
+	if (ret)
+		return ret;
+
+	/* Enable Gating */
+	ret = lan937x_port_cfg(dev, port, REG_PORT_TAS_GATE_CTRL__1,
+			       TAS_GATE_ENABLE, true);
+	if (ret)
+		return ret;
+
+	/* Schedule entry */
+	for (i = 0; i < qopt->num_entries; i++) {
+		ret = lan937x_pwrite8(dev, port, REG_PORT_TAS_EVENT_INDEX__1,
+				      i);
+		if (ret)
+			return ret;
+
+		/*1 Cycle count equals 12ns. 1/83.3Mhz*/
+		event = qopt->entries[i].gate_mask << TAS_GATE_CMD_S;
+		cycle_cnt = qopt->entries[i].interval / 12;
+		event |= (cycle_cnt & TAS_GATE_CYCLE_M);
+
+		ret = lan937x_pwrite32(dev, port, REG_PORT_TAS_EVENT__4, event);
+		if (ret)
+			return ret;
+	}
+
+	/* Last schedule entry */
+	ret = lan937x_pwrite16(dev, port, REG_PORT_TAS_GCL_LAST_INDEX__2,
+			       qopt->num_entries - 1);
+	if (ret)
+		return ret;
+
+	/*PTP Cycle time*/
+	ret = lan937x_pwrite32(dev, port, REG_PORT_TAS_CYCLE_TIME__4,
+			       qopt->cycle_time);
+	if (ret)
+		return ret;
+
+	/*PTP Base time */
+	lan937x_tas_set_basetime(dev, qopt->base_time, qopt->cycle_time,
+				 &base_ts);
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_TAS_TRIG_SEC__4,
+			       base_ts.tv_sec);
+	if (ret)
+		return ret;
+
+	ret = lan937x_pwrite32(dev, port, REG_PORT_TAS_TRIG_NSEC__4,
+			       base_ts.tv_nsec);
+	if (ret)
+		return ret;
+
+	/*Set the config change bit */
+	return lan937x_port_cfg(dev, port, REG_PORT_TAS_GATE_CTRL__1,
+				TAS_CFG_CHANGE, true);
+}
diff --git a/drivers/net/dsa/microchip/lan937x_tas.h b/drivers/net/dsa/microchip/lan937x_tas.h
new file mode 100644
index 000000000000..e16a3e85c5ce
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_tas.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip lan937x Time aware schedular functions
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+#ifndef _LAN937x_TAS_H
+#define _LAN937x_TAS_H
+
+#if IS_ENABLED(CONFIG_NET_DSA_MICROCHIP_LAN937X_TAS)
+
+int lan937x_setup_tc_taprio(struct dsa_switch *ds, int port,
+			    struct tc_taprio_qopt_offload *admin);
+#else
+
+static inline int lan937x_setup_tc_taprio(struct dsa_switch *ds, int port,
+					  struct tc_taprio_qopt_offload *admin)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
+#endif
diff --git a/drivers/net/dsa/microchip/lan937x_tc.c b/drivers/net/dsa/microchip/lan937x_tc.c
new file mode 100644
index 000000000000..0d427d51363a
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_tc.c
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Microchip lan937x dev ops functions
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+#include <net/dsa.h>
+#include <net/switchdev.h>
+#include "lan937x_reg.h"
+#include "ksz_common.h"
+#include "lan937x_dev.h"
+#include "lan937x_tc.h"
+#include "lan937x_tas.h"
+
+#define LAN937X_CBS_ENABLE ((MTI_SCHEDULE_STRICT_PRIO << MTI_SCHEDULE_MODE_S) | \
+			    (MTI_SHAPING_SRP << MTI_SHAPING_S))
+#define LAN937X_CBS_DISABLE ((MTI_SCHEDULE_WRR << MTI_SCHEDULE_MODE_S) |\
+			     (MTI_SHAPING_OFF << MTI_SHAPING_S))
+
+/* Bandwidth is calculated by idle slope/transmission speed. Then the Bandwidth
+ * is converted to Hex-decimal using the successive multiplication method. On
+ * every step, integer part is taken and decimal part is carry forwarded.
+ */
+static int cinc_cal(s32 idle_slope, s32 send_slope)
+{
+	int cinc = 0;
+	u32 txrate;
+	u32 rate;
+	u8 temp;
+	u8 i;
+
+	txrate = idle_slope - send_slope;
+
+	rate = idle_slope;
+
+	/* 24 bit register */
+	for (i = 0; i < 6; i++) {
+		rate = rate * 16;
+
+		temp = rate / txrate;
+
+		rate %= txrate;
+
+		cinc = ((cinc << 4) | temp);
+	}
+
+	return cinc;
+}
+
+static int lan937x_setup_tc_cbs(struct dsa_switch *ds, int port,
+				struct tc_cbs_qopt_offload *qopt)
+{
+	struct ksz_device *dev = ds->priv;
+	int ret;
+	u32 bw;
+
+	if (qopt->queue > LAN937X_NUM_TC)
+		return -EINVAL;
+
+	/* Queue Selection */
+	ret = lan937x_pwrite32(dev, port, REG_PORT_MTI_QUEUE_INDEX__4,
+			       qopt->queue);
+	if (ret)
+		return ret;
+
+	if (!qopt->enable) {
+		lan937x_pwrite8(dev, port, REG_PORT_MTI_QUEUE_CTRL_0,
+				LAN937X_CBS_DISABLE);
+		return 0;
+	}
+
+	ret = lan937x_pwrite8(dev, port, REG_PORT_MTI_QUEUE_CTRL_0,
+			      LAN937X_CBS_ENABLE);
+	if (ret)
+		return ret;
+
+	/* High Credit */
+	ret = lan937x_pwrite16(dev, port, REG_PORT_MTI_HI_WATER_MARK,
+			       qopt->hicredit);
+	if (ret)
+		return ret;
+
+	/* Low Credit */
+	ret = lan937x_pwrite16(dev, port, REG_PORT_MTI_LO_WATER_MARK,
+			       qopt->locredit);
+	if (ret)
+		return ret;
+
+	/* Credit Increment Register */
+	bw = cinc_cal(qopt->idleslope, qopt->sendslope);
+
+	return lan937x_pwrite32(dev, port, REG_PORT_MTI_CREDIT_INCREMENT, bw);
+}
+
+int lan937x_setup_tc(struct dsa_switch *ds, int port,
+		     enum tc_setup_type type, void *type_data)
+{
+	switch (type) {
+	case TC_SETUP_QDISC_CBS:
+		return lan937x_setup_tc_cbs(ds, port, type_data);
+	case TC_SETUP_QDISC_TAPRIO:
+		return lan937x_setup_tc_taprio(ds, port, type_data);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+void lan937x_tc_queue_init(struct dsa_switch *ds)
+{
+	struct ksz_device *dev = ds->priv;
+	int port;
+
+	ds->num_tx_queues = LAN937X_NUM_TC;
+
+	for (port = 0; port < dev->info->port_cnt; port++) {
+		lan937x_port_cfg(dev, port, REG_PORT_CTRL_0,
+				 PORT_QUEUE_SPLIT_ENABLE, true);
+	}
+}
diff --git a/drivers/net/dsa/microchip/lan937x_tc.h b/drivers/net/dsa/microchip/lan937x_tc.h
new file mode 100644
index 000000000000..ecf3aa1dff25
--- /dev/null
+++ b/drivers/net/dsa/microchip/lan937x_tc.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Microchip LAN937X TC Implementation
+ * Copyright (C) 2021 Microchip Technology Inc.
+ */
+
+#ifndef _NET_DSA_DRIVERS_LAN937X_TC_H
+#define _NET_DSA_DRIVERS_LAN937X_TC_H
+
+#include <net/pkt_cls.h>
+
+#define LAN937X_NUM_TC 8
+
+void lan937x_tc_queue_init(struct dsa_switch *ds);
+
+int lan937x_setup_tc(struct dsa_switch *ds, int port, enum tc_setup_type type,
+		     void *type_data);
+#endif
diff --git a/include/linux/dsa/ksz_common.h b/include/linux/dsa/ksz_common.h
new file mode 100644
index 000000000000..969b6cc51df3
--- /dev/null
+++ b/include/linux/dsa/ksz_common.h
@@ -0,0 +1,71 @@
+#ifndef _NET_DSA_KSZ_COMMON_H_
+#define _NET_DSA_KSZ_COMMON_H_
+
+#include <linux/bitfield.h>
+#include <linux/bits.h>
+#include <linux/ktime.h>
+#include <linux/kthread.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_classify.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/time64.h>
+#include <net/dsa.h>
+
+/* All time stamps from the KSZ consist of 2 bits for seconds and 30 bits for
+ * nanoseconds. This is NOT the same as 32 bits for nanoseconds.
+ */
+#define KSZ_TSTAMP_SEC_MASK  GENMASK(31, 30)
+#define KSZ_TSTAMP_NSEC_MASK GENMASK(29, 0)
+
+#define KSZ9477_HWTS_EN  0
+#define LAN937X_HWTS_EN  0
+
+struct ksz_device_ptp_shared {
+	/* protects ptp_clock_time (user space (various syscalls)
+	 * vs. softirq in ksz9477_rcv_timestamp()).
+	 */
+	spinlock_t ptp_clock_lock;
+	/* approximated current time, read once per second from hardware */
+	struct timespec64 ptp_clock_time;
+	unsigned long state;
+};
+
+struct lan937x_port_ptp_shared{
+	struct ksz_device_ptp_shared *dev;
+        struct kthread_worker *sync_worker;
+        struct kthread_worker *pdelayreq_worker;
+        struct kthread_worker *pdelayrsp_worker;
+	struct kthread_work sync_work;
+	struct sk_buff_head sync_queue;
+	struct kthread_work pdelayreq_work;
+	struct sk_buff_head pdelayreq_queue;
+	struct kthread_work pdelayrsp_work;
+	struct sk_buff_head pdelayrsp_queue;
+};
+
+/* net/dsa/tag_ksz.c */
+static inline ktime_t ksz_decode_tstamp(u32 tstamp)
+{
+	u64 ns = FIELD_GET(KSZ_TSTAMP_SEC_MASK, tstamp) * NSEC_PER_SEC +
+		 FIELD_GET(KSZ_TSTAMP_NSEC_MASK, tstamp);
+
+	return ns_to_ktime(ns);
+}
+
+ktime_t ksz_tstamp_reconstruct(struct ksz_device_ptp_shared *ksz,
+				   ktime_t tstamp);
+
+struct ksz_skb_cb {
+	struct sk_buff *clone;
+	unsigned int ptp_type;
+	/* Do not cache pointer to PTP header between ksz9477_ptp_port_txtstamp
+	 * and ksz9xxx_xmit() (will become invalid during dsa_realloc_skb()).
+	 */
+	u8 ptp_msg_type;
+};
+
+#define KSZ_SKB_CB(skb) \
+	((struct ksz_skb_cb *)((skb)->cb))
+
+#endif /* _NET_DSA_KSZ_COMMON_H_ */
diff --git a/include/net/dsa.h b/include/net/dsa.h
index 14f07275852b..efad77f4af7b 100644
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -53,6 +53,8 @@ struct phylink_link_state;
 #define DSA_TAG_PROTO_SJA1110_VALUE		23
 #define DSA_TAG_PROTO_RTL8_4_VALUE		24
 #define DSA_TAG_PROTO_RTL8_4T_VALUE		25
+#define DSA_TAG_PROTO_LAN937X_VALUE		26
+#define DSA_TAG_PROTO_LAN937X_CASCADE_VALUE	27
 
 enum dsa_tag_protocol {
 	DSA_TAG_PROTO_NONE		= DSA_TAG_PROTO_NONE_VALUE,
@@ -81,6 +83,8 @@ enum dsa_tag_protocol {
 	DSA_TAG_PROTO_SJA1110		= DSA_TAG_PROTO_SJA1110_VALUE,
 	DSA_TAG_PROTO_RTL8_4		= DSA_TAG_PROTO_RTL8_4_VALUE,
 	DSA_TAG_PROTO_RTL8_4T		= DSA_TAG_PROTO_RTL8_4T_VALUE,
+	DSA_TAG_PROTO_LAN937X		= DSA_TAG_PROTO_LAN937X_VALUE,
+	DSA_TAG_PROTO_LAN937X_CASCADE	= DSA_TAG_PROTO_LAN937X_CASCADE_VALUE,
 };
 
 struct dsa_switch;
@@ -279,6 +283,8 @@ struct dsa_port {
 
 	u8			stp_state;
 
+	void *priv;
+
 	/* Warning: the following bit fields are not atomic, and updating them
 	 * can only be done from code paths where concurrency is not possible
 	 * (probe time or under rtnl_lock).
diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 3509fc967ca9..c649d84a3947 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -4,8 +4,12 @@
  * Copyright (c) 2017 Microchip Technology
  */
 
+
+#include <linux/dsa/ksz_common.h>
+#include <linux/etherdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/list.h>
+#include <linux/slab.h>
 #include <net/dsa.h>
 #include "dsa_priv.h"
 
@@ -15,15 +19,15 @@
 
 static struct sk_buff *ksz_common_rcv(struct sk_buff *skb,
 				      struct net_device *dev,
-				      unsigned int port, unsigned int len)
+				      unsigned int port, unsigned int len, u8 device)
 {
-	skb->dev = dsa_master_find_slave(dev, 0, port);
+	skb->dev = dsa_master_find_slave(dev, device, port);
 	if (!skb->dev)
 		return NULL;
 
 	pskb_trim_rcsum(skb, skb->len - len);
 
-	dsa_default_offload_fwd_mark(skb);
+	skb->offload_fwd_mark = true;
 
 	return skb;
 }
@@ -70,7 +74,7 @@ static struct sk_buff *ksz8795_rcv(struct sk_buff *skb, struct net_device *dev)
 {
 	u8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
 
-	return ksz_common_rcv(skb, dev, tag[0] & 7, KSZ_EGRESS_TAG_LEN);
+	return ksz_common_rcv(skb, dev, tag[0] & 7, KSZ_EGRESS_TAG_LEN, 0);
 }
 
 static const struct dsa_device_ops ksz8795_netdev_ops = {
@@ -143,7 +147,7 @@ static struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev)
 	if (tag[0] & KSZ9477_PTP_TAG_INDICATION)
 		len += KSZ9477_PTP_TAG_LEN;
 
-	return ksz_common_rcv(skb, dev, port, len);
+	return ksz_common_rcv(skb, dev, port, len, 0);
 }
 
 static const struct dsa_device_ops ksz9477_netdev_ops = {
@@ -193,10 +197,237 @@ static const struct dsa_device_ops ksz9893_netdev_ops = {
 DSA_TAG_DRIVER(ksz9893_netdev_ops);
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893);
 
+
+/* For xmit, 2 bytes are added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|tag1(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : represents tag override, lookup and valid
+ * tag1 : each bit represents port (eg, 0x01=port1, 0x02=port2, 0x80=port8)
+ *
+ * For rcv, 1 byte is added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : zero-based value represents port
+ *	  (eg, 0x00=port1, 0x02=port3, 0x07=port8)
+ */
+#define LAN937X_CASCADE_TAG_LEN		3
+#define LAN937X_EGRESS_TAG_LEN		2
+#define LAN937X_PTP_TAG_LEN		4
+
+#define LAN937X_PTP_TAG_INDICATION	BIT(7)
+#define LAN937X_CASCADE_CHIP            BIT(6)
+
+#define LAN937X_TAIL_TAG_BLOCKING_OVERRIDE	BIT(11)
+#define LAN937X_TAIL_TAG_LOOKUP			BIT(12)
+#define LAN937X_TAIL_TAG_VALID			BIT(13)
+#define LAN937X_TAIL_TAG_PORT_MASK		7
+
+ktime_t ksz_tstamp_reconstruct(struct ksz_device_ptp_shared *ksz, ktime_t tstamp)
+{
+	struct timespec64 ts = ktime_to_timespec64(tstamp);
+	struct timespec64 ptp_clock_time;
+	struct timespec64 diff;
+
+	spin_lock_bh(&ksz->ptp_clock_lock);
+	ptp_clock_time = ksz->ptp_clock_time;
+	spin_unlock_bh(&ksz->ptp_clock_lock);
+
+	/* calculate full time from partial time stamp */
+	ts.tv_sec = (ptp_clock_time.tv_sec & ~3) | ts.tv_sec;
+
+	/* find nearest possible point in time */
+	diff = timespec64_sub(ts, ptp_clock_time);
+	if (diff.tv_sec > 2)
+		ts.tv_sec -= 4;
+	else if (diff.tv_sec < -2)
+		ts.tv_sec += 4;
+
+	return timespec64_to_ktime(ts);
+}
+EXPORT_SYMBOL(ksz_tstamp_reconstruct);
+
+static void lan937x_xmit_timestamp(struct sk_buff *skb)
+{
+	u32 tstamp_raw = 0;
+
+	put_unaligned_be32(tstamp_raw, skb_put(skb, LAN937X_PTP_TAG_LEN));
+}
+
+static struct sk_buff *lan937x_defer_xmit(struct dsa_port *dp,
+					  struct sk_buff *skb)
+{
+	struct lan937x_port_ptp_shared *ptp_shared = dp->priv;
+	struct sk_buff *clone = KSZ_SKB_CB(skb)->clone;
+	u8 ptp_msg_type;
+
+	if (!clone)
+		return skb;  /* no deferred xmit for this packet */
+
+	/* Use cached PTP msg type from ksz9477_ptp_port_txtstamp().  */
+	ptp_msg_type = KSZ_SKB_CB(clone)->ptp_msg_type;
+	switch(ptp_msg_type)
+	{
+	case PTP_MSGTYPE_SYNC:
+		skb_queue_tail(&ptp_shared->sync_queue, skb_get(skb));
+		kthread_queue_work(ptp_shared->sync_worker, &ptp_shared->sync_work);
+		break;
+
+	case PTP_MSGTYPE_PDELAY_REQ:
+		skb_queue_tail(&ptp_shared->pdelayreq_queue, skb_get(skb));
+		kthread_queue_work(ptp_shared->pdelayreq_worker, &ptp_shared->pdelayreq_work);
+		break;
+
+	case PTP_MSGTYPE_PDELAY_RESP:
+		skb_queue_tail(&ptp_shared->pdelayrsp_queue, skb_get(skb));
+		kthread_queue_work(ptp_shared->pdelayrsp_worker, &ptp_shared->pdelayrsp_work);
+		break;
+
+	default:
+		kfree_skb(clone);
+		KSZ_SKB_CB(skb)->clone = NULL;
+		return skb;
+	}
+
+	return NULL;
+}
+
+static void lan937x_rcv_timestamp(struct sk_buff *skb, u8 *tag,
+                                  struct net_device *dev, unsigned int port)
+{
+	struct skb_shared_hwtstamps *hwtstamps = skb_hwtstamps(skb);
+	struct dsa_switch *ds = dev->dsa_ptr->ds;
+	struct lan937x_port_ptp_shared *port_ptp_shared;
+	u8 *tstamp_raw = tag - KSZ9477_PTP_TAG_LEN;
+	ktime_t tstamp;
+
+	port_ptp_shared = dsa_to_port(ds, port)->priv;
+	if (!port_ptp_shared)
+		return;
+
+	/* convert time stamp and write to skb */
+	tstamp = ksz_decode_tstamp(get_unaligned_be32(tstamp_raw));
+	memset(hwtstamps, 0, sizeof(*hwtstamps));
+	hwtstamps->hwtstamp = ksz_tstamp_reconstruct(port_ptp_shared->dev, tstamp);
+}
+
+static u16 lan937x_common_tt_fmt(struct net_device *dev, struct dsa_port *dp,
+								struct sk_buff *skb)
+{
+	struct lan937x_port_ptp_shared *port_ptp_shared = dp->priv;
+	struct ksz_device_ptp_shared *ptp_shared = port_ptp_shared->dev;
+	u16 queue_mapping = skb_get_queue_mapping(skb);
+	u8 prio = netdev_txq_to_tc(dev, queue_mapping);
+	const struct ethhdr *hdr = eth_hdr(skb);
+	u16 val = 0;
+
+	/* Tag encoding */
+	if (test_bit(LAN937X_HWTS_EN, &ptp_shared->state))
+		lan937x_xmit_timestamp(skb);
+
+	/* priority */
+	val |= (prio<<8);
+
+	if (is_link_local_ether_addr(hdr->h_dest))
+		val |= LAN937X_TAIL_TAG_BLOCKING_OVERRIDE;
+
+	/* Tail tag valid bit - This bit should always be set by the CPU */
+	val |= LAN937X_TAIL_TAG_VALID;
+
+	return val;
+}
+
+static struct sk_buff *lan937x_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	__be16 *tag;
+	u16 val;
+
+	/* FIXME: confirm putting this first will not harm anyone */
+	if (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))
+		return NULL;
+
+	val = lan937x_common_tt_fmt(dev, dp, skb);
+	val |= BIT(dp->index);
+
+	tag = skb_put(skb, LAN937X_EGRESS_TAG_LEN);
+
+	put_unaligned_be16(val,tag);
+
+	return lan937x_defer_xmit(dp, skb);
+}
+
+static struct sk_buff *lan937x_rcv(struct sk_buff *skb, struct net_device *dev)
+{
+	/* Tag decoding */
+	u8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
+	unsigned int port = tag[0] & LAN937X_TAIL_TAG_PORT_MASK;
+	unsigned int len = KSZ_EGRESS_TAG_LEN;
+	u8 device = 0;
+
+	/* Extra 4-bytes PTP timestamp */
+	if (tag[0] & LAN937X_PTP_TAG_INDICATION) {
+		lan937x_rcv_timestamp(skb, tag, dev, port);
+		len += KSZ9477_PTP_TAG_LEN;
+	}
+
+	if (tag[0] & LAN937X_CASCADE_CHIP)
+		device = 1;
+
+	return ksz_common_rcv(skb, dev, port, len, device);
+}
+
+static const struct dsa_device_ops lan937x_netdev_ops = {
+	.name	= "lan937x",
+	.proto	= DSA_TAG_PROTO_LAN937X,
+	.xmit	= lan937x_xmit,
+	.rcv	= lan937x_rcv,
+	.needed_tailroom = LAN937X_EGRESS_TAG_LEN + LAN937X_PTP_TAG_LEN,
+};
+
+DSA_TAG_DRIVER(lan937x_netdev_ops);
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_LAN937X);
+
+static struct sk_buff *lan937x_cascade_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	__be32 *tag_32;
+	u32 val_32 = 0;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))
+		return NULL;
+
+	tag_32 = skb_put(skb, LAN937X_CASCADE_TAG_LEN);
+
+	val_32 = (lan937x_common_tt_fmt(dev, dp, skb) << 8);
+
+	val_32 |= BIT((dp->index + (8 * dp->ds->index)));
+
+	put_unaligned_be24(val_32,tag_32);
+
+	return lan937x_defer_xmit(dp, skb);
+}
+
+static const struct dsa_device_ops cascade_netdev_ops = {
+	.name	= "lan937x_cascade",
+	.proto	= DSA_TAG_PROTO_LAN937X_CASCADE,
+	.xmit	= lan937x_cascade_xmit,
+	.rcv	= lan937x_rcv,
+	.needed_tailroom = LAN937X_CASCADE_TAG_LEN + LAN937X_PTP_TAG_LEN,
+};
+
+DSA_TAG_DRIVER(cascade_netdev_ops);
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_LAN937X_CASCADE);
+
 static struct dsa_tag_driver *dsa_tag_driver_array[] = {
 	&DSA_TAG_DRIVER_NAME(ksz8795_netdev_ops),
 	&DSA_TAG_DRIVER_NAME(ksz9477_netdev_ops),
 	&DSA_TAG_DRIVER_NAME(ksz9893_netdev_ops),
+	&DSA_TAG_DRIVER_NAME(lan937x_netdev_ops),
+	&DSA_TAG_DRIVER_NAME(cascade_netdev_ops),
 };
 
 module_dsa_tag_drivers(dsa_tag_driver_array);
-- 
2.34.1

