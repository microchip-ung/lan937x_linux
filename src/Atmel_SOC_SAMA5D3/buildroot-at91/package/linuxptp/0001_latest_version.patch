From b2f2c9e02dfd43dc90d57128304e9a681672e19b Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Tue, 21 Aug 2018 10:53:08 +0200
Subject: [PATCH 001/173] snmp4lptp: Add snmp sub agent for linuxptp

The sub agent use net-snmp library and AgentX protocol for the
communication towards the snmp master agent.
snmpd.c should only include general setup needed for handling snmp.
Supported MIBs should be implemented in separate files.
Makefile will include snmpd if libsnmp is available during compilation.
configs/snmpd.conf should be placed in /etc/snmp/

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 .gitignore         |  1 +
 configs/snmpd.conf | 26 +++++++++++++++++++++
 makefile           | 13 +++++++++++
 snmp4lptp.c        | 57 ++++++++++++++++++++++++++++++++++++++++++++++
 snmpflg.sh         | 42 ++++++++++++++++++++++++++++++++++
 5 files changed, 139 insertions(+)
 create mode 100644 configs/snmpd.conf
 create mode 100644 snmp4lptp.c
 create mode 100755 snmpflg.sh

diff --git a/.gitignore b/.gitignore
index 6d288ae..3dbcbfa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,4 +7,5 @@
 /pmc
 /ptp4l
 /phc_ctl
+/snmp4lptp
 /timemaster
diff --git a/configs/snmpd.conf b/configs/snmpd.conf
new file mode 100644
index 0000000..8a0d929
--- /dev/null
+++ b/configs/snmpd.conf
@@ -0,0 +1,26 @@
+# Map 'linuxptp' community to the 'LinuxPtpUser'
+# Map 'public' community to the 'AllUser'
+#       sec.name        source          community
+com2sec LinuxPtpUser    default         linuxptp
+com2sec AllUser         default         public
+
+# Map 'LinuxPtpUser' to 'LinuxPtpGroup' for SNMP Version 2c
+# Map 'AllUser' to 'AllGroup' for SNMP Version 2c
+#                       sec.model       sec.name
+group   LinuxPtpGroup   v2c             LinuxPtpUser
+group   AllGroup        v2c             AllUser
+
+# Define 'SystemView', which includes everything under .1.3.6.1.2.1.241
+# Define 'AllView', which includes everything under .1
+#                       incl/excl       subtree
+view    SystemView      included        .1.3.6.1.2.1.241
+view    AllView         included        .1
+
+# Give 'ConfigGroup' read access to objects in the view 'SystemView'
+# Give 'AllGroup' read access to objects in the view 'AllView'
+#                       context model   level   prefix  read            write   notify
+access  LinuxPtpGroup   ""      any     noauth  exact   SystemView      none    none
+access  AllGroup        ""      any     noauth  exact   AllView         none    none
+
+# turn on the AgentX master agent support
+master agentx
diff --git a/makefile b/makefile
index 693e75d..b6a96d0 100644
--- a/makefile
+++ b/makefile
@@ -35,9 +35,16 @@ SRC	= $(OBJECTS:.o=.c)
 DEPEND	= $(OBJECTS:.o=.d)
 srcdir	:= $(dir $(lastword $(MAKEFILE_LIST)))
 incdefs := $(shell $(srcdir)/incdefs.sh)
+snmpflg	:= $(shell $(srcdir)/snmpflg.sh)
 version := $(shell $(srcdir)/version.sh $(srcdir))
 VPATH	= $(srcdir)
 
+ifneq (,$(findstring -DHAVE_NET_SNMP,$(snmpflg)))
+PRG	+= snmp4lptp
+OBJECTS	+= snmp4lptp.o
+snmplib	:= $(shell net-snmp-config --netsnmp-agent-libs)
+endif
+
 prefix	= /usr/local
 sbindir	= $(prefix)/sbin
 mandir	= $(prefix)/man
@@ -61,6 +68,12 @@ hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
+snmp4lptp: print.o sk.o snmp4lptp.o util.o
+	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
+
+snmp4lptp.o: snmp4lptp.c
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(snmpflg) -c $<
+
 timemaster: print.o rtnl.o sk.o timemaster.o util.o version.o
 
 version.o: .version version.sh $(filter-out version.d,$(DEPEND))
diff --git a/snmp4lptp.c b/snmp4lptp.c
new file mode 100644
index 0000000..eec49af
--- /dev/null
+++ b/snmp4lptp.c
@@ -0,0 +1,57 @@
+/**
+ * @file snmp4lptp.c
+ * @brief Implements SNMP sub agent program for linuxptp
+ * @note Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#include "util.h"
+
+static int open_snmp()
+{
+	snmp_enable_calllog();
+	netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
+			       NETSNMP_DS_AGENT_ROLE, 1);
+	init_agent("linuxptpAgent");
+
+	init_snmp("linuxptpAgent");
+
+	return 0;
+}
+
+int main(int argc, char *argv[])
+{
+	int err = 0;
+
+	if (handle_term_signals()) {
+		return -1;
+	}
+
+	if (open_snmp()) {
+		return -1;
+	}
+
+	while (is_running()) {
+		agent_check_and_process(1);
+	}
+
+	snmp_shutdown("linuxptpAgent");
+
+	return err;
+}
diff --git a/snmpflg.sh b/snmpflg.sh
new file mode 100755
index 0000000..3c58bcb
--- /dev/null
+++ b/snmpflg.sh
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# Discover the SNMP CFLAGS to use during compilation.
+#
+# Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+#
+# Look for libsnmp presence.  When cross compiling, the user will
+# specify the include path in EXTRA_CFLAGS.
+#
+snmp_flags()
+{
+	# Get list of directories searched for header files.
+	dirs=$(echo "" | ${CROSS_COMPILE}cpp ${EXTRA_CFLAGS} -Wp,-v 2>&1 >/dev/null | grep ^" /")
+
+	# Look for libsnmp presence
+	for d in $dirs; do
+		files=$(find $d -type f -name net-snmp-agent-includes.h)
+		for f in $files; do
+			if grep -q NET_SNMP_AGENT_INCLUDES_H $f; then
+				printf " -DHAVE_NET_SNMP `net-snmp-config --cflags`"
+				break 2
+			fi
+		done
+	done
+}
+
+echo "$(snmp_flags)"
-- 
2.17.1


From 68dcd10673ba5bca0d6d6976e4253ae5e7bf8d68 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Tue, 21 Aug 2018 10:53:09 +0200
Subject: [PATCH 002/173] snmp4lptp: Added communication to ptp4l via the UDS
 port.

UDS transport is configured using pmc_common functions.

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 makefile    |   3 +-
 snmp4lptp.c | 102 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 102 insertions(+), 3 deletions(-)

diff --git a/makefile b/makefile
index b6a96d0..6995e70 100644
--- a/makefile
+++ b/makefile
@@ -68,7 +68,8 @@ hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
-snmp4lptp: print.o sk.o snmp4lptp.o util.o
+snmp4lptp: config.o hash.o msg.o pmc_common.o print.o raw.o sk.o \
+ snmp4lptp.o tlv.o transport.o udp.o udp6.o uds.o util.o
 	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
 
 snmp4lptp.o: snmp4lptp.c
diff --git a/snmp4lptp.c b/snmp4lptp.c
index eec49af..b32e4f6 100644
--- a/snmp4lptp.c
+++ b/snmp4lptp.c
@@ -21,8 +21,26 @@
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 
+#include "config.h"
+#include "pmc_common.h"
+#include "print.h"
 #include "util.h"
 
+static struct pmc *pmc;
+
+static int open_pmc(struct config *cfg)
+{
+	char uds_local[MAX_IFNAME_SIZE + 1];
+	snprintf(uds_local, sizeof(uds_local), "/var/run/snmp4lptp.%d", getpid());
+
+	pmc = pmc_create(cfg, TRANS_UDS, uds_local, 0,
+			 config_get_int(cfg, NULL, "domainNumber"),
+			 config_get_int(cfg, NULL, "transportSpecific") << 4,
+			 1);
+
+	return pmc ? 0 : -1;
+}
+
 static int open_snmp()
 {
 	snmp_enable_calllog();
@@ -35,23 +53,103 @@ static int open_snmp()
 	return 0;
 }
 
+static void usage(char *progname)
+{
+	fprintf(stderr,
+		"\nusage: %s [options]\n\n"
+		" -f [file] read configuration from 'file'\n"
+		" -h        prints this message and exits\n"
+		" -m        print messages to stdout\n"
+		" -q        do not print messages to the syslog\n"
+		"\n",
+		progname);
+}
+
 int main(int argc, char *argv[])
 {
-	int err = 0;
+	char *config = NULL, *progname;
+	int c, err = 0, index;
+	struct option *opts;
+	struct config *cfg;
 
 	if (handle_term_signals()) {
 		return -1;
 	}
 
-	if (open_snmp()) {
+	cfg = config_create();
+	if (!cfg) {
 		return -1;
 	}
 
+	opts = config_long_options(cfg);
+	print_set_verbose(1);
+	print_set_syslog(0);
+
+	/* Process the command line arguments. */
+	progname = strrchr(argv[0], '/');
+	progname = progname ? 1+progname : argv[0];
+	while (EOF != (c = getopt_long(argc, argv, "f:hmq", opts, &index))) {
+		switch (c) {
+		case 0:
+			if (config_parse_option(cfg, opts[index].name, optarg)) {
+				config_destroy(cfg);
+				return -1;
+			}
+			break;
+		case 'f':
+			config = optarg;
+			break;
+		case 'h':
+			usage(progname);
+			err = -1;
+			goto out;
+		case 'm':
+			config_set_int(cfg, "verbose", 1);
+			break;
+		case 'q':
+			config_set_int(cfg, "use_syslog", 0);
+			break;
+		case '?':
+		default:
+			usage(progname);
+			err = -1;
+			goto out;
+		}
+	}
+
+	if (config && (err = config_read(config, cfg))) {
+		err = -1;
+		goto out;
+	}
+
+	print_set_progname(progname);
+	print_set_tag(config_get_string(cfg, NULL, "message_tag"));
+	print_set_verbose(config_get_int(cfg, NULL, "verbose"));
+	print_set_syslog(config_get_int(cfg, NULL, "use_syslog"));
+	print_set_level(config_get_int(cfg, NULL, "logging_level"));
+
+
+	if (open_pmc(cfg)) {
+		err = -1;
+		goto pmc_out;
+	}
+
+	if (open_snmp()) {
+		err = -1;
+		goto snmp_out;
+	}
+
 	while (is_running()) {
 		agent_check_and_process(1);
 	}
 
 	snmp_shutdown("linuxptpAgent");
 
+snmp_out:
+	pmc_destroy(pmc);
+	msg_cleanup();
+pmc_out:
+out:
+	config_destroy(cfg);
 	return err;
 }
-- 
2.17.1


From 1d0832b2f50d8f3a1a67f8cc5ba2390d8f1e7a63 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Tue, 21 Aug 2018 10:53:10 +0200
Subject: [PATCH 003/173] snmp4lptp: Added function for data collection from
 ptp4l program.

General function to use for sending signals for data collection
from ptp4l program.

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 snmp4lptp.c     | 37 +++++++++++++++++++++++++++++++++++++
 snmp4lptp_mib.h | 30 ++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+)
 create mode 100644 snmp4lptp_mib.h

diff --git a/snmp4lptp.c b/snmp4lptp.c
index b32e4f6..e06f212 100644
--- a/snmp4lptp.c
+++ b/snmp4lptp.c
@@ -17,6 +17,9 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
+#include <errno.h>
+#include <poll.h>
+
 #include <net-snmp/net-snmp-config.h>
 #include <net-snmp/net-snmp-includes.h>
 #include <net-snmp/agent/net-snmp-agent-includes.h>
@@ -24,10 +27,44 @@
 #include "config.h"
 #include "pmc_common.h"
 #include "print.h"
+#include "snmp4lptp_mib.h"
 #include "util.h"
 
+#define SNMP_NFD 1
 static struct pmc *pmc;
 
+struct ptp_message* snmp4lptp_run_pmc(char *cmd)
+{
+	struct pollfd pollfd[SNMP_NFD];
+	int cnt, tmo = 100;
+
+	pollfd[0].fd = pmc_get_transport_fd(pmc);
+	pollfd[0].events = POLLIN | POLLPRI;
+
+	if (cmd && pmc_do_command(pmc, cmd)) {
+		pr_err("bad command: %s", cmd);
+	}
+
+	while (is_running()) {
+		cnt = poll(pollfd, SNMP_NFD, tmo);
+		if (cnt < 0) {
+			if (EINTR == errno) {
+				continue;
+			} else {
+				pr_emerg("poll failed");
+				break;
+			}
+		} else if (!cnt) {
+			break;
+		}
+
+		if (pollfd[0].revents & (POLLIN|POLLPRI)) {
+			return pmc_recv(pmc);
+		}
+	}
+	return NULL;
+}
+
 static int open_pmc(struct config *cfg)
 {
 	char uds_local[MAX_IFNAME_SIZE + 1];
diff --git a/snmp4lptp_mib.h b/snmp4lptp_mib.h
new file mode 100644
index 0000000..f135006
--- /dev/null
+++ b/snmp4lptp_mib.h
@@ -0,0 +1,30 @@
+/**
+ * @file snmp4lptp_mib.h
+ * @brief Common header file for all supported mibs in linuxptp
+ * @note Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef HAVE_SNMP4LPTP_MIB_H
+#define HAVE_SNMP4LPTP_MIB_H
+
+#include "msg.h"
+
+/*
+ * function declarations
+ */
+struct ptp_message* snmp4lptp_run_pmc(char *cmd);
+
+#endif /* HAVE_SNMP4LPTP_MIB_H */
-- 
2.17.1


From 399907db7f9dc3f57c3f9831b3b4da705a2c51a3 Mon Sep 17 00:00:00 2001
From: Erez Geva <erezgeva2@gmail.com>
Date: Tue, 28 Aug 2018 22:05:28 +0200
Subject: [PATCH 004/173] config: Add hardware time stamp filter setting mode

Add global option for the hardware time stamp setting.
The function could:
Normally set the filters as the PTP daemon require.
Check that the filters are proper but do not change them.
Full, set the RX filter to all and the TX filter as the PTP daemon require.

[ RC: added missing extern keyword and fixed indentation. ]

Signed-off-by: Erez Geva <erez.geva.ext@siemens.com>
Signed-off-by: Erez Geva <ErezGeva2@gmail.com>
---
 config.c |  8 +++++
 ptp4l.8  |  9 ++++++
 ptp4l.c  |  1 +
 sk.c     | 93 +++++++++++++++++++++++++++++++++++++-------------------
 sk.h     | 15 +++++++++
 5 files changed, 95 insertions(+), 31 deletions(-)

diff --git a/config.c b/config.c
index 7914ba4..3530ce6 100644
--- a/config.c
+++ b/config.c
@@ -164,6 +164,13 @@ static struct config_enum delay_mech_enu[] = {
 	{ NULL, 0 },
 };
 
+static struct config_enum hwts_filter_enu[] = {
+	{ "normal",  HWTS_FILTER_NORMAL  },
+	{ "check",   HWTS_FILTER_CHECK   },
+	{ "full",    HWTS_FILTER_FULL    },
+	{ NULL, 0 },
+};
+
 static struct config_enum nw_trans_enu[] = {
 	{ "L2",    TRANS_IEEE_802_3 },
 	{ "UDPv4", TRANS_UDP_IPV4   },
@@ -215,6 +222,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("G.8275.defaultDS.localPriority", 128, 1, UINT8_MAX),
 	PORT_ITEM_INT("G.8275.portDS.localPriority", 128, 1, UINT8_MAX),
 	GLOB_ITEM_INT("gmCapable", 1, 0, 1),
+	GLOB_ITEM_ENU("hwts_filter", HWTS_FILTER_NORMAL, hwts_filter_enu),
 	PORT_ITEM_INT("hybrid_e2e", 0, 0, 1),
 	PORT_ITEM_INT("ignore_transport_specific", 0, 0, 1),
 	PORT_ITEM_INT("ingressLatency", 0, INT_MIN, INT_MAX),
diff --git a/ptp4l.8 b/ptp4l.8
index 10c5c2f..39bf36e 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -661,6 +661,15 @@ The time source is a single byte code that gives an idea of the kind
 of local clock in use. The value is purely informational, having no
 effect on the outcome of the Best Master Clock algorithm, and is
 advertised when the clock becomes grand master.
+.TP
+.B hwts_filter
+Select the hardware time stamp filter setting mode.
+Possible values are normal, check, full.
+Normal mode set the filters as needed.
+Check mode only check but do not set.
+Full mode set the receive filter to mark all packets with hardware time stamp,
+ so all applications can get them.
+The default is normal.
 
 .SH UNICAST DISCOVERY OPTIONS
 
diff --git a/ptp4l.c b/ptp4l.c
index 9ef8169..3a9f084 100644
--- a/ptp4l.c
+++ b/ptp4l.c
@@ -191,6 +191,7 @@ int main(int argc, char *argv[])
 	assume_two_step = config_get_int(cfg, NULL, "assume_two_step");
 	sk_check_fupsync = config_get_int(cfg, NULL, "check_fup_sync");
 	sk_tx_timeout = config_get_int(cfg, NULL, "tx_timestamp_timeout");
+	sk_hwts_filter_mode = config_get_int(cfg, NULL, "hwts_filter");
 
 	if (config_get_int(cfg, NULL, "clock_servo") == CLOCK_SERVO_NTPSHM) {
 		config_set_int(cfg, "kernel_leap", 0);
diff --git a/sk.c b/sk.c
index f18b2bf..43f1800 100644
--- a/sk.c
+++ b/sk.c
@@ -40,39 +40,76 @@
 
 int sk_tx_timeout = 1;
 int sk_check_fupsync;
+enum hwts_filter_mode sk_hwts_filter_mode = HWTS_FILTER_NORMAL;
 
 /* private methods */
 
-static int hwts_init(int fd, const char *device, int rx_filter, int tx_type)
+static void init_ifreq(struct ifreq *ifreq, struct hwtstamp_config *cfg,
+	const char *device)
 {
-	struct ifreq ifreq;
-	struct hwtstamp_config cfg, req;
-	int err;
+	memset(ifreq, 0, sizeof(*ifreq));
+	memset(cfg, 0, sizeof(*cfg));
 
-	memset(&ifreq, 0, sizeof(ifreq));
-	memset(&cfg, 0, sizeof(cfg));
+	strncpy(ifreq->ifr_name, device, sizeof(ifreq->ifr_name) - 1);
 
-	strncpy(ifreq.ifr_name, device, sizeof(ifreq.ifr_name) - 1);
+	ifreq->ifr_data = (void *) cfg;
+}
 
-	ifreq.ifr_data = (void *) &cfg;
-	cfg.tx_type    = tx_type;
-	cfg.rx_filter  = rx_filter;
-	req = cfg;
-	err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
-	if (err < 0)
-		return err;
+static int hwts_init(int fd, const char *device, int rx_filter,
+	int rx_filter2, int tx_type)
+{
+	struct ifreq ifreq;
+	struct hwtstamp_config cfg;
+	int err;
 
-	if (memcmp(&cfg, &req, sizeof(cfg))) {
+	init_ifreq(&ifreq, &cfg, device);
 
-		pr_debug("driver changed our HWTSTAMP options");
-		pr_debug("tx_type   %d not %d", cfg.tx_type, req.tx_type);
-		pr_debug("rx_filter %d not %d", cfg.rx_filter, req.rx_filter);
+	switch (sk_hwts_filter_mode) {
+	case HWTS_FILTER_CHECK:
+		err = ioctl(fd, SIOCGHWTSTAMP, &ifreq);
+		if (err < 0) {
+			pr_err("ioctl SIOCGHWTSTAMP failed: %m");
+			return err;
+		}
+		break;
+	case HWTS_FILTER_FULL:
+		cfg.tx_type   = tx_type;
+		cfg.rx_filter = HWTSTAMP_FILTER_ALL;
+		err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
+		if (err < 0) {
+			pr_err("ioctl SIOCSHWTSTAMP failed: %m");
+			return err;
+		}
+		break;
+	case HWTS_FILTER_NORMAL:
+		cfg.tx_type   = tx_type;
+		cfg.rx_filter = rx_filter;
+		err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
+		if (err < 0) {
+			pr_info("driver rejected most general HWTSTAMP filter");
 
-		if (cfg.tx_type != req.tx_type ||
-		    (cfg.rx_filter != HWTSTAMP_FILTER_ALL &&
-		     cfg.rx_filter != HWTSTAMP_FILTER_PTP_V2_EVENT)) {
-			return -1;
+			init_ifreq(&ifreq, &cfg, device);
+			cfg.tx_type   = tx_type;
+			cfg.rx_filter = rx_filter2;
+
+			err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
+			if (err < 0) {
+				pr_err("ioctl SIOCSHWTSTAMP failed: %m");
+				return err;
+			}
 		}
+		break;
+	}
+
+	if (cfg.tx_type != tx_type ||
+	    (cfg.rx_filter != rx_filter &&
+	     cfg.rx_filter != rx_filter2 &&
+	     cfg.rx_filter != HWTSTAMP_FILTER_ALL)) {
+		pr_debug("tx_type   %d not %d", cfg.tx_type, tx_type);
+		pr_debug("rx_filter %d not %d or %d", cfg.rx_filter, rx_filter,
+			 rx_filter2);
+		pr_err("The current filter does not match the required");
+		return -1;
 	}
 
 	return 0;
@@ -450,15 +487,9 @@ int sk_timestamping_init(int fd, const char *device, enum timestamp_type type,
 		case TRANS_UDS:
 			return -1;
 		}
-		err = hwts_init(fd, device, filter1, tx_type);
-		if (err) {
-			pr_info("driver rejected most general HWTSTAMP filter");
-			err = hwts_init(fd, device, filter2, tx_type);
-			if (err) {
-				pr_err("ioctl SIOCSHWTSTAMP failed: %m");
-				return err;
-			}
-		}
+		err = hwts_init(fd, device, filter1, filter2, tx_type);
+		if (err)
+			return err;
 	}
 
 	if (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMPING,
diff --git a/sk.h b/sk.h
index d91d5d8..fd4d820 100644
--- a/sk.h
+++ b/sk.h
@@ -23,6 +23,16 @@
 #include "address.h"
 #include "transport.h"
 
+/**
+ * Defines the available Hardware time-stamp setting modes.
+ */
+
+enum hwts_filter_mode {
+	HWTS_FILTER_NORMAL,    /* set hardware filters in normal way */
+	HWTS_FILTER_CHECK,     /* check filters but do not change them */
+	HWTS_FILTER_FULL,      /* Use time-stamp on all received packets */
+};
+
 /**
  * Contains timestamping information returned by the GET_TS_INFO ioctl.
  * @valid:            set to non-zero when the info struct contains valid data.
@@ -131,4 +141,9 @@ extern int sk_tx_timeout;
  */
 extern int sk_check_fupsync;
 
+/**
+ * Hardware time-stamp setting mode
+ */
+extern enum hwts_filter_mode sk_hwts_filter_mode;
+
 #endif
-- 
2.17.1


From 1173e774dd71f890369c55baa69f33291195e373 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Fri, 14 Sep 2018 10:57:30 +0200
Subject: [PATCH 005/173] Introduce the maxStepsRemoved attribute

Add attribute maxStepsRemoved which is included in IEEE1588-2017 (v2.1)
It is an optional attribute which can decide if an Announce message is
considered in the operation of the BMCA or not.

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 clock.c              | 7 +++++++
 clock.h              | 7 +++++++
 config.c             | 1 +
 configs/G.8275.1.cfg | 1 +
 configs/G.8275.2.cfg | 1 +
 configs/default.cfg  | 1 +
 port.c               | 5 +----
 ptp4l.8              | 7 +++++++
 8 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/clock.c b/clock.c
index faf2dea..47592ac 100644
--- a/clock.c
+++ b/clock.c
@@ -106,6 +106,7 @@ struct clock {
 	int utc_offset;
 	int time_flags;  /* grand master role */
 	int time_source; /* grand master role */
+	UInteger8 max_steps_removed;
 	enum servo_state servo_state;
 	enum timestamp_type timestamping;
 	tmv_t master_offset;
@@ -930,6 +931,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	}
 	c->default_dataset.localPriority =
 		config_get_int(config, NULL, "G.8275.defaultDS.localPriority");
+	c->max_steps_removed = config_get_int(config, NULL,"maxStepsRemoved");
 
 	/* Harmonize the twoStepFlag with the time_stamping option. */
 	if (config_harmonize_onestep(config)) {
@@ -1564,6 +1566,11 @@ int clock_slave_only(struct clock *c)
 	return c->dds.flags & DDS_SLAVE_ONLY;
 }
 
+UInteger8 clock_max_steps_removed(struct clock *c)
+{
+	return c->max_steps_removed;
+}
+
 UInteger16 clock_steps_removed(struct clock *c)
 {
 	return c->cur.stepsRemoved;
diff --git a/clock.h b/clock.h
index cc2910a..07aba18 100644
--- a/clock.h
+++ b/clock.h
@@ -260,6 +260,13 @@ int clock_poll(struct clock *c);
  */
 int clock_slave_only(struct clock *c);
 
+/**
+ * Obtain the max steps removed field from a clock's default data set.
+ * @param c  The clock instance.
+ * @return   The value of the clock's max steps removed field.
+ */
+UInteger8 clock_max_steps_removed(struct clock *c);
+
 /**
  * Obtain the steps removed field from a clock's current data set.
  * @param c  The clock instance.
diff --git a/config.c b/config.c
index 3530ce6..3455b5a 100644
--- a/config.c
+++ b/config.c
@@ -235,6 +235,7 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("logSyncInterval", 0, INT8_MIN, INT8_MAX),
 	GLOB_ITEM_INT("logging_level", LOG_INFO, PRINT_LEVEL_MIN, PRINT_LEVEL_MAX),
 	PORT_ITEM_INT("masterOnly", 0, 0, 1),
+	GLOB_ITEM_INT("maxStepsRemoved", 255, 2, UINT8_MAX),
 	GLOB_ITEM_STR("message_tag", NULL),
 	GLOB_ITEM_STR("manufacturerIdentity", "00:00:00"),
 	GLOB_ITEM_INT("max_frequency", 900000000, 0, INT_MAX),
diff --git a/configs/G.8275.1.cfg b/configs/G.8275.1.cfg
index f40cda0..288fa4f 100644
--- a/configs/G.8275.1.cfg
+++ b/configs/G.8275.1.cfg
@@ -7,5 +7,6 @@
 [global]
 dataset_comparison		G.8275.x
 G.8275.defaultDS.localPriority	128
+maxStepsRemoved			255
 masterOnly			0
 G.8275.portDS.localPriority	128
diff --git a/configs/G.8275.2.cfg b/configs/G.8275.2.cfg
index 3d7a908..15bc609 100644
--- a/configs/G.8275.2.cfg
+++ b/configs/G.8275.2.cfg
@@ -7,6 +7,7 @@
 [global]
 dataset_comparison		G.8275.x
 G.8275.defaultDS.localPriority	128
+maxStepsRemoved			255
 masterOnly			0
 G.8275.portDS.localPriority	128
 hybrid_e2e			1
diff --git a/configs/default.cfg b/configs/default.cfg
index c5a8b57..2ac6eb7 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -17,6 +17,7 @@ dscp_event		0
 dscp_general		0
 dataset_comparison	ieee1588
 G.8275.defaultDS.localPriority	128
+maxStepsRemoved		255
 #
 # Port Data Set
 #
diff --git a/port.c b/port.c
index 5e0aed7..01e99a2 100644
--- a/port.c
+++ b/port.c
@@ -1711,10 +1711,7 @@ int process_announce(struct port *p, struct ptp_message *m)
 {
 	int result = 0;
 
-	/* Do not qualify announce messages with stepsRemoved >= 255, see
-	 * IEEE1588-2008 section 9.3.2.5 (d)
-	 */
-	if (m->announce.stepsRemoved >= 255) {
+	if (m->announce.stepsRemoved >= clock_max_steps_removed(p->clock)) {
 		return result;
 	}
 
diff --git a/ptp4l.8 b/ptp4l.8
index 39bf36e..90454fa 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -414,6 +414,13 @@ timing network without loops) only when using the default values of
 G.8275.defaultDS.localPriority and G.8275.portDS.localPriority.
 Careful network engineering is needed when using non-default values.
 .TP
+.B maxStepsRemoved
+When using this option, if the value of stepsRemoved of an Announce
+message is greater than or equal to the value of maxStepsRemoved the
+Announce message is not considered in the operation of the BMCA.
+The default value is 255.
+.TP
+
 .B domainNumber
 The domain attribute of the local clock.
 The default is 0.
-- 
2.17.1


From 57b98c216a7c93f7378c9978d93d2dc99f7d7a71 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Fri, 14 Sep 2018 11:14:58 +0200
Subject: [PATCH 006/173] Add possibility to set clockIdentity

Currently the clockIdentity is generated from the mac address of the first
interface/port in config file. This patch add the possibility to set it in
config file.
The reason is if the stack is restarted with a different set of ports, it
may be circumstances when clockIdentity needs to be equal as before
restart even if the port setup is different.

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 clock.c  | 16 +++++++++++++---
 config.c |  1 +
 ptp4l.8  |  9 +++++++++
 util.c   | 15 +++++++++++++++
 util.h   |  9 +++++++++
 5 files changed, 47 insertions(+), 3 deletions(-)

diff --git a/clock.c b/clock.c
index 47592ac..0a000b9 100644
--- a/clock.c
+++ b/clock.c
@@ -988,9 +988,19 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		pr_info("selected /dev/ptp%d as PTP clock", phc_index);
 	}
 
-	if (generate_clock_identity(&c->dds.clockIdentity, iface->name)) {
-		pr_err("failed to generate a clock identity");
-		return NULL;
+	if (strcmp(config_get_string(config, NULL, "clockIdentity"),
+		   "000000.0000.000000") == 0) {
+		if (generate_clock_identity(&c->dds.clockIdentity,
+					    iface->name)) {
+			pr_err("failed to generate a clock identity");
+			return NULL;
+		}
+	} else {
+		if (str2cid(config_get_string(config, NULL, "clockIdentity"),
+					      &c->dds.clockIdentity)) {
+			pr_err("failed to set clock identity");
+			return NULL;
+		}
 	}
 
 	/* Configure the UDS. */
diff --git a/config.c b/config.c
index 3455b5a..ac082bf 100644
--- a/config.c
+++ b/config.c
@@ -202,6 +202,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("check_fup_sync", 0, 0, 1),
 	GLOB_ITEM_INT("clockAccuracy", 0xfe, 0, UINT8_MAX),
 	GLOB_ITEM_INT("clockClass", 248, 0, UINT8_MAX),
+	GLOB_ITEM_STR("clockIdentity", "000000.0000.000000"),
 	GLOB_ITEM_ENU("clock_servo", CLOCK_SERVO_PI, clock_servo_enu),
 	GLOB_ITEM_ENU("clock_type", CLOCK_TYPE_ORDINARY, clock_type_enu),
 	GLOB_ITEM_ENU("dataset_comparison", DS_CMP_IEEE1588, dataset_comp_enu),
diff --git a/ptp4l.8 b/ptp4l.8
index 90454fa..d1751df 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -395,6 +395,15 @@ The clockAccuracy attribute of the local clock. It is used in the best master
 selection algorithm.
 The default is 0xFE.
 .TP
+.B clockIdentity
+The clockIdentity attribute of the local clock.
+The clockIdentity is an 8-octet array and should in this configuration be
+written in textual form, see default. It should be unique since it is used to
+identify the specific clock.
+If default is used or if not set at all, the clockIdentity will be automtically
+generated.
+The default is "000000.0000.000000"
+.TP
 .B offsetScaledLogVariance
 The offsetScaledLogVariance attribute of the local clock. It characterizes the
 stability of the clock.
diff --git a/util.c b/util.c
index 73fb37e..c617510 100644
--- a/util.c
+++ b/util.c
@@ -218,6 +218,21 @@ int str2mac(const char *s, unsigned char mac[MAC_LEN])
 	return 0;
 }
 
+int str2cid(const char *s, struct ClockIdentity *result)
+{
+	struct ClockIdentity cid;
+	unsigned char *ptr = cid.id;
+	int c;
+	c = sscanf(s, " %02hhx%02hhx%02hhx.%02hhx%02hhx.%02hhx%02hhx%02hhx",
+		   &ptr[0], &ptr[1], &ptr[2], &ptr[3],
+		   &ptr[4], &ptr[5], &ptr[6], &ptr[7]);
+	if (c == 8) {
+		*result = cid;
+		return 0;
+	}
+	return -1;
+}
+
 int str2pid(const char *s, struct PortIdentity *result)
 {
 	struct PortIdentity pid;
diff --git a/util.h b/util.h
index 1ab1b3f..39d602e 100644
--- a/util.h
+++ b/util.h
@@ -133,6 +133,15 @@ int str2addr(enum transport_type type, const char *s, struct address *addr);
  */
 int str2mac(const char *s, unsigned char mac[MAC_LEN]);
 
+/**
+ * Scan a string containing a clock identity and convert it into binary form.
+ *
+ * @param s       String in human readable form.
+ * @param result  Pointer to a buffer to hold the result.
+ * @return Zero on success, or -1 if the string is incorrectly formatted.
+ */
+int str2cid(const char *s, struct ClockIdentity *result);
+
 /**
  * Scan a string containing a port identity and convert it into binary form.
  *
-- 
2.17.1


From 2b006082789aef176eaac25344b19ef88b1ded63 Mon Sep 17 00:00:00 2001
From: Ethel Nilsson <ethel.nilsson@est.tech>
Date: Thu, 20 Sep 2018 13:18:13 +0200
Subject: [PATCH 007/173] snmp4lptp: added snmp4lptp.8

Signed-off-by: Ethel Nilsson <ethel.nilsson@est.tech>
---
 snmp4lptp.8 | 119 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 119 insertions(+)
 create mode 100644 snmp4lptp.8

diff --git a/snmp4lptp.8 b/snmp4lptp.8
new file mode 100644
index 0000000..7dda4d0
--- /dev/null
+++ b/snmp4lptp.8
@@ -0,0 +1,119 @@
+.TH SNMP4LPTP 8 "September 2018" "linuxptp"
+.SH NAME
+snmp4lptp - SNMP sub agent
+
+.SH SYNOPSIS
+.B snmp4lptp
+[
+.BI \-f " config-file"
+] [
+.B \-m
+] [
+.B \-q
+] [
+.I long-options
+]
+
+.SH DESCRIPTION
+.B snmp4lptp
+is an implementation of a sub agent for handling SNMP requests on
+the device running ptp4l. Via the UDS port, the sub agent retrieves
+management information from ptp4l and translates the information to
+or from an SNMP-specific form. 
+
+.SH OPTIONS
+.TP
+.BI \-f " file"
+Specify the path to the \fBsnmp4lptp\fR configuration file.
+.TP
+.B \-h
+Display a help message.
+.TP
+.B \-m
+Print messages to the standard output.
+.TP
+.B \-q
+Don't send messages to the system logger.
+
+.SH LONG OPTIONS
+
+Each and every configuration file option (see below in sections
+.BR PROGRAM\ OPTIONS
+and
+.BR PORT\ OPTIONS )
+may also appear
+as a "long" style command line argument. For example, the transportSpecific
+option may be set using either of these two forms:
+
+.RS
+\f(CW\-\-transportSpecific 1   \-\-transportSpecific=1\fP
+.RE
+
+Option values given on the command line override values in the global
+section of the configuration file (which, in turn, overrides default
+values).
+
+.SH CONFIGURATION FILE
+
+The configuration file is divided into sections. Each section starts with a
+line containing its name enclosed in brackets and it follows with settings.
+Each setting is placed on a separate line, it contains the name of the
+option and the value separated by whitespace characters. Empty lines and lines
+starting with # are ignored.
+
+The global section (indicated as
+.BR [global] )
+sets the global program options as well as the default port specific options.
+Other sections are port specific sections and they override the default port
+options. The name of the section is the name of the configured port (e.g.
+.BR [eth0]
+). Currently no port specific options other than default are considered.
+
+.SH PROGRAM OPTIONS
+.TP
+.B domainNumber
+The domain attribute of the local clock.
+The default is 0.
+.TP
+.B logging_level
+The maximum logging level of messages which should be printed.
+The default is 6 (LOG_INFO).
+.TP
+.B message_tag
+The tag which is added to all messages printed to the standard output or system
+log.
+The default is an empty string (which cannot be set in the configuration file
+as the option requires an argument).
+.TP
+.B use_syslog
+Print messages to the system log if enabled.
+The default is 1 (enabled).
+.TP
+.B verbose
+Print messages to the standard output if enabled.
+The default is 0 (disabled).
+.TP
+.B uds_address
+Specifies the address of the server's UNIX domain socket.
+The default is /var/run/ptp4l.
+
+.SH PORT OPTIONS
+.TP
+.B transportSpecific
+The transport specific field. Must be in the range 0 to 255.
+The default is 0.
+
+.SH WARNING
+
+Be cautious when the same configuration file is used for both ptp4l
+and snmp4lptp. Keep in mind that values specified in the configuration
+file take precedence over their default values. If a certain option which
+is common to ptp4l and snmp4lptp is specified to a non-default value in
+the configuration file (e.g. for ptp4l), then this non-default value
+applies also for snmp4lptp. This might be not what is expected.
+
+To avoid securely these unexpected behaviour, different configuration files
+for ptp4l and snmp4lptp are recommended.
+
+.SH SEE ALSO
+.BR ptp4l (8)
-- 
2.17.1


From 241d8a064efa535029e28b87a8995add3cca8c0c Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Tue, 25 Sep 2018 18:16:19 +0200
Subject: [PATCH 008/173] unicast: Process timeouts equal to current time.

Don't postpone processing of a timeout if it is equal to the current
time. This prevents an infinite loop with a simulated clock.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 unicast_service.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/unicast_service.c b/unicast_service.c
index ad0e06a..9c9b95b 100644
--- a/unicast_service.c
+++ b/unicast_service.c
@@ -502,7 +502,7 @@ int unicast_service_timer(struct port *p)
 		pr_debug("peek i={2^%d} tmo={%ld,%ld}", interval->log_period,
 			 interval->tmo.tv_sec, interval->tmo.tv_nsec);
 
-		if (timespec_compare(&now, &interval->tmo) >= 0) {
+		if (timespec_compare(&now, &interval->tmo) > 0) {
 			break;
 		}
 		interval = pqueue_extract(p->unicast_service->queue);
-- 
2.17.1


From 78a720f2b38459f5be1089f01e4b396e6167948a Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Tue, 25 Sep 2018 18:16:20 +0200
Subject: [PATCH 009/173] timemaster: Allow ptp4l-specific sections in
 [ptp4l.conf].

Remove > from beginning of lines specified in the *.conf sections in
order to allow a ptp4l-specific section (e.g. [unicast_master_table]) to
be included there.

After inserting the lines to the generated ptp4l.conf, switch back to
the [global] section.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 timemaster.8 | 10 +++++++---
 timemaster.c | 28 ++++++++++++++++++++++++----
 2 files changed, 31 insertions(+), 7 deletions(-)

diff --git a/timemaster.8 b/timemaster.8
index 7288972..2f92976 100644
--- a/timemaster.8
+++ b/timemaster.8
@@ -253,9 +253,13 @@ Specify extra options that should be added to all \fBptp4l\fR command lines. By
 default, \fB\-l 5\fR is added to the command lines.
 
 .SS [ptp4l.conf]
-Settings specified in this section are copied directly to the configuration
-files generated for all \fBptp4l\fR instances. There is no default content of
-this section.
+Settings specified in this section are copied directly to the global section of
+the configuration files generated for all \fBptp4l\fR instances. There is no
+default content of this section.
+
+Other sections (e.g. \fB[unicast_master_table]\fR) may be specified here, but
+lines beginning with the bracket need to be prefixed with the \fB>\fR character
+to prevent \fBtimemaster\fR from parsing it as a beginning of another section.
 
 .SH NOTES
 For best accuracy, \fBchronyd\fR is usually preferred over \fBntpd\fR, it also
diff --git a/timemaster.c b/timemaster.c
index 4ba921e..058678f 100644
--- a/timemaster.c
+++ b/timemaster.c
@@ -405,6 +405,23 @@ static int parse_timemaster_settings(char **settings,
 	return 0;
 }
 
+static char **parse_raw_settings(char **settings)
+{
+	char **setting, *s, **parsed_settings;
+
+	parsed_settings = (char **)parray_new();
+
+	for (setting = settings; *setting; setting++) {
+		s = *setting;
+		/* Unescape lines beginning with '>' */
+		if (s[0] == '>')
+			s++;
+		parray_append((void ***)&parsed_settings, xstrdup(s));
+	}
+
+	return parsed_settings;
+}
+
 static int parse_section(char **settings, char *name,
 			 struct timemaster_config *config)
 {
@@ -451,8 +468,7 @@ static int parse_section(char **settings, char *name,
 
 	if (settings_dst) {
 		free_parray((void **)*settings_dst);
-		*settings_dst = (char **)parray_new();
-		extend_string_array(settings_dst, settings);
+		*settings_dst = parse_raw_settings(settings);
 	}
 
 	return 0;
@@ -802,9 +818,13 @@ static int add_ptp_source(struct ptp_domain *source,
 		config_file = xmalloc(sizeof(*config_file));
 		config_file->path = string_newf("%s/ptp4l.%d.conf",
 						config->rundir, *shm_segment);
+
 		config_file->content = xstrdup("[global]\n");
-		extend_config_string(&config_file->content,
-				     config->ptp4l.settings);
+		if (*config->ptp4l.settings) {
+			extend_config_string(&config_file->content,
+					     config->ptp4l.settings);
+			string_appendf(&config_file->content, "\n[global]\n");
+		}
 		extend_config_string(&config_file->content,
 				     source->ptp4l_settings);
 		string_appendf(&config_file->content,
-- 
2.17.1


From 4910055bd7b426c0be50945c3c7b9007379aad90 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:47 -0700
Subject: [PATCH 010/173] port: Add condition to check fc.

If foreign clock is NULL, both the clocks are obviously not equal. So,
return 0 in that case.

The above condition (fc == NULL) is not currently encountered. It will
be encoutered in the next few patches which implement static roles for
master and slave.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 port.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/port.c b/port.c
index 01e99a2..303310f 100644
--- a/port.c
+++ b/port.c
@@ -144,6 +144,11 @@ static int msg_current(struct ptp_message *m, struct timespec now)
 static int msg_source_equal(struct ptp_message *m1, struct foreign_clock *fc)
 {
 	struct PortIdentity *id1, *id2;
+
+	if (!fc) {
+		return 0;
+	}
+
 	id1 = &m1->header.sourcePortIdentity;
 	id2 = &fc->dataset.sender;
 	return 0 == memcmp(id1, id2, sizeof(*id1));
-- 
2.17.1


From 386fc3ed893a2215784c76ffa745dd3fddaa451d Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:48 -0700
Subject: [PATCH 011/173] clock: Add NULL check for best clock in
 clock_update_slave()

This scenario will only be encountered when the clock transitions to the
slave state without knowing who the master is.

This will result in a segfault for BMCA with designated master and slave
states (to be added in upcoming patches).

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 clock.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/clock.c b/clock.c
index 0a000b9..56bc79b 100644
--- a/clock.c
+++ b/clock.c
@@ -636,7 +636,12 @@ static void clock_update_grandmaster(struct clock *c)
 static void clock_update_slave(struct clock *c)
 {
 	struct parentDS *pds = &c->dad.pds;
-	struct ptp_message *msg        = TAILQ_FIRST(&c->best->messages);
+	struct ptp_message *msg;
+
+	if (!c->best)
+		return;
+
+	msg                            = TAILQ_FIRST(&c->best->messages);
 	c->cur.stepsRemoved            = 1 + c->best->dataset.stepsRemoved;
 	pds->parentPortIdentity        = c->best->dataset.sender;
 	pds->grandmasterIdentity       = msg->announce.grandmasterIdentity;
-- 
2.17.1


From 3f764aec6a10bdff0c28a68f28fac06d5755c07f Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:49 -0700
Subject: [PATCH 012/173] port: Add configurable option to set asCapable.

If set to 'true', this unconditionally sets the asCapable variable. The
usual checks will be applied to asCapable if it is set to 'auto'. The
default value is 'auto'.

This config option is needed by the Automotive Profile. The master will
be able to send out Sync Message as soon as the daemon is started.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 as_capable.h        | 45 +++++++++++++++++++++++++++++++++++++++++++++
 config.c            |  8 ++++++++
 configs/default.cfg |  1 +
 port.c              | 17 +++++++++++++----
 port_private.h      |  3 ++-
 ptp4l.8             |  6 ++++++
 6 files changed, 75 insertions(+), 5 deletions(-)
 create mode 100644 as_capable.h

diff --git a/as_capable.h b/as_capable.h
new file mode 100644
index 0000000..fbd77b2
--- /dev/null
+++ b/as_capable.h
@@ -0,0 +1,45 @@
+/**
+ * @file as_capable.h
+ * @brief Enumerates the states for asCapable.
+ * @note Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef HAVE_AS_CAPABLE_H
+#define HAVE_AS_CAPABLE_H
+
+/* Enum used by the asCapable config option. */
+enum as_capable_option {
+	AS_CAPABLE_TRUE,
+	AS_CAPABLE_AUTO,
+};
+
+/*
+ * Defines whether the device can interoperate with the device on other end via
+ * IEEE 802.1AS protocol.
+ *
+ * More information about this in Section 10.2.4.1 of IEEE 802.1AS standard.
+ */
+enum as_capable {
+	NOT_CAPABLE,
+	AS_CAPABLE,
+	/*
+	 * Non-standard extension to support Automotive Profile. asCapable
+	 * always set to true without checking the system at other end.
+	 */
+	ALWAYS_CAPABLE,
+};
+
+#endif
diff --git a/config.c b/config.c
index ac082bf..c55bd51 100644
--- a/config.c
+++ b/config.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "as_capable.h"
 #include "bmc.h"
 #include "clock.h"
 #include "config.h"
@@ -195,8 +196,15 @@ static struct config_enum tsproc_enu[] = {
 	{ NULL, 0 },
 };
 
+static struct config_enum as_capable_enu[] = {
+	{ "true", AS_CAPABLE_TRUE },
+	{ "auto", AS_CAPABLE_AUTO },
+	{ NULL, 0 },
+};
+
 struct config_item config_tab[] = {
 	PORT_ITEM_INT("announceReceiptTimeout", 3, 2, UINT8_MAX),
+	PORT_ITEM_ENU("asCapable", AS_CAPABLE_AUTO, as_capable_enu),
 	GLOB_ITEM_INT("assume_two_step", 0, 0, 1),
 	PORT_ITEM_INT("boundary_clock_jbod", 0, 0, 1),
 	GLOB_ITEM_INT("check_fup_sync", 0, 0, 1),
diff --git a/configs/default.cfg b/configs/default.cfg
index 2ac6eb7..d2b8c8f 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -32,6 +32,7 @@ fault_reset_interval	4
 neighborPropDelayThresh	20000000
 masterOnly		0
 G.8275.portDS.localPriority	128
+asCapable               auto
 #
 # Run time options
 #
diff --git a/port.c b/port.c
index 303310f..cd87553 100644
--- a/port.c
+++ b/port.c
@@ -644,15 +644,16 @@ static int port_capable(struct port *p)
 	}
 
 capable:
-	if (!p->asCapable)
+	if (p->asCapable == NOT_CAPABLE) {
 		pr_debug("port %hu: setting asCapable", portnum(p));
-	p->asCapable = 1;
+		p->asCapable = AS_CAPABLE;
+	}
 	return 1;
 
 not_capable:
 	if (p->asCapable)
 		port_nrate_initialize(p);
-	p->asCapable = 0;
+	p->asCapable = NOT_CAPABLE;
 	return 0;
 }
 
@@ -742,6 +743,9 @@ static int port_sync_incapable(struct port *p)
 
 static int port_is_ieee8021as(struct port *p)
 {
+	if (p->asCapable == ALWAYS_CAPABLE) {
+		return 0;
+	}
 	return p->follow_up_info ? 1 : 0;
 }
 
@@ -1021,7 +1025,6 @@ static void port_nrate_initialize(struct port *p)
 
 	/* We start in the 'incapable' state. */
 	p->pdr_missing = ALLOWED_LOST_RESPONSES + 1;
-	p->asCapable = 0;
 
 	p->peer_portid_valid = 0;
 
@@ -1600,6 +1603,12 @@ int port_initialize(struct port *p)
 	p->neighborPropDelayThresh = config_get_int(cfg, p->name, "neighborPropDelayThresh");
 	p->min_neighbor_prop_delay = config_get_int(cfg, p->name, "min_neighbor_prop_delay");
 
+	if (config_get_int(cfg, p->name, "asCapable") == AS_CAPABLE_TRUE) {
+		p->asCapable = ALWAYS_CAPABLE;
+	} else {
+		p->asCapable = NOT_CAPABLE;
+	}
+
 	for (i = 0; i < N_TIMER_FDS; i++) {
 		fd[i] = -1;
 	}
diff --git a/port_private.h b/port_private.h
index 19d1d7b..91e7986 100644
--- a/port_private.h
+++ b/port_private.h
@@ -21,6 +21,7 @@
 
 #include <sys/queue.h>
 
+#include "as_capable.h"
 #include "clock.h"
 #include "fsm.h"
 #include "msg.h"
@@ -100,7 +101,7 @@ struct port {
 	struct PortIdentity portIdentity;
 	enum port_state     state; /*portState*/
 	Integer64           asymmetry;
-	int                 asCapable;
+	enum as_capable     asCapable;
 	Integer8            logMinDelayReqInterval;
 	TimeInterval        peerMeanPathDelay;
 	Integer8            logAnnounceInterval;
diff --git a/ptp4l.8 b/ptp4l.8
index d1751df..8e9b9a2 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -686,6 +686,12 @@ Check mode only check but do not set.
 Full mode set the receive filter to mark all packets with hardware time stamp,
  so all applications can get them.
 The default is normal.
+.TP
+.B asCapable
+If set to 'true', all the checks which can unset asCapable variable (as
+described in Section 10.2.4.1 of 802.1AS) are skipped. If set to 'auto',
+asCapable is initialized to 'false' and will be set to 'true' after the
+relevant checks have passed. The default value is 'auto'.
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From 83be05256b900d1d83a23ecce9d80fb7cedec865 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:50 -0700
Subject: [PATCH 013/173] Add BMCA config option.

This adds config option to specify static roles for master and slave
in the Best Master Clock Algorithm. This is the case for Automotive
Profile where networks are mostly static and role for each device is
known in advance.

masterOnly and slaveOnly will be used to determine the roles for the
devices. Since masterOnly is a per-port config and slaveOnly is a global
config option, role assignment will be slightly odd in case of bridges.
If slaveOnly is set to 1, all the ports will be in slave roles except
for the ones where masterOnly is set to 1. These ports will assume the
master role.

Two new FSMs which will be used for master and slave roles for this
config option have also been added.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 bmc.c               |  11 +++++
 config.c            |   7 +++
 configs/default.cfg |   1 +
 designated_fsm.c    | 107 ++++++++++++++++++++++++++++++++++++++++++++
 designated_fsm.h    |  43 ++++++++++++++++++
 fsm.h               |   5 +++
 makefile            |  11 ++---
 port.c              |  41 ++++++++++++++++-
 port.h              |   8 ++++
 port_private.h      |   1 +
 ptp4l.8             |  17 +++++--
 11 files changed, 241 insertions(+), 11 deletions(-)
 create mode 100644 designated_fsm.c
 create mode 100644 designated_fsm.h

diff --git a/bmc.c b/bmc.c
index 3c3db82..6ac7aa0 100644
--- a/bmc.c
+++ b/bmc.c
@@ -126,6 +126,17 @@ enum port_state bmc_state_decision(struct clock *c, struct port *r,
 	port_best = port_best_foreign(r);
 	ps = port_state(r);
 
+	/*
+	 * This scenario is particularly important in the designated_slave_fsm
+	 * when it is in PS_SLAVE state. In this scenario, there is no other
+	 * foreign master and it will elect itself as master ultimately
+	 * resulting in printing out some unnecessary warnings (see
+	 * port_slave_priority_warning()).
+	 */
+	if (!port_best && port_bmca(r) == BMCA_NOOP) {
+		return ps;
+	}
+
 	if (!port_best && PS_LISTENING == ps)
 		return ps;
 
diff --git a/config.c b/config.c
index c55bd51..78b578b 100644
--- a/config.c
+++ b/config.c
@@ -202,11 +202,18 @@ static struct config_enum as_capable_enu[] = {
 	{ NULL, 0 },
 };
 
+static struct config_enum bmca_enu[] = {
+	{ "ptp",  BMCA_PTP  },
+	{ "noop", BMCA_NOOP },
+	{ NULL, 0 },
+};
+
 struct config_item config_tab[] = {
 	PORT_ITEM_INT("announceReceiptTimeout", 3, 2, UINT8_MAX),
 	PORT_ITEM_ENU("asCapable", AS_CAPABLE_AUTO, as_capable_enu),
 	GLOB_ITEM_INT("assume_two_step", 0, 0, 1),
 	PORT_ITEM_INT("boundary_clock_jbod", 0, 0, 1),
+	PORT_ITEM_ENU("BMCA", BMCA_PTP, bmca_enu),
 	GLOB_ITEM_INT("check_fup_sync", 0, 0, 1),
 	GLOB_ITEM_INT("clockAccuracy", 0xfe, 0, UINT8_MAX),
 	GLOB_ITEM_INT("clockClass", 248, 0, UINT8_MAX),
diff --git a/configs/default.cfg b/configs/default.cfg
index d2b8c8f..de346a3 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -33,6 +33,7 @@ neighborPropDelayThresh	20000000
 masterOnly		0
 G.8275.portDS.localPriority	128
 asCapable               auto
+BMCA                    ptp
 #
 # Run time options
 #
diff --git a/designated_fsm.c b/designated_fsm.c
new file mode 100644
index 0000000..d19158b
--- /dev/null
+++ b/designated_fsm.c
@@ -0,0 +1,107 @@
+/**
+ * @file designated_fsm.c
+ * @brief Implements designated Finite State Machines.
+ * @note Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA.
+ */
+#include "fsm.h"
+#include "designated_fsm.h"
+
+enum port_state designated_master_fsm(enum port_state state,
+				      enum fsm_event event,
+				      int mdiff)
+{
+	enum port_state next = state;
+
+	if (EV_INITIALIZE == event || EV_POWERUP == event)
+		return PS_INITIALIZING;
+
+	switch (state) {
+	case PS_INITIALIZING:
+		switch (event) {
+		case EV_FAULT_DETECTED:
+			next = PS_FAULTY;
+			break;
+		case EV_INIT_COMPLETE:
+			next = PS_MASTER;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case PS_FAULTY:
+		if (event == EV_FAULT_CLEARED) {
+			next = PS_INITIALIZING;
+		}
+		break;
+
+	case PS_MASTER:
+		if (event == EV_FAULT_DETECTED) {
+			next = PS_FAULTY;
+		}
+		break;
+
+	default:
+		break;
+	}
+	return next;
+}
+
+enum port_state designated_slave_fsm(enum port_state state,
+				     enum fsm_event event,
+				     int mdiff)
+{
+	enum port_state next = state;
+
+	if (EV_INITIALIZE == event || EV_POWERUP == event)
+		return PS_INITIALIZING;
+
+	switch (state) {
+	case PS_INITIALIZING:
+		switch (event) {
+		case EV_FAULT_DETECTED:
+			next = PS_FAULTY;
+			break;
+		case EV_INIT_COMPLETE:
+			next =  PS_SLAVE;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case PS_FAULTY:
+		if (event == EV_FAULT_CLEARED) {
+			next = PS_INITIALIZING;
+		}
+		break;
+
+	case PS_SLAVE:
+		switch (event) {
+		case EV_FAULT_DETECTED:
+			next = PS_FAULTY;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+	return next;
+}
diff --git a/designated_fsm.h b/designated_fsm.h
new file mode 100644
index 0000000..b1c0eae
--- /dev/null
+++ b/designated_fsm.h
@@ -0,0 +1,43 @@
+/**
+ * @file designated_fsm.c
+ * @brief Implements designated Finite State Machines.
+ * @note Copyright (C) 2018 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA.
+ */
+#ifndef HAVE_DESIGNATED_FSM_H
+#define HAVE_DESIGNATED_FSM_H
+/**
+ * Run the state machine for a clock which is designated as master port.
+ * @param state  The current state of the port.
+ * @param event  The event to be processed.
+ * @param mdiff  This param is not used by this function.
+ * @return       The new state for the port.
+ */
+enum port_state designated_master_fsm(enum port_state state,
+				      enum fsm_event event,
+				      int mdiff);
+
+/**
+ * Run the state machine for a clock designated as slave port.
+ * @param state  The current state of the port.
+ * @param event  The event to be processed.
+ * @param mdiff  This param is not used by this function.
+ * @return       The new state for the port.
+ */
+enum port_state designated_slave_fsm(enum port_state state,
+				     enum fsm_event event,
+				     int mdiff);
+#endif
diff --git a/fsm.h b/fsm.h
index 0616daa..857af05 100644
--- a/fsm.h
+++ b/fsm.h
@@ -55,6 +55,11 @@ enum fsm_event {
 	EV_RS_PASSIVE,
 };
 
+enum bmca_select {
+	BMCA_PTP,
+	BMCA_NOOP,
+};
+
 /**
  * Run the state machine for a BC or OC port.
  * @param state  The current state of the port.
diff --git a/makefile b/makefile
index 6995e70..d09a4a9 100644
--- a/makefile
+++ b/makefile
@@ -23,11 +23,12 @@ VER     = -DVER=$(version)
 CFLAGS	= -Wall $(VER) $(incdefs) $(DEBUG) $(EXTRA_CFLAGS)
 LDLIBS	= -lm -lrt $(EXTRA_LDFLAGS)
 PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster
-OBJ     = bmc.o clock.o clockadj.o clockcheck.o config.o e2e_tc.o fault.o \
- filter.o fsm.o hash.o linreg.o mave.o mmedian.o msg.o ntpshm.o nullf.o phc.o \
- pi.o port.o port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o raw.o rtnl.o \
- servo.o sk.o stats.o tc.o telecom.o tlv.o transport.o tsproc.o udp.o udp6.o \
- uds.o unicast_client.o unicast_fsm.o unicast_service.o util.o version.o
+OBJ     = bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
+e2e_tc.o fault.o filter.o fsm.o hash.o linreg.o mave.o mmedian.o msg.o ntpshm.o \
+nullf.o phc.o pi.o port.o port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o \
+raw.o rtnl.o servo.o sk.o stats.o tc.o telecom.o tlv.o transport.o tsproc.o \
+udp.o udp6.o uds.o unicast_client.o unicast_fsm.o unicast_service.o util.o \
+version.o
 
 OBJECTS	= $(OBJ) hwstamp_ctl.o nsm.o phc2sys.o phc_ctl.o pmc.o pmc_common.o \
  sysoff.o timemaster.o
diff --git a/port.c b/port.c
index cd87553..96e536f 100644
--- a/port.c
+++ b/port.c
@@ -27,6 +27,7 @@
 
 #include "bmc.h"
 #include "clock.h"
+#include "designated_fsm.h"
 #include "filter.h"
 #include "missing.h"
 #include "msg.h"
@@ -1596,7 +1597,6 @@ int port_initialize(struct port *p)
 	p->transportSpecific       = config_get_int(cfg, p->name, "transportSpecific");
 	p->transportSpecific     <<= 4;
 	p->match_transport_specific = !config_get_int(cfg, p->name, "ignore_transport_specific");
-	p->master_only             = config_get_int(cfg, p->name, "masterOnly");
 	p->localPriority           = config_get_int(cfg, p->name, "G.8275.portDS.localPriority");
 	p->logSyncInterval         = config_get_int(cfg, p->name, "logSyncInterval");
 	p->logMinPdelayReqInterval = config_get_int(cfg, p->name, "logMinPdelayReqInterval");
@@ -1635,6 +1635,14 @@ int port_initialize(struct port *p)
 
 	/* No need to open rtnl socket on UDS port. */
 	if (transport_type(p->trp) != TRANS_UDS) {
+		/*
+		 * The delay timer is usually started when the device
+		 * transitions to PS_LISTENING. But, we are skipping the state
+		 * when BMCA == 'noop'. So, start the timer here.
+		 */
+		if (p->bmca == BMCA_NOOP) {
+			port_set_delay_tmo(p);
+		}
 		if (p->fda.fd[FD_RTNL] == -1)
 			p->fda.fd[FD_RTNL] = rtnl_open();
 		if (p->fda.fd[FD_RTNL] >= 0)
@@ -2469,6 +2477,16 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 		if (p->best)
 			fc_clear(p->best);
 		port_set_announce_tmo(p);
+
+		/*
+		 * Clear out the event returned by poll(). It is only cleared
+		 * in port_*_transition(). But, when BMCA == 'noop', there is no
+		 * state transition. So, it won't be cleared anywhere else.
+		 */
+		if (p->bmca == BMCA_NOOP) {
+			port_clr_tmo(p->fda.fd[FD_SYNC_RX_TIMER]);
+		}
+
 		delay_req_prune(p);
 		if (clock_slave_only(p->clock) && p->delayMechanism != DM_P2P &&
 		    port_renew_transport(p)) {
@@ -2859,10 +2877,24 @@ struct port *port_open(int phc_index,
 		goto err_port;
 	}
 
-	p->state_machine = clock_slave_only(clock) ? ptp_slave_fsm : ptp_fsm;
 	p->phc_index = phc_index;
 	p->jbod = config_get_int(cfg, interface->name, "boundary_clock_jbod");
 	transport = config_get_int(cfg, interface->name, "network_transport");
+	p->master_only = config_get_int(cfg, p->name, "masterOnly");
+	p->bmca = config_get_int(cfg, p->name, "BMCA");
+
+	if (p->bmca == BMCA_NOOP && transport != TRANS_UDS) {
+		if (p->master_only) {
+			p->state_machine = designated_master_fsm;
+		} else if (clock_slave_only(clock)) {
+			p->state_machine = designated_slave_fsm;
+		} else {
+			pr_err("Please enable at least one of masterOnly or slaveOnly when BMCA == noop.\n");
+			goto err_port;
+		}
+	} else {
+		p->state_machine = clock_slave_only(clock) ? ptp_slave_fsm : ptp_fsm;
+	}
 
 	if (transport == TRANS_UDS) {
 		; /* UDS cannot have a PHC. */
@@ -3020,3 +3052,8 @@ int port_state_update(struct port *p, enum fsm_event event, int mdiff)
 
 	return 0;
 }
+
+enum bmca_select port_bmca(struct port *p)
+{
+	return p->bmca;
+}
diff --git a/port.h b/port.h
index 9639193..aa3b1ec 100644
--- a/port.h
+++ b/port.h
@@ -322,6 +322,14 @@ enum fault_type last_fault_type(struct port *port);
 void fault_interval(struct port *port, enum fault_type ft,
 		    struct fault_interval *i);
 
+/**
+ * Obtain the BMCA type of the port.
+ *
+ * @param port        A port instance.
+ * @return            bmca type.
+ */
+enum bmca_select port_bmca(struct port *p);
+
 /**
  * Release all of the memory in the TC transmit descriptor cache.
  */
diff --git a/port_private.h b/port_private.h
index 91e7986..4b22976 100644
--- a/port_private.h
+++ b/port_private.h
@@ -97,6 +97,7 @@ struct port {
 	unsigned int multiple_pdr_detected;
 	enum port_state (*state_machine)(enum port_state state,
 					 enum fsm_event event, int mdiff);
+	int bmca;
 	/* portDS */
 	struct PortIdentity portIdentity;
 	enum port_state     state; /*portState*/
diff --git a/ptp4l.8 b/ptp4l.8
index 8e9b9a2..a4a31a3 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -363,10 +363,7 @@ hardware time stamping.
 The default is 1 (enabled).
 .TP
 .B slaveOnly
-The local clock is a slave-only clock if enabled.
-This option is only for use with 1588 clocks and should not be enabled
-for 802.1AS clocks.
-The default is 0 (disabled).
+The local clock is a slave-only clock if enabled. The default is 0 (disabled).
 .TP
 .B gmCapable
 If this option is enabled, then the local clock is able to become grand master.
@@ -692,6 +689,18 @@ If set to 'true', all the checks which can unset asCapable variable (as
 described in Section 10.2.4.1 of 802.1AS) are skipped. If set to 'auto',
 asCapable is initialized to 'false' and will be set to 'true' after the
 relevant checks have passed. The default value is 'auto'.
+.TP
+.B BMCA
+This option enables use of static roles for master and slave devices instead of
+running the best master clock algorithm (BMCA) described in 1588 profile. This
+is useful when you know the roles of the devices in advance. When set to
+\'noop', the traditional BMCA algorithm used by 1588 is skipped. masterOnly and
+slaveOnly will be used to determine master or slave role for the device. In a
+bridge, slaveOnly (which is a global option) can be set to make all ports
+assume the slave role. masterOnly (which is a per-port config option) can then
+be used to set individual ports to take master role. BMCA is used in the
+Automotive profile to speed up the start time for grand master and slaves. The
+default value is 'ptp' which runs the BMCA related state machines.
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From 1cbeec80cd7b2f170a02d9fa6b071345645477ca Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:51 -0700
Subject: [PATCH 014/173] Add inhibit_announce config option.

This option will accomplish 2 things. On the master, it will stop the
announce messages being sent (by disabling FD_MANNO_TIMER timer). On
slave, it will not configure announce message timeouts (by disabling
FD_ANNOUNCE_TIMEOUT timer).

This config option is needed for the Automotive profile as part of
skipping the Best Master Clock Algorithm (BMCA).

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 config.c            |  1 +
 configs/default.cfg |  1 +
 port.c              | 19 +++++++++++++++----
 port_private.h      |  1 +
 ptp4l.8             |  8 ++++++++
 5 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/config.c b/config.c
index 78b578b..a018066 100644
--- a/config.c
+++ b/config.c
@@ -242,6 +242,7 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("hybrid_e2e", 0, 0, 1),
 	PORT_ITEM_INT("ignore_transport_specific", 0, 0, 1),
 	PORT_ITEM_INT("ingressLatency", 0, INT_MIN, INT_MAX),
+	PORT_ITEM_INT("inhibit_announce", 0, 0, 1),
 	PORT_ITEM_INT("inhibit_multicast_service", 0, 0, 1),
 	GLOB_ITEM_INT("initial_delay", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("kernel_leap", 1, 0, 1),
diff --git a/configs/default.cfg b/configs/default.cfg
index de346a3..b791ea3 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -34,6 +34,7 @@ masterOnly		0
 G.8275.portDS.localPriority	128
 asCapable               auto
 BMCA                    ptp
+inhibit_announce        0
 #
 # Run time options
 #
diff --git a/port.c b/port.c
index 96e536f..bf6860c 100644
--- a/port.c
+++ b/port.c
@@ -1592,6 +1592,7 @@ int port_initialize(struct port *p)
 	p->logMinDelayReqInterval  = config_get_int(cfg, p->name, "logMinDelayReqInterval");
 	p->peerMeanPathDelay       = 0;
 	p->logAnnounceInterval     = config_get_int(cfg, p->name, "logAnnounceInterval");
+	p->inhibit_announce        = config_get_int(cfg, p->name, "inhibit_announce");
 	p->announceReceiptTimeout  = config_get_int(cfg, p->name, "announceReceiptTimeout");
 	p->syncReceiptTimeout      = config_get_int(cfg, p->name, "syncReceiptTimeout");
 	p->transportSpecific       = config_get_int(cfg, p->name, "transportSpecific");
@@ -2310,7 +2311,9 @@ static void port_e2e_transition(struct port *p, enum port_state next)
 		break;
 	case PS_MASTER:
 	case PS_GRAND_MASTER:
-		set_tmo_log(p->fda.fd[FD_MANNO_TIMER], 1, -10); /*~1ms*/
+		if (!p->inhibit_announce) {
+			set_tmo_log(p->fda.fd[FD_MANNO_TIMER], 1, -10); /*~1ms*/
+		}
 		port_set_sync_tx_tmo(p);
 		break;
 	case PS_PASSIVE:
@@ -2353,7 +2356,9 @@ static void port_p2p_transition(struct port *p, enum port_state next)
 		break;
 	case PS_MASTER:
 	case PS_GRAND_MASTER:
-		set_tmo_log(p->fda.fd[FD_MANNO_TIMER], 1, -10); /*~1ms*/
+		if (!p->inhibit_announce) {
+			set_tmo_log(p->fda.fd[FD_MANNO_TIMER], 1, -10); /*~1ms*/
+		}
 		port_set_sync_tx_tmo(p);
 		break;
 	case PS_PASSIVE:
@@ -2474,9 +2479,9 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 	case FD_SYNC_RX_TIMER:
 		pr_debug("port %hu: %s timeout", portnum(p),
 			 fd_index == FD_SYNC_RX_TIMER ? "rx sync" : "announce");
-		if (p->best)
+		if (p->best) {
 			fc_clear(p->best);
-		port_set_announce_tmo(p);
+		}
 
 		/*
 		 * Clear out the event returned by poll(). It is only cleared
@@ -2487,6 +2492,12 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 			port_clr_tmo(p->fda.fd[FD_SYNC_RX_TIMER]);
 		}
 
+		if (p->inhibit_announce) {
+			port_clr_tmo(p->fda.fd[FD_ANNOUNCE_TIMER]);
+		} else {
+			port_set_announce_tmo(p);
+		}
+
 		delay_req_prune(p);
 		if (clock_slave_only(p->clock) && p->delayMechanism != DM_P2P &&
 		    port_renew_transport(p)) {
diff --git a/port_private.h b/port_private.h
index 4b22976..ca3c906 100644
--- a/port_private.h
+++ b/port_private.h
@@ -98,6 +98,7 @@ struct port {
 	enum port_state (*state_machine)(enum port_state state,
 					 enum fsm_event event, int mdiff);
 	int bmca;
+	int inhibit_announce;
 	/* portDS */
 	struct PortIdentity portIdentity;
 	enum port_state     state; /*portState*/
diff --git a/ptp4l.8 b/ptp4l.8
index a4a31a3..d4133a8 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -701,6 +701,14 @@ assume the slave role. masterOnly (which is a per-port config option) can then
 be used to set individual ports to take master role. BMCA is used in the
 Automotive profile to speed up the start time for grand master and slaves. The
 default value is 'ptp' which runs the BMCA related state machines.
+.TP
+.B inhibit_announce
+This will disable the timer for announce messages (i.e. FD_MANNO_TIMER) and
+also the announce message timeout timer (i.e. FD_ANNOUNCE_TIMER). This is used
+by the Automotive profile as part of switching over to a static BMCA. if this
+option is enabled, ignore_source_id has to be enabled in the slave because it
+has no way to identify master identity in Sync and Follow_Up messages. The
+default is 0 (disabled).
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From d58b1080bce54c60cd4375d74d32688c9e289491 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:52 -0700
Subject: [PATCH 015/173] Add ignore_source_id config option.

This config option will skip the source port identity verification in
the Sync and Follow_up messages. This option is needed when the announce
messages are disabled because the slave cannot know the identity of
master without announce messages.

This is required by Automotive Profile as part of skipping the Best
Master Clock Algorithm (BMCA).

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 config.c            |  1 +
 configs/default.cfg |  1 +
 port.c              | 22 ++++++++++++++++------
 port_private.h      |  1 +
 ptp4l.8             |  6 ++++++
 5 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/config.c b/config.c
index a018066..2321310 100644
--- a/config.c
+++ b/config.c
@@ -240,6 +240,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("gmCapable", 1, 0, 1),
 	GLOB_ITEM_ENU("hwts_filter", HWTS_FILTER_NORMAL, hwts_filter_enu),
 	PORT_ITEM_INT("hybrid_e2e", 0, 0, 1),
+	PORT_ITEM_INT("ignore_source_id", 0, 0, 1),
 	PORT_ITEM_INT("ignore_transport_specific", 0, 0, 1),
 	PORT_ITEM_INT("ingressLatency", 0, INT_MIN, INT_MAX),
 	PORT_ITEM_INT("inhibit_announce", 0, 0, 1),
diff --git a/configs/default.cfg b/configs/default.cfg
index b791ea3..3ee3a9b 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -35,6 +35,7 @@ G.8275.portDS.localPriority	128
 asCapable               auto
 BMCA                    ptp
 inhibit_announce        0
+ignore_source_id        0
 #
 # Run time options
 #
diff --git a/port.c b/port.c
index bf6860c..3e61179 100644
--- a/port.c
+++ b/port.c
@@ -1593,6 +1593,7 @@ int port_initialize(struct port *p)
 	p->peerMeanPathDelay       = 0;
 	p->logAnnounceInterval     = config_get_int(cfg, p->name, "logAnnounceInterval");
 	p->inhibit_announce        = config_get_int(cfg, p->name, "inhibit_announce");
+	p->ignore_source_id        = config_get_int(cfg, p->name, "ignore_source_id");
 	p->announceReceiptTimeout  = config_get_int(cfg, p->name, "announceReceiptTimeout");
 	p->syncReceiptTimeout      = config_get_int(cfg, p->name, "syncReceiptTimeout");
 	p->transportSpecific       = config_get_int(cfg, p->name, "transportSpecific");
@@ -1877,10 +1878,20 @@ void process_delay_resp(struct port *p, struct ptp_message *m)
 	port_set_delay_tmo(p);
 }
 
+static int check_source_identity(struct port *p, struct ptp_message *m)
+{
+	struct PortIdentity master;
+
+	if (p->ignore_source_id) {
+		return 0;
+	}
+	master = clock_parent_identity(p->clock);
+	return pid_eq(&master, &m->header.sourcePortIdentity) ? 0 : -1;
+}
+
 void process_follow_up(struct port *p, struct ptp_message *m)
 {
 	enum syfu_event event;
-	struct PortIdentity master;
 	switch (p->state) {
 	case PS_INITIALIZING:
 	case PS_FAULTY:
@@ -1895,8 +1906,8 @@ void process_follow_up(struct port *p, struct ptp_message *m)
 	case PS_SLAVE:
 		break;
 	}
-	master = clock_parent_identity(p->clock);
-	if (!pid_eq(&master, &m->header.sourcePortIdentity)) {
+
+	if (check_source_identity(p, m)) {
 		return;
 	}
 
@@ -2185,7 +2196,6 @@ void process_pdelay_resp_fup(struct port *p, struct ptp_message *m)
 void process_sync(struct port *p, struct ptp_message *m)
 {
 	enum syfu_event event;
-	struct PortIdentity master;
 	switch (p->state) {
 	case PS_INITIALIZING:
 	case PS_FAULTY:
@@ -2200,8 +2210,8 @@ void process_sync(struct port *p, struct ptp_message *m)
 	case PS_SLAVE:
 		break;
 	}
-	master = clock_parent_identity(p->clock);
-	if (!pid_eq(&master, &m->header.sourcePortIdentity)) {
+
+	if (check_source_identity(p, m)) {
 		return;
 	}
 
diff --git a/port_private.h b/port_private.h
index ca3c906..593eb76 100644
--- a/port_private.h
+++ b/port_private.h
@@ -99,6 +99,7 @@ struct port {
 					 enum fsm_event event, int mdiff);
 	int bmca;
 	int inhibit_announce;
+	int ignore_source_id;
 	/* portDS */
 	struct PortIdentity portIdentity;
 	enum port_state     state; /*portState*/
diff --git a/ptp4l.8 b/ptp4l.8
index d4133a8..99b085c 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -709,6 +709,12 @@ by the Automotive profile as part of switching over to a static BMCA. if this
 option is enabled, ignore_source_id has to be enabled in the slave because it
 has no way to identify master identity in Sync and Follow_Up messages. The
 default is 0 (disabled).
+.TP
+.B ignore_source_id
+This will disable source port identity checking for Sync and Follow_Up
+messages. This is useful when the announce messages are disabled in the master
+and the slave does not have any way to know it's identity. The default is 0
+(disabled).
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From 4d251d8358e9464c001e5e623a6f35bca4791786 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 3 Oct 2018 09:41:53 -0700
Subject: [PATCH 016/173] Add example configuration for Automotive Profile.

This commit adds example for configuring master and slave devices that
support features from the Automotive Profile.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 configs/automotive-master.cfg | 28 ++++++++++++++++++++++++++++
 configs/automotive-slave.cfg  | 33 +++++++++++++++++++++++++++++++++
 2 files changed, 61 insertions(+)
 create mode 100644 configs/automotive-master.cfg
 create mode 100644 configs/automotive-slave.cfg

diff --git a/configs/automotive-master.cfg b/configs/automotive-master.cfg
new file mode 100644
index 0000000..e3ad5a3
--- /dev/null
+++ b/configs/automotive-master.cfg
@@ -0,0 +1,28 @@
+#
+# Automotive Profile example configuration for master containing those
+# attributes which differ from the defaults.  See the file, default.cfg, for
+# the complete list of available options.
+#
+[global]
+# Options carried over from gPTP.
+gmCapable		1
+priority1		248
+priority2		248
+logSyncInterval		-3
+syncReceiptTimeout	3
+neighborPropDelayThresh	800
+min_neighbor_prop_delay	-20000000
+assume_two_step		1
+path_trace_enabled	1
+follow_up_info		1
+transportSpecific	0x1
+ptp_dst_mac		01:80:C2:00:00:0E
+network_transport	L2
+delay_mechanism		P2P
+#
+# Automotive Profile specific options
+#
+BMCA			noop
+masterOnly		1
+inhibit_announce	1
+asCapable               true
diff --git a/configs/automotive-slave.cfg b/configs/automotive-slave.cfg
new file mode 100644
index 0000000..94d45b6
--- /dev/null
+++ b/configs/automotive-slave.cfg
@@ -0,0 +1,33 @@
+#
+# Automotive Profile example configuration for slaves containing those
+# attributes which differ from the defaults.  See the file, default.cfg, for
+# the complete list of available options.
+#
+[global]
+#
+# Options carried over from gPTP.
+#
+gmCapable		1
+priority1		248
+priority2		248
+logSyncInterval		-3
+syncReceiptTimeout	3
+neighborPropDelayThresh	800
+min_neighbor_prop_delay	-20000000
+assume_two_step		1
+path_trace_enabled	1
+follow_up_info		1
+transportSpecific	0x1
+ptp_dst_mac		01:80:C2:00:00:0E
+network_transport	L2
+delay_mechanism		P2P
+#
+# Automotive Profile specific options
+#
+BMCA			noop
+slaveOnly		1
+inhibit_announce	1
+asCapable               true
+ignore_source_id	1
+# Required to quickly correct Time Jumps in master
+step_threshold          1
-- 
2.17.1


From 8f2f9bbcabd2f0381dc7dcbc9d947e0178c71d6b Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Wed, 10 Oct 2018 11:01:14 +0000
Subject: [PATCH 017/173] port: correction of port name used port_open

Correction of fault introduced in "Add BMCA config option."

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
Reviewed-by: Vedang Patel <vedang.patel@intel.com>
---
 port.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/port.c b/port.c
index 3e61179..142b970 100644
--- a/port.c
+++ b/port.c
@@ -2901,8 +2901,8 @@ struct port *port_open(int phc_index,
 	p->phc_index = phc_index;
 	p->jbod = config_get_int(cfg, interface->name, "boundary_clock_jbod");
 	transport = config_get_int(cfg, interface->name, "network_transport");
-	p->master_only = config_get_int(cfg, p->name, "masterOnly");
-	p->bmca = config_get_int(cfg, p->name, "BMCA");
+	p->master_only = config_get_int(cfg, interface->name, "masterOnly");
+	p->bmca = config_get_int(cfg, interface->name, "BMCA");
 
 	if (p->bmca == BMCA_NOOP && transport != TRANS_UDS) {
 		if (p->master_only) {
-- 
2.17.1


From d88b4ff2298b9b6588e03fe94c2e7c0263fb4750 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Tue, 23 Oct 2018 12:09:47 +0000
Subject: [PATCH 018/173] util: Added IPv6 support in help funtions addreq and
 str2addr

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 util.c | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/util.c b/util.c
index c617510..9ad23e0 100644
--- a/util.c
+++ b/util.c
@@ -80,13 +80,17 @@ int addreq(enum transport_type type, struct address *a, struct address *b)
 		bufb = &b->sin.sin_addr;
 		len = sizeof(a->sin);
 		break;
+	case TRANS_UDP_IPV6:
+		bufa = &a->sin6.sin6_addr;
+		bufb = &b->sin6.sin6_addr;
+		len = sizeof(a->sin6);
+		break;
 	case TRANS_IEEE_802_3:
 		bufa = &a->sll.sll_addr;
 		bufb = &b->sll.sll_addr;
 		len = MAC_LEN;
 		break;
 	case TRANS_UDS:
-	case TRANS_UDP_IPV6:
 	case TRANS_DEVICENET:
 	case TRANS_CONTROLNET:
 	case TRANS_PROFINET:
@@ -171,12 +175,12 @@ int str2addr(enum transport_type type, const char *s, struct address *addr)
 {
 	unsigned char mac[MAC_LEN];
 	struct in_addr ipv4_addr;
+	struct in6_addr ipv6_addr;
 
 	memset(addr, 0, sizeof(*addr));
 
 	switch (type) {
 	case TRANS_UDS:
-	case TRANS_UDP_IPV6:
 	case TRANS_DEVICENET:
 	case TRANS_CONTROLNET:
 	case TRANS_PROFINET:
@@ -191,6 +195,15 @@ int str2addr(enum transport_type type, const char *s, struct address *addr)
 		addr->sin.sin_addr = ipv4_addr;
 		addr->len = sizeof(addr->sin);
 		break;
+	case TRANS_UDP_IPV6:
+		if (1 != inet_pton(AF_INET6, s, &ipv6_addr)) {
+			pr_err("bad IPv6 address");
+			return -1;
+		}
+		addr->sin6.sin6_family = AF_INET6;
+		addr->sin6.sin6_addr = ipv6_addr;
+		addr->len = sizeof(addr->sin6);
+		break;
 	case TRANS_IEEE_802_3:
 		if (str2mac(s, mac)) {
 			pr_err("bad Layer-2 address");
-- 
2.17.1


From 80b1d25dfd6cfc1ad24fec1d2adee7aa6dead6f7 Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Wed, 24 Oct 2018 13:07:06 +0000
Subject: [PATCH 019/173] sk: Added address family as inargument in
 sk_set_priority

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 sk.c   | 21 +++++++++++++++++----
 sk.h   |  7 ++++---
 udp.c  |  4 ++--
 udp6.c |  4 ++--
 4 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/sk.c b/sk.c
index 43f1800..e2b1f28 100644
--- a/sk.c
+++ b/sk.c
@@ -406,13 +406,26 @@ int sk_receive(int fd, void *buf, int buflen,
 	return cnt;
 }
 
-int sk_set_priority(int fd, uint8_t dscp)
+int sk_set_priority(int fd, int family, uint8_t dscp)
 {
-	int tos;
+	int level, optname, tos;
 	socklen_t tos_len;
 
+	switch (family) {
+	case AF_INET:
+		level = IPPROTO_IP;
+		optname = IP_TOS;
+		break;
+	case AF_INET6:
+		level = IPPROTO_IPV6;
+		optname = IPV6_TCLASS;
+		break;
+	default:
+		return -1;
+	}
+
 	tos_len = sizeof(tos);
-	if (getsockopt(fd, SOL_IP, IP_TOS, &tos, &tos_len) < 0) {
+	if (getsockopt(fd, level, optname, &tos, &tos_len) < 0) {
 		tos = 0;
 	}
 
@@ -422,7 +435,7 @@ int sk_set_priority(int fd, uint8_t dscp)
 	/* set new DSCP value */
 	tos |= dscp<<2;
 	tos_len = sizeof(tos);
-	if (setsockopt(fd, SOL_IP, IP_TOS, &tos, tos_len) < 0) {
+	if (setsockopt(fd, level, optname, &tos, tos_len) < 0) {
 		return -1;
 	}
 
diff --git a/sk.h b/sk.h
index fd4d820..04d26ee 100644
--- a/sk.h
+++ b/sk.h
@@ -111,11 +111,12 @@ int sk_receive(int fd, void *buf, int buflen,
 
 /**
  * Set DSCP value for socket.
- * @param fd    An open socket.
- * @param dscp  The desired DSCP code.
+ * @param fd     An open socket.
+ * @param family The address family in use: AF_INET or AF_INET6
+ * @param dscp   The desired DSCP code.
  * @return Zero on success, negative on failure
  */
-int sk_set_priority(int fd, uint8_t dscp);
+int sk_set_priority(int fd, int family, uint8_t dscp);
 
 /**
  * Enable time stamping on a given network interface.
diff --git a/udp.c b/udp.c
index 62b5c72..48af482 100644
--- a/udp.c
+++ b/udp.c
@@ -188,10 +188,10 @@ static int udp_open(struct transport *t, struct interface *iface,
 	event_dscp = config_get_int(t->cfg, NULL, "dscp_event");
 	general_dscp = config_get_int(t->cfg, NULL, "dscp_general");
 
-	if (event_dscp && sk_set_priority(efd, event_dscp)) {
+	if (event_dscp && sk_set_priority(efd, AF_INET, event_dscp)) {
 		pr_warning("Failed to set event DSCP priority.");
 	}
-	if (general_dscp && sk_set_priority(gfd, general_dscp)) {
+	if (general_dscp && sk_set_priority(gfd, AF_INET, general_dscp)) {
 		pr_warning("Failed to set general DSCP priority.");
 	}
 
diff --git a/udp6.c b/udp6.c
index d3c9c86..908f307 100644
--- a/udp6.c
+++ b/udp6.c
@@ -199,10 +199,10 @@ static int udp6_open(struct transport *t, struct interface *iface,
 	event_dscp = config_get_int(t->cfg, NULL, "dscp_event");
 	general_dscp = config_get_int(t->cfg, NULL, "dscp_general");
 
-	if (event_dscp && sk_set_priority(efd, event_dscp)) {
+	if (event_dscp && sk_set_priority(efd, AF_INET6, event_dscp)) {
 		pr_warning("Failed to set event DSCP priority.");
 	}
-	if (general_dscp && sk_set_priority(gfd, general_dscp)) {
+	if (general_dscp && sk_set_priority(gfd, AF_INET6, general_dscp)) {
 		pr_warning("Failed to set general DSCP priority.");
 	}
 
-- 
2.17.1


From 2c3a501fc34ff519e0418b821f47d68b1becd216 Mon Sep 17 00:00:00 2001
From: Cliff Spradlin via Linuxptp-devel <linuxptp-devel@lists.sourceforge.net>
Date: Tue, 30 Oct 2018 12:26:46 -0700
Subject: [PATCH 020/173] Use llabs() instead of fabs() for integers.

Change-Id: I64cf1d4e1728c31ced40aff865d66b5b4356560f
Signed-off-by: Cliff Spradlin <cspradlin@google.com>
---
 nullf.c | 4 ++--
 pi.c    | 6 +++---
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/nullf.c b/nullf.c
index 5512837..9a40d07 100644
--- a/nullf.c
+++ b/nullf.c
@@ -44,8 +44,8 @@ static double nullf_sample(struct servo *servo, int64_t offset,
 	}
 
 	if ((servo->first_update && servo->first_step_threshold &&
-	     servo->first_step_threshold < fabs(offset)) ||
-	    (servo->step_threshold && servo->step_threshold < fabs(offset))) {
+	     servo->first_step_threshold < llabs(offset)) ||
+	    (servo->step_threshold && servo->step_threshold < llabs(offset))) {
 		*state = SERVO_JUMP;
 	} else {
 		*state = SERVO_UNLOCKED;
diff --git a/pi.c b/pi.c
index 35556e1..bfe5022 100644
--- a/pi.c
+++ b/pi.c
@@ -112,9 +112,9 @@ static double pi_sample(struct servo *servo,
 
 		if ((servo->first_update &&
 		     servo->first_step_threshold &&
-		     servo->first_step_threshold < fabs(offset)) ||
+		     servo->first_step_threshold < llabs(offset)) ||
 		    (servo->step_threshold &&
-		     servo->step_threshold < fabs(offset)))
+		     servo->step_threshold < llabs(offset)))
 			*state = SERVO_JUMP;
 		else
 			*state = SERVO_LOCKED;
@@ -131,7 +131,7 @@ static double pi_sample(struct servo *servo,
 		 * clock startup.
 		 */
 		if (servo->step_threshold &&
-		    servo->step_threshold < fabs(offset)) {
+		    servo->step_threshold < llabs(offset)) {
 			*state = SERVO_UNLOCKED;
 			s->count = 0;
 			break;
-- 
2.17.1


From e27cc2d8a8bc1d8735f2a1ee35f09333156239b8 Mon Sep 17 00:00:00 2001
From: Cliff Spradlin via Linuxptp-devel <linuxptp-devel@lists.sourceforge.net>
Date: Tue, 30 Oct 2018 14:38:54 -0700
Subject: [PATCH 021/173] Include missing headers.

Signed-off-by: Cliff Spradlin <cspradlin@google.com>
Change-Id: If0fd08df74e1cf108978266cd77768df4b49fb1f
---
 designated_fsm.h | 3 +++
 servo_private.h  | 3 +++
 2 files changed, 6 insertions(+)

diff --git a/designated_fsm.h b/designated_fsm.h
index b1c0eae..8ffa1a3 100644
--- a/designated_fsm.h
+++ b/designated_fsm.h
@@ -19,6 +19,9 @@
  */
 #ifndef HAVE_DESIGNATED_FSM_H
 #define HAVE_DESIGNATED_FSM_H
+
+#include "fsm.h"
+
 /**
  * Run the state machine for a clock which is designated as master port.
  * @param state  The current state of the port.
diff --git a/servo_private.h b/servo_private.h
index b8c3c98..1c5cfdf 100644
--- a/servo_private.h
+++ b/servo_private.h
@@ -19,7 +19,10 @@
 #ifndef HAVE_SERVO_PRIVATE_H
 #define HAVE_SERVO_PRIVATE_H
 
+#include <stdint.h>
+
 #include "contain.h"
+#include "servo.h"
 
 struct servo {
 	double max_frequency;
-- 
2.17.1


From 563c52b833b3c5d810b80422d13205fcae1f13dd Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 6 Jan 2019 14:15:56 -0800
Subject: [PATCH 022/173] Allow ignoring source port identity in end to end
 mode.

The "inhibit_announce" and "ignore_source_id" options were introduced
in order to support the automotive profile.  That profile happens to
specify using the peer to peer delay mechanism, but there is no reason
to restrict them to that mechanism.  As it now stands, enabling these
two options prevents E2E slaves from synchronizing.  This patch fixes
the issue by checking the "ignore_source_id" option when accepting E2E
delay response messages.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 27 ++++++++++++---------------
 1 file changed, 12 insertions(+), 15 deletions(-)

diff --git a/port.c b/port.c
index 142b970..a52510a 100644
--- a/port.c
+++ b/port.c
@@ -99,6 +99,17 @@ int clear_fault_asap(struct fault_interval *faint)
 	return 0;
 }
 
+static int check_source_identity(struct port *p, struct ptp_message *m)
+{
+	struct PortIdentity master;
+
+	if (p->ignore_source_id) {
+		return 0;
+	}
+	master = clock_parent_identity(p->clock);
+	return pid_eq(&master, &m->header.sourcePortIdentity) ? 0 : -1;
+}
+
 static void extract_address(struct ptp_message *m, struct PortAddress *paddr)
 {
 	int len = 0;
@@ -1825,19 +1836,16 @@ out:
 void process_delay_resp(struct port *p, struct ptp_message *m)
 {
 	struct delay_resp_msg *rsp = &m->delay_resp;
-	struct PortIdentity master;
 	struct ptp_message *req;
 	tmv_t c3, t3, t4, t4c;
 
-	master = clock_parent_identity(p->clock);
-
 	if (p->state != PS_UNCALIBRATED && p->state != PS_SLAVE) {
 		return;
 	}
 	if (!pid_eq(&rsp->requestingPortIdentity, &p->portIdentity)) {
 		return;
 	}
-	if (!pid_eq(&master, &m->header.sourcePortIdentity)) {
+	if (check_source_identity(p, m)) {
 		return;
 	}
 	TAILQ_FOREACH(req, &p->delay_req, list) {
@@ -1878,17 +1886,6 @@ void process_delay_resp(struct port *p, struct ptp_message *m)
 	port_set_delay_tmo(p);
 }
 
-static int check_source_identity(struct port *p, struct ptp_message *m)
-{
-	struct PortIdentity master;
-
-	if (p->ignore_source_id) {
-		return 0;
-	}
-	master = clock_parent_identity(p->clock);
-	return pid_eq(&master, &m->header.sourcePortIdentity) ? 0 : -1;
-}
-
 void process_follow_up(struct port *p, struct ptp_message *m)
 {
 	enum syfu_event event;
-- 
2.17.1


From d1ce07d5cbbff73303c8544020dd1c1b30aee135 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Wed, 14 Nov 2018 14:10:04 -0800
Subject: [PATCH 023/173] port: Fix for inhibit_announce.

When inhibit_announce is set, ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES event is
still sent once every state change. Avoid this by explicitly sending
EV_NONE instead.

[ RC - Simplify and keep all of the timer's state maintenance. ]

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/port.c b/port.c
index a52510a..428326e 100644
--- a/port.c
+++ b/port.c
@@ -2510,6 +2510,10 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 		    port_renew_transport(p)) {
 			return EV_FAULT_DETECTED;
 		}
+
+		if (p->inhibit_announce) {
+			return EV_NONE;
+		}
 		return EV_ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES;
 
 	case FD_DELAY_TIMER:
-- 
2.17.1


From a5da8c4b71dee314ed0f199e820f66b6c3df437a Mon Sep 17 00:00:00 2001
From: Dimitrios Katsaros <patcherwork@gmail.com>
Date: Thu, 8 Nov 2018 15:05:12 +0100
Subject: [PATCH 024/173] Added support for opening POSIX clock devices

I have reduced the requirements for the -p option to accept
any type of device. With this it should be possible to use
ptp4l to syncronize any clock device that implements the kernel
POSIX clock interface.

[ RC - Initialize struct timex. ]

Signed-off-by: Dimitrios Katsaros <patcherwork@gmail.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c    | 11 +++++++++--
 clockadj.c | 43 +++++++++++++++++++++++++------------------
 clockadj.h |  6 ++++++
 phc.c      | 21 +++++++++++++++------
 phc.h      |  2 +-
 ptp4l.c    |  2 +-
 6 files changed, 57 insertions(+), 28 deletions(-)

diff --git a/clock.c b/clock.c
index 56bc79b..9c493c3 100644
--- a/clock.c
+++ b/clock.c
@@ -979,8 +979,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		phc_index = -1;
 	} else if (phc_device) {
 		if (1 != sscanf(phc_device, "/dev/ptp%d", &phc_index)) {
-			pr_err("bad ptp device string");
-			return NULL;
+			phc_index = -1;
 		}
 	} else if (iface->ts_info.valid) {
 		phc_index = iface->ts_info.phc_index;
@@ -1053,6 +1052,14 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 			return NULL;
 		}
 		clockadj_init(c->clkid);
+	} else if (phc_device) {
+		c->clkid = phc_open(phc_device);
+		if (c->clkid == CLOCK_INVALID) {
+			pr_err("Failed to open %s: %m", phc_device);
+			return NULL;
+		}
+		max_adj = clockadj_max_freq(c->clkid);
+		clockadj_init(c->clkid);
 	} else {
 		c->clkid = CLOCK_REALTIME;
 		c->utc_timescale = 1;
diff --git a/clockadj.c b/clockadj.c
index 86c7b33..0485d8c 100644
--- a/clockadj.c
+++ b/clockadj.c
@@ -103,6 +103,30 @@ void clockadj_step(clockid_t clkid, int64_t step)
 		pr_err("failed to step clock: %m");
 }
 
+int clockadj_max_freq(clockid_t clkid)
+{
+	int f = 0;
+	struct timex tx;
+
+	memset(&tx, 0, sizeof(tx));
+	if (clock_adjtime(clkid, &tx) < 0)
+		pr_err("failed to read out the clock maximum adjustment: %m");
+	else
+		f = tx.tolerance / 65.536;
+	if (!f)
+		f = 500000;
+
+	/* The kernel allows the tick length to be adjusted up to 10%. But use
+	 * it only if the overall frequency of the clock can be adjusted
+	 * continuously with the tick and freq fields (i.e. hz <= 1000).
+	 */
+	if (clkid == CLOCK_REALTIME && (realtime_nominal_tick && 2 * f >=
+					1000 * realtime_hz))
+		f = realtime_nominal_tick / 10 * 1000 * realtime_hz;
+
+	return f;
+}
+
 void sysclk_set_leap(int leap)
 {
 	clockid_t clkid = CLOCK_REALTIME;
@@ -142,24 +166,7 @@ void sysclk_set_tai_offset(int offset)
 
 int sysclk_max_freq(void)
 {
-	clockid_t clkid = CLOCK_REALTIME;
-	int f = 0;
-	struct timex tx;
-	memset(&tx, 0, sizeof(tx));
-	if (clock_adjtime(clkid, &tx) < 0)
-		pr_err("failed to read out the clock maximum adjustment: %m");
-	else
-		f = tx.tolerance / 65.536;
-	if (!f)
-		f = 500000;
-
-	/* The kernel allows the tick length to be adjusted up to 10%. But use
-	   it only if the overall frequency of the clock can be adjusted
-	   continuously with the tick and freq fields (i.e. hz <= 1000). */
-	if (realtime_nominal_tick && 2 * f >= 1000 * realtime_hz)
-		f = realtime_nominal_tick / 10 * 1000 * realtime_hz;
-
-	return f;
+	return clockadj_max_freq(CLOCK_REALTIME);
 }
 
 void sysclk_set_sync(void)
diff --git a/clockadj.h b/clockadj.h
index 492418e..4ea98c1 100644
--- a/clockadj.h
+++ b/clockadj.h
@@ -50,6 +50,12 @@ double clockadj_get_freq(clockid_t clkid);
  */
 void clockadj_step(clockid_t clkid, int64_t step);
 
+/**
+ * Read maximum frequency adjustment of the target clock.
+ * @return The maximum frequency adjustment in parts per billion (ppb).
+ */
+int clockadj_max_freq(clockid_t clkid);
+
 /**
  * Set the system clock to insert/delete leap second at midnight.
  * @param leap  +1 to insert leap second, -1 to delete leap second,
diff --git a/phc.c b/phc.c
index 40fa6a1..a90d13e 100644
--- a/phc.c
+++ b/phc.c
@@ -16,11 +16,12 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
+#include <fcntl.h>
 #include <stdio.h>
+#include <string.h>
 #include <sys/ioctl.h>
-#include <sys/types.h>
 #include <sys/stat.h>
-#include <fcntl.h>
+#include <sys/types.h>
 #include <unistd.h>
 
 #include <linux/ptp_clock.h>
@@ -38,18 +39,26 @@
 
 static int phc_get_caps(clockid_t clkid, struct ptp_clock_caps *caps);
 
-clockid_t phc_open(char *phc)
+clockid_t phc_open(const char *phc)
 {
 	clockid_t clkid;
-	struct ptp_clock_caps caps;
-	int fd = open(phc, O_RDWR);
+	struct timespec ts;
+	struct timex tx;
+	int fd;
 
+	memset(&tx, 0, sizeof(tx));
+
+	fd = open(phc, O_RDWR);
 	if (fd < 0)
 		return CLOCK_INVALID;
 
 	clkid = FD_TO_CLOCKID(fd);
 	/* check if clkid is valid */
-	if (phc_get_caps(clkid, &caps)) {
+	if (clock_gettime(clkid, &ts)) {
+		close(fd);
+		return CLOCK_INVALID;
+	}
+	if (clock_adjtime(clkid, &tx)) {
 		close(fd);
 		return CLOCK_INVALID;
 	}
diff --git a/phc.h b/phc.h
index 154e35e..c0c5996 100644
--- a/phc.h
+++ b/phc.h
@@ -28,7 +28,7 @@
  *
  * @return A valid clock ID on success, CLOCK_INVALID otherwise.
  */
-clockid_t phc_open(char *phc);
+clockid_t phc_open(const char *phc);
 
 /**
  * Closes a PTP hardware clock device.
diff --git a/ptp4l.c b/ptp4l.c
index 3a9f084..17db31f 100644
--- a/ptp4l.c
+++ b/ptp4l.c
@@ -56,7 +56,7 @@ static void usage(char *progname)
 		" -f [file] read configuration from 'file'\n"
 		" -i [dev]  interface device to use, for example 'eth0'\n"
 		"           (may be specified multiple times)\n"
-		" -p [dev]  PTP hardware clock device to use, default auto\n"
+		" -p [dev]  Clock device to use, default auto\n"
 		"           (ignored for SOFTWARE/LEGACY HW time stamping)\n"
 		" -s        slave only mode (overrides configuration file)\n"
 		" -t        transparent clock\n"
-- 
2.17.1


From 1a4f6a26ce174db070a37d555e21d4efef7ab7ce Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Fri, 9 Nov 2018 07:42:58 +0000
Subject: [PATCH 025/173] msg: Added const flag in msg_type

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 msg.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/msg.h b/msg.h
index b5a57fe..02e45fd 100644
--- a/msg.h
+++ b/msg.h
@@ -299,7 +299,7 @@ static inline UInteger8 msg_transport_specific(struct ptp_message *m)
  * @param m  Message to test.
  * @return   The value of the messageType field.
  */
-static inline int msg_type(struct ptp_message *m)
+static inline int msg_type(const struct ptp_message *m)
 {
 	return m->header.tsmt & 0x0f;
 }
-- 
2.17.1


From d663a483c40939bad58301c256d86da1f3da6cc0 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Tue, 13 Nov 2018 13:16:08 +0100
Subject: [PATCH 026/173] Fix building with new kernel headers.

net_tstamp.h in recent kernel versions requires time.h for clockid_t.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 clock.c      | 2 +-
 sk.c         | 1 +
 timemaster.c | 1 +
 3 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/clock.c b/clock.c
index 9c493c3..8533b39 100644
--- a/clock.c
+++ b/clock.c
@@ -17,11 +17,11 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 #include <errno.h>
+#include <time.h>
 #include <linux/net_tstamp.h>
 #include <poll.h>
 #include <stdlib.h>
 #include <string.h>
-#include <time.h>
 #include <sys/queue.h>
 
 #include "address.h"
diff --git a/sk.c b/sk.c
index e2b1f28..30162eb 100644
--- a/sk.c
+++ b/sk.c
@@ -18,6 +18,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 #include <errno.h>
+#include <time.h>
 #include <linux/net_tstamp.h>
 #include <linux/sockios.h>
 #include <linux/ethtool.h>
diff --git a/timemaster.c b/timemaster.c
index 058678f..00db59f 100644
--- a/timemaster.c
+++ b/timemaster.c
@@ -22,6 +22,7 @@
 #include <errno.h>
 #include <libgen.h>
 #include <limits.h>
+#include <time.h>
 #include <linux/net_tstamp.h>
 #include <net/if.h>
 #include <signal.h>
-- 
2.17.1


From 14ac29b059865de61097f296d7e272d3eb8a30fc Mon Sep 17 00:00:00 2001
From: Anders Selhammer <anders.selhammer@est.tech>
Date: Tue, 13 Nov 2018 12:44:40 +0000
Subject: [PATCH 027/173] tmv: Avoid overflow when byte shift in
 tmv_to_TimeInterval

Added check so that convertion from a positive tmv not result in a negative TimeInterval and vice versa.

Signed-off-by: Anders Selhammer <anders.selhammer@est.tech>
---
 tmv.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/tmv.h b/tmv.h
index b8339e6..cca4da7 100644
--- a/tmv.h
+++ b/tmv.h
@@ -26,6 +26,8 @@
 #include "pdt.h"
 
 #define NS_PER_SEC 1000000000LL
+#define MIN_TMV_TO_TIMEINTERVAL 0xFFFF800000000000ll
+#define MAX_TMV_TO_TIMEINTERVAL 0x00007FFFFFFFFFFFll
 
 /**
  * We implement the time value as a 64 bit signed integer containing
@@ -111,6 +113,11 @@ static inline int64_t tmv_to_nanoseconds(tmv_t x)
 
 static inline TimeInterval tmv_to_TimeInterval(tmv_t x)
 {
+	if (x.ns < (int64_t)MIN_TMV_TO_TIMEINTERVAL) {
+		return MIN_TMV_TO_TIMEINTERVAL << 16;
+	} else if (x.ns > (int64_t)MAX_TMV_TO_TIMEINTERVAL) {
+		return MAX_TMV_TO_TIMEINTERVAL << 16;
+	}
 	return x.ns << 16;
 }
 
-- 
2.17.1


From c0e49c708814ec783726fe92202371847703c5ed Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:27:58 +0100
Subject: [PATCH 028/173] sysoff: Initialize data for ioctl(PTP_SYS_OFFSET).

This fixes valgrind errors.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 sysoff.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/sysoff.c b/sysoff.c
index f7b6240..407a01c 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -18,6 +18,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 #include <stdio.h>
+#include <string.h>
 #include <sys/ioctl.h>
 #include <linux/ptp_clock.h>
 
@@ -76,6 +77,7 @@ int sysoff_measure(int fd, int n_samples,
 		   int64_t *result, uint64_t *ts, int64_t *delay)
 {
 	struct ptp_sys_offset pso;
+	memset(&pso, 0, sizeof(pso));
 	pso.n_samples = n_samples;
 	if (ioctl(fd, PTP_SYS_OFFSET, &pso)) {
 		perror("ioctl PTP_SYS_OFFSET");
-- 
2.17.1


From 93baf34adb81046a5e1c3b9a3e685029f2046993 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:27:59 +0100
Subject: [PATCH 029/173] sysoff: Extend API for different sysoff methods.

The kernel supports different PTP_SYS_OFFSET* ioctls. Use the sysoff
enum to allow selecting between them in sysoff_measure().

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 phc2sys.c | 12 ++++++------
 phc_ctl.c |  8 +++++---
 sysoff.c  | 25 +++++++++++++++++++++----
 sysoff.h  | 12 +++++++-----
 4 files changed, 39 insertions(+), 18 deletions(-)

diff --git a/phc2sys.c b/phc2sys.c
index 15f8d75..2cd477a 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -74,7 +74,7 @@ struct clock {
 	LIST_ENTRY(clock) dst_list;
 	clockid_t clkid;
 	int phc_index;
-	int sysoff_supported;
+	int sysoff_method;
 	int is_utc;
 	int dest_only;
 	int state;
@@ -255,9 +255,8 @@ static struct clock *clock_add(struct node *node, char *device)
 		c->servo = servo_add(node, c);
 
 	if (clkid != CLOCK_INVALID && clkid != CLOCK_REALTIME)
-		c->sysoff_supported = (SYSOFF_SUPPORTED ==
-				       sysoff_probe(CLOCKID_TO_FD(clkid),
-						    node->phc_readings));
+		c->sysoff_method = sysoff_probe(CLOCKID_TO_FD(clkid),
+						node->phc_readings);
 
 	LIST_INSERT_HEAD(&node->clocks, c, list);
 	return c;
@@ -784,11 +783,12 @@ static int do_loop(struct node *node, int subscriptions)
 				continue;
 
 			if (clock->clkid == CLOCK_REALTIME &&
-			    node->master->sysoff_supported) {
+			    node->master->sysoff_method >= 0) {
 				/* use sysoff */
 				if (sysoff_measure(CLOCKID_TO_FD(node->master->clkid),
+						   node->master->sysoff_method,
 						   node->phc_readings,
-						   &offset, &ts, &delay))
+						   &offset, &ts, &delay) < 0)
 					return -1;
 			} else {
 				/* use phc */
diff --git a/phc_ctl.c b/phc_ctl.c
index 4a78a19..b9a9cf4 100644
--- a/phc_ctl.c
+++ b/phc_ctl.c
@@ -367,10 +367,12 @@ static int do_cmp(clockid_t clkid, int cmdc, char *cmdv[])
 	struct timespec ts, rta, rtb;
 	int64_t sys_offset, delay = 0, offset;
 	uint64_t sys_ts;
+	int method;
 
-	if (SYSOFF_SUPPORTED ==
-	    sysoff_measure(CLOCKID_TO_FD(clkid),
-			   9, &sys_offset, &sys_ts, &delay)) {
+	method = sysoff_probe(CLOCKID_TO_FD(clkid), 9);
+
+	if (method >= 0 && sysoff_measure(CLOCKID_TO_FD(clkid), method, 9,
+					  &sys_offset, &sys_ts, &delay) >= 0) {
 		pr_notice( "offset from CLOCK_REALTIME is %"PRId64"ns\n",
 			sys_offset);
 		return 0;
diff --git a/sysoff.c b/sysoff.c
index 407a01c..f709a9b 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -73,8 +73,8 @@ static int64_t sysoff_estimate(struct ptp_clock_time *pct, int n_samples,
 	return samples[0].offset;
 }
 
-int sysoff_measure(int fd, int n_samples,
-		   int64_t *result, uint64_t *ts, int64_t *delay)
+static int sysoff_basic(int fd, int n_samples,
+			int64_t *result, uint64_t *ts, int64_t *delay)
 {
 	struct ptp_sys_offset pso;
 	memset(&pso, 0, sizeof(pso));
@@ -84,13 +84,24 @@ int sysoff_measure(int fd, int n_samples,
 		return SYSOFF_RUN_TIME_MISSING;
 	}
 	*result = sysoff_estimate(pso.ts, n_samples, ts, delay);
-	return SYSOFF_SUPPORTED;
+	return SYSOFF_BASIC;
+}
+
+int sysoff_measure(int fd, int method, int n_samples,
+		   int64_t *result, uint64_t *ts, int64_t *delay)
+{
+	switch (method) {
+	case SYSOFF_BASIC:
+		return sysoff_basic(fd, n_samples, result, ts, delay);
+	}
+	return SYSOFF_COMPILE_TIME_MISSING;
 }
 
 int sysoff_probe(int fd, int n_samples)
 {
 	int64_t junk, delay;
 	uint64_t ts;
+	int i;
 
 	if (n_samples > PTP_MAX_SAMPLES) {
 		fprintf(stderr, "warning: %d exceeds kernel max readings %d\n",
@@ -99,7 +110,13 @@ int sysoff_probe(int fd, int n_samples)
 		return SYSOFF_RUN_TIME_MISSING;
 	}
 
-	return sysoff_measure(fd, n_samples, &junk, &ts, &delay);
+	for (i = 0; i < SYSOFF_LAST; i++) {
+		if (sysoff_measure(fd, i, n_samples, &junk, &ts, &delay) < 0)
+			continue;
+		return i;
+	}
+
+	return SYSOFF_RUN_TIME_MISSING;
 }
 
 #else /* !PTP_SYS_OFFSET */
diff --git a/sysoff.h b/sysoff.h
index cb70265..02ecdfa 100644
--- a/sysoff.h
+++ b/sysoff.h
@@ -21,13 +21,14 @@
 #include <stdint.h>
 
 enum {
-	SYSOFF_SUPPORTED,
-	SYSOFF_COMPILE_TIME_MISSING,
-	SYSOFF_RUN_TIME_MISSING,
+	SYSOFF_COMPILE_TIME_MISSING = -2,
+	SYSOFF_RUN_TIME_MISSING = -1,
+	SYSOFF_BASIC,
+	SYSOFF_LAST,
 };
 
 /**
- * Check to see if the PTP_SYS_OFFSET ioctl is supported.
+ * Check to see if a PTP_SYS_OFFSET ioctl is supported.
  * @param fd  An open file descriptor to a PHC device.
  * @return  One of the SYSOFF_ enumeration values.
  */
@@ -36,11 +37,12 @@ int sysoff_probe(int fd, int n_samples);
 /**
  * Measure the offset between a PHC and the system time.
  * @param fd         An open file descriptor to a PHC device.
+ * @param method     A non-negative SYSOFF_ value returned by sysoff_probe().
  * @param n_samples  The number of consecutive readings to make.
  * @param result     The estimated offset in nanoseconds.
  * @param ts         The system time corresponding to the 'result'.
  * @param delay      The delay in reading of the clock in nanoseconds.
  * @return  One of the SYSOFF_ enumeration values.
  */
-int sysoff_measure(int fd, int n_samples,
+int sysoff_measure(int fd, int method, int n_samples,
 		   int64_t *result, uint64_t *ts, int64_t *delay);
-- 
2.17.1


From 192b8e315c4585489d7aa7f59683035998805e40 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:28:00 +0100
Subject: [PATCH 030/173] sysoff: Add support for PTP_SYS_OFFSET_PRECISE ioctl.

This ioctl uses cross timestamping for a more accurate measurement of
the offset. It is supported on some onboard Intel NICs using the e1000e
driver and a virtual PHC with the ptp_kvm driver.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 sysoff.c | 21 +++++++++++++++++++++
 sysoff.h |  1 +
 2 files changed, 22 insertions(+)

diff --git a/sysoff.c b/sysoff.c
index f709a9b..9f65d95 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -22,6 +22,7 @@
 #include <sys/ioctl.h>
 #include <linux/ptp_clock.h>
 
+#include "print.h"
 #include "sysoff.h"
 
 #define NS_PER_SEC 1000000000LL
@@ -39,6 +40,23 @@ static struct {
 	uint64_t timestamp;
 } samples[PTP_MAX_SAMPLES];
 
+static int sysoff_precise(int fd, int64_t *result, uint64_t *ts)
+{
+#ifdef PTP_SYS_OFFSET_PRECISE
+	struct ptp_sys_offset_precise pso;
+	memset(&pso, 0, sizeof(pso));
+	if (ioctl(fd, PTP_SYS_OFFSET_PRECISE, &pso)) {
+		pr_debug("ioctl PTP_SYS_OFFSET_PRECISE: %m");
+		return SYSOFF_RUN_TIME_MISSING;
+	}
+	*result = pctns(&pso.sys_realtime) - pctns(&pso.device);
+	*ts = pctns(&pso.sys_realtime);
+	return SYSOFF_PRECISE;
+#else
+	return SYSOFF_COMPILE_TIME_MISSING;
+#endif
+}
+
 static void insertion_sort(int length, int64_t interval, int64_t offset, uint64_t ts)
 {
 	int i = length - 1;
@@ -91,6 +109,9 @@ int sysoff_measure(int fd, int method, int n_samples,
 		   int64_t *result, uint64_t *ts, int64_t *delay)
 {
 	switch (method) {
+	case SYSOFF_PRECISE:
+		*delay = 0;
+		return sysoff_precise(fd, result, ts);
 	case SYSOFF_BASIC:
 		return sysoff_basic(fd, n_samples, result, ts, delay);
 	}
diff --git a/sysoff.h b/sysoff.h
index 02ecdfa..37f7353 100644
--- a/sysoff.h
+++ b/sysoff.h
@@ -23,6 +23,7 @@
 enum {
 	SYSOFF_COMPILE_TIME_MISSING = -2,
 	SYSOFF_RUN_TIME_MISSING = -1,
+	SYSOFF_PRECISE,
 	SYSOFF_BASIC,
 	SYSOFF_LAST,
 };
-- 
2.17.1


From 68a9011c9d7d859920da339ba59c14dc1d617a45 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:28:01 +0100
Subject: [PATCH 031/173] sysoff: Add support for PTP_SYS_OFFSET_EXTENDED
 ioctl.

This is a more accurate variant of the the PTP_SYS_OFFSET ioctl, which
will probably be supported in future kernel versions.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 sysoff.c | 38 ++++++++++++++++++++++++++++++++------
 sysoff.h |  1 +
 2 files changed, 33 insertions(+), 6 deletions(-)

diff --git a/sysoff.c b/sysoff.c
index 9f65d95..b993ee9 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -71,17 +71,23 @@ static void insertion_sort(int length, int64_t interval, int64_t offset, uint64_
 	samples[i+1].timestamp = ts;
 }
 
-static int64_t sysoff_estimate(struct ptp_clock_time *pct, int n_samples,
-			       uint64_t *ts, int64_t *delay)
+static int64_t sysoff_estimate(struct ptp_clock_time *pct, int extended,
+			       int n_samples, uint64_t *ts, int64_t *delay)
 {
 	int64_t t1, t2, tp;
 	int64_t interval, offset;
 	int i;
 
 	for (i = 0; i < n_samples; i++) {
-		t1 = pctns(&pct[2*i]);
-		tp = pctns(&pct[2*i+1]);
-		t2 = pctns(&pct[2*i+2]);
+		if (extended) {
+			t1 = pctns(&pct[3*i]);
+			tp = pctns(&pct[3*i+1]);
+			t2 = pctns(&pct[3*i+2]);
+		} else {
+			t1 = pctns(&pct[2*i]);
+			tp = pctns(&pct[2*i+1]);
+			t2 = pctns(&pct[2*i+2]);
+		}
 		interval = t2 - t1;
 		offset = (t2 + t1) / 2 - tp;
 		insertion_sort(i, interval, offset, (t2 + t1) / 2);
@@ -91,6 +97,24 @@ static int64_t sysoff_estimate(struct ptp_clock_time *pct, int n_samples,
 	return samples[0].offset;
 }
 
+static int sysoff_extended(int fd, int n_samples,
+			   int64_t *result, uint64_t *ts, int64_t *delay)
+{
+#ifdef PTP_SYS_OFFSET_EXTENDED
+	struct ptp_sys_offset_extended pso;
+	memset(&pso, 0, sizeof(pso));
+	pso.n_samples = n_samples;
+	if (ioctl(fd, PTP_SYS_OFFSET_EXTENDED, &pso)) {
+		pr_debug("ioctl PTP_SYS_OFFSET_EXTENDED: %m");
+		return SYSOFF_RUN_TIME_MISSING;
+	}
+	*result = sysoff_estimate(&pso.ts[0][0], 1, n_samples, ts, delay);
+	return SYSOFF_EXTENDED;
+#else
+	return SYSOFF_COMPILE_TIME_MISSING;
+#endif
+}
+
 static int sysoff_basic(int fd, int n_samples,
 			int64_t *result, uint64_t *ts, int64_t *delay)
 {
@@ -101,7 +125,7 @@ static int sysoff_basic(int fd, int n_samples,
 		perror("ioctl PTP_SYS_OFFSET");
 		return SYSOFF_RUN_TIME_MISSING;
 	}
-	*result = sysoff_estimate(pso.ts, n_samples, ts, delay);
+	*result = sysoff_estimate(pso.ts, 0, n_samples, ts, delay);
 	return SYSOFF_BASIC;
 }
 
@@ -112,6 +136,8 @@ int sysoff_measure(int fd, int method, int n_samples,
 	case SYSOFF_PRECISE:
 		*delay = 0;
 		return sysoff_precise(fd, result, ts);
+	case SYSOFF_EXTENDED:
+		return sysoff_extended(fd, n_samples, result, ts, delay);
 	case SYSOFF_BASIC:
 		return sysoff_basic(fd, n_samples, result, ts, delay);
 	}
diff --git a/sysoff.h b/sysoff.h
index 37f7353..79d2290 100644
--- a/sysoff.h
+++ b/sysoff.h
@@ -24,6 +24,7 @@ enum {
 	SYSOFF_COMPILE_TIME_MISSING = -2,
 	SYSOFF_RUN_TIME_MISSING = -1,
 	SYSOFF_PRECISE,
+	SYSOFF_EXTENDED,
 	SYSOFF_BASIC,
 	SYSOFF_LAST,
 };
-- 
2.17.1


From 8142da41b61fb5b9ee4ad8f5ab56adb0447cd37b Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:28:02 +0100
Subject: [PATCH 032/173] phc2sys: Use reversed sysoff when synchronizing to
 system clock.

If synchronizing a PHC to the system clock, use one of the
PTP_SYS_OFFSET ioctls (if supported) to measure the offset between the
two clocks. Negate the offset and switch the timestamp before passing
them to the servo.

This makes the synchronization between PHC and system clock symmetric.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 phc2sys.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/phc2sys.c b/phc2sys.c
index 2cd477a..b8f1ea0 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -790,6 +790,16 @@ static int do_loop(struct node *node, int subscriptions)
 						   node->phc_readings,
 						   &offset, &ts, &delay) < 0)
 					return -1;
+			} else if (node->master->clkid == CLOCK_REALTIME &&
+				   clock->sysoff_method >= 0) {
+				/* use reversed sysoff */
+				if (sysoff_measure(CLOCKID_TO_FD(clock->clkid),
+						   clock->sysoff_method,
+						   node->phc_readings,
+						   &offset, &ts, &delay) < 0)
+					return -1;
+				ts += offset;
+				offset = -offset;
 			} else {
 				/* use phc */
 				if (!read_phc(node->master->clkid, clock->clkid,
-- 
2.17.1


From 3c7e4947e4e471de56ced82323f89732ef9a774f Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 12 Nov 2018 17:28:03 +0100
Subject: [PATCH 033/173] phc2sys: Fix crash when trying to synchronize
 unadjustable clock.

A clock that cannot be adjusted has no servo. Check if a servo is
present before updating the clock.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 phc2sys.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/phc2sys.c b/phc2sys.c
index b8f1ea0..a476e63 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -782,6 +782,11 @@ static int do_loop(struct node *node, int subscriptions)
 			    !strcmp(clock->device, node->master->device))
 				continue;
 
+			if (!clock->servo) {
+				pr_err("cannot update clock without servo");
+				return -1;
+			}
+
 			if (clock->clkid == CLOCK_REALTIME &&
 			    node->master->sysoff_method >= 0) {
 				/* use sysoff */
-- 
2.17.1


From 6d50817dc094b92478477a0259959494eba372e3 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 28 Jan 2019 10:39:41 +0100
Subject: [PATCH 034/173] port: Prevent undefined shift operations in
 msg_current().

Adjust checks of logMessageInterval in received packet to prevent 1 of
type int being shifted by values >= 31.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 port.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/port.c b/port.c
index 428326e..ad9554f 100644
--- a/port.c
+++ b/port.c
@@ -140,9 +140,9 @@ static int msg_current(struct ptp_message *m, struct timespec now)
 	t1 = m->ts.host.tv_sec * NSEC2SEC + m->ts.host.tv_nsec;
 	t2 = now.tv_sec * NSEC2SEC + now.tv_nsec;
 
-	if (m->header.logMessageInterval < -63) {
+	if (m->header.logMessageInterval <= -31) {
 		tmo = 0;
-	} else if (m->header.logMessageInterval > 31) {
+	} else if (m->header.logMessageInterval >= 31) {
 		tmo = INT64_MAX;
 	} else if (m->header.logMessageInterval < 0) {
 		tmo = 4LL * NSEC2SEC / (1 << -m->header.logMessageInterval);
-- 
2.17.1


From 36624a43457255c95ce7f54efc71532ae3520dae Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 24 Feb 2019 19:03:50 -0800
Subject: [PATCH 035/173] Add an acknowledgment in the readme for Moser Baer.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 README.org | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/README.org b/README.org
index 91de38c..dcd4371 100644
--- a/README.org
+++ b/README.org
@@ -299,6 +299,11 @@
 
   - https://www.meinbergglobal.com
 
+  Thanks to Moser Baer for sponsoring the Telecom Profiles and unicast
+  support.
+
+  - http://www.mobatime.com
+
   For testing I use an OTMC 100 grandmaster clock donated by OMICRON Lab.
 
   - http://www.omicron-lab.com/ptp
-- 
2.17.1


From 47a4fd040b98243a4e8da3b6ac1d52b71c5a4be3 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 24 Feb 2019 19:16:42 -0800
Subject: [PATCH 036/173] Update the features listed in the readme file.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 README.org | 25 ++++++++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)

diff --git a/README.org b/README.org
index dcd4371..8cdfb7c 100644
--- a/README.org
+++ b/README.org
@@ -20,10 +20,11 @@
     SO_TIMESTAMPING socket option.
 
   - Supports the Linux PTP Hardware Clock (PHC) subsystem by using the
-    clock_gettime family of calls, including the new clock_adjtimex
-    system call.
+    clock_gettime family of calls, including the clock_adjtimex system
+    call.
 
-  - Implements Boundary Clock (BC) and Ordinary Clock (OC).
+  - Implements Boundary Clock (BC), Ordinary Clock (OC) and
+    Transparent Clock (TC).
 
   - Transport over UDP/IPv4, UDP/IPv6, and raw Ethernet (Layer 2).
 
@@ -32,6 +33,24 @@
   - Modular design allowing painless addition of new transports and
     clock servos.
 
+  - Implements unicast operation.
+
+  - Supports a number of profiles, including:
+
+    - The automotive profile
+
+    - The default 1588 profile.
+
+    - The enterprise profile.
+
+    - The telecom profiles G.8265.1, G.8275.1, and G.8275.2.
+
+  - Supports the NetSync Monitor protocol.
+
+  - Implements Peer to peer one-step.
+
+  - Supports bonded, IPoIB, and vlan interfaces.
+
 * Getting the Code
 
   You can download the latest released version at Source Forge.
-- 
2.17.1


From 32e34d5da381c90b2d6ef1704b90aaa6dd11be76 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 24 Feb 2019 19:26:36 -0800
Subject: [PATCH 037/173] Simplify the systems requirements section of the
 readme file.

Now that PTP support support is well established, remove the text that
attempts to explain the (at the time) incomplete kernel support.  Instead
just give a couple of ethtool examples.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 README.org | 187 ++++++++++++-----------------------------------------
 1 file changed, 40 insertions(+), 147 deletions(-)

diff --git a/README.org b/README.org
index 8cdfb7c..063b542 100644
--- a/README.org
+++ b/README.org
@@ -73,165 +73,58 @@
 
 * System Requirements
 
-  In order to run this software, you need Linux kernel
-  version 3.0 or newer, and the kernel header files must available at
-  compile time.
-
-  In addition, you will also need to have either:
-
-  1. A supported Ethernet MAC device.
-
-  2. A supported PHY device paired with a MAC that allows time
-     stamping in the PHY (indicated by PHY=Y in the table below).
-
-** Linux Kernel Support
-
-   In order to support PTP, the operating system needs to provide two
-   services: network packet time stamping and clock control. In 2009,
-   Patrick Ohly added a new socket option called SO_TIMESTAMPING for
-   packet time stamping, especially for PTP. This work appeared in
-   Linux version 2.6.30.
-
-   In July of 2011, the PTP Hardware Clock (PHC) subsystem was merged
-   into Linux version 3.0. The PHC code provides a driver framework and
-   the user space API for clock control.
-
-** Ethtool Support
-
-   Starting with version 3.5 of the Linux kernel, you can query the
-   time stamping capabilities of a network interface using the
-   ETHTOOL_GET_TS_INFO ioctl. Using ethtool version 3.4 or later, you
-   can check your system's time stamping support as shown in the
-   following example.
+  In order to run this software, you need Linux kernel version 3.0 or
+  newer.  Check whether your network interface supports PTP with the
+  following command.
 
 #+BEGIN_EXAMPLE
   ethtool -T eth0
 #+END_EXAMPLE
 
-   If the ethtool ioctl is available, then the ptp4l program will use
-   it in order to discover the proper PHC device.
-
-** Driver Support Matrix
-
-   The following two tables list the drivers that support the PHC
-   subsystem and the Linux kernel version when they first appeared.
-   These drivers will create a PHC device for controlling the hardware
-   clock.
-
-*** Hardware Timestamping - PHY
-
-    |---------+-------------------------------+---------|
-    | Driver  | Hardware                      | Version |
-    |---------+-------------------------------+---------|
-    | dp83640 | National Semiconductor PHYTER |     3.0 |
-    |---------+-------------------------------+---------|
-
-*** Hardware Timestamping - MAC
-
-    |------------+--------------------------+---------|
-    | Driver     | Hardware                 | Version |
-    |------------+--------------------------+---------|
-    | amd-xgbe   | AMD 10GbE Ethernet Soc   |    3.17 |
-    | bfin_mac   | Analog Blackfin          |     3.8 |
-    | bnx2x      | Broadcom NetXtremeII 10G |    3.18 |
-    | cpts       | Texas Instruments am335x |     3.8 |
-    | e1000e     | Intel 82574, 82583       |     3.9 |
-    | fm10k      | Intel FM10000            |    3.18 |
-    | fec        | Freescale i.mx6          |     3.8 |
-    | gianfar    | Freescale eTSEC PowerPC  |     3.0 |
-    | i40e       | Intel XL710 Family       |    3.14 |
-    | igb        | Intel 82576, 82580       |     3.5 |
-    | ixgbe      | Intel 82599              |     3.5 |
-    | mlx4       | Mellanox 40G PCI         |    3.14 |
-    | ptp_ixp46x | Intel IXP465             |     3.0 |
-    | ptp_phc    | Lapis EG20T PCH          |     3.5 |
-    | sfc        | Solarflare SFC9000       |     3.7 |
-    | stmmac     | STM Synopsys IP Core     |    3.10 |
-    | tg3        | Broadcom Tigon3 PCI      |     3.8 |
-    | tilegx     | Tilera GBE/XGBE          |    3.12 |
-    |------------+--------------------------+---------|
-
-*** Software Timestamping
-
-    The table below shows the Linux drivers that support software time
-    stamping. In addition, the 'PHY' column indicates whether the
-    Ethernet MAC driver can support a PTP Hardware Clock in an
-    external PHY. The letter 'Y' in this column means that if you
-    design a mother board that combines such a MAC with a PTP capable
-    PHY, then it will work with the Linux PHC subsystem.
-
-    |--------------+--------------------------+---------+-----|
-    | Driver       | Hardware                 | Version | PHY |
-    |--------------+--------------------------+---------+-----|
-    | 3c59x        | 3Com EtherLink PCI       |    3.14 | N   |
-    | altera_tse   | Altera Triple-Speed MAC  |    3.15 | Y   |
-    | bna          | Brocade 1010/1020 10Gb   |    3.14 | N   |
-    | bnx2x        | Broadcom Everest         |     3.5 | N   |
-    | davinci_emac | TI DaVinci, Sitara       |     3.1 | Y   |
-    | dnet         | Dave Ethernet MAC        |     3.1 | Y   |
-    | e100         | Intel PRO/100            |     3.5 | N   |
-    | e1000        | Intel PRO/1000 PCI/PCI-X |     3.5 | N   |
-    | e1000e       | Intel PRO/1000 PCIe      |     3.5 | N   |
-    | emaclite     | Xilinx Ethernet Lite     |     3.1 | Y   |
-    | ethoc        | OpenCores 10/100 MAC     |     3.1 | Y   |
-    | fec          | Freescale Coldfire       |     3.1 | Y   |
-    | fec_mpc52xx  | Freescale MPC5200        |     3.1 | Y   |
-    | forcedeth    | NVIDIA nForce            |     3.5 | N   |
-    | fs_enet      | Freescale MPC512x        |     3.1 | Y   |
-    | genet        | Broadcom GENET           |    3.15 | Y   |
-    | ixp4xx_eth   | Intel IXP4xx             |     3.0 | Y   |
-    | lib8390      | Asix AX88796             |     3.1 | Y   |
-    | lib8390      | Various 8390 based HW    |     3.1 | N   |
-    | ll_temac     | Xilinx LL TEMAC          |     3.1 | Y   |
-    | macb         | Atmel AT32, AT91         |     3.1 | Y   |
-    | mv643xx_eth  | Marvell Discovery, Orion |     3.1 | Y   |
-    | pxa168_eth   | Marvell pxa168           |     3.1 | Y   |
-    | r6040        | RDC Ethernet MAC         |     3.1 | Y   |
-    | r8169        | Realtek 8169/8168/8101   |     3.4 | N   |
-    | samsun-sxgbe | Samsung SXGBE 10G        |    3.15 | Y   |
-    | smsc911x     | SMSC LAN911x, LAN921x    |     3.1 | Y   |
-    | smsc9420     | SMSC LAN9420 PCI         |     3.1 | Y   |
-    | stmmac       | STM Synopsys IP Core     |     3.1 | Y   |
-    | tg3          | Broadcom Tigon3 PCI      |     3.1 | Y   |
-    | ucc_geth     | Freescale QE Gigabit     |     3.1 | Y   |
-    | usbnet       | USB network devices      |     3.2 | Y/N |
-    | xgene-enet   | APM X-Gene SoC           |    3.17 | Y   |
-    |--------------+--------------------------+---------+-----|
-
-* Installation
+  This command shows whether a MAC supports hardware or software time
+  stamping.  The following example output indicates support for
+  hardware time stamping.
 
-** Linux kernel
+#+BEGIN_EXAMPLE
+Time stamping parameters for eth6:
+Capabilities:
+        hardware-transmit     (SOF_TIMESTAMPING_TX_HARDWARE)
+        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)
+        hardware-receive      (SOF_TIMESTAMPING_RX_HARDWARE)
+        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)
+        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)
+        hardware-raw-clock    (SOF_TIMESTAMPING_RAW_HARDWARE)
+PTP Hardware Clock: 1
+Hardware Transmit Timestamp Modes:
+        off                   (HWTSTAMP_TX_OFF)
+        on                    (HWTSTAMP_TX_ON)
+Hardware Receive Filter Modes:
+        none                  (HWTSTAMP_FILTER_NONE)
+        all                   (HWTSTAMP_FILTER_ALL)
+#+END_EXAMPLE
 
-   There are many ways of getting a precompiled Linux kernel or
-   compiling your own, so this section is only meant as an example. It
-   is important to have the kernel headers available when compiling
-   the Linux PTP stack.
+  The next example shows the case where the MAC only supports software
+  time stamping.  The ~ptp4l~ program requires either the ~-S~ command
+  line argument or the ~time_stamping software~ configuration option
+  when using such interfaces.
 
 #+BEGIN_EXAMPLE
-   export ARCH=x86
-   export CROSS_COMPILE=
-   export KBUILD_OUTPUT=/home/richard/kernel/ptp_debian
-   mkdir -p $KBUILD_OUTPUT
-   cp /boot/config-2.6.38-bpo.2-686 $KBUILD_OUTPUT/.config
-   make oldnoconfig
-   make menuconfig
-   time make -j4
-   make headers_install
+Time stamping parameters for enp6s0:
+Capabilities:
+        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)
+        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)
+        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)
+PTP Hardware Clock: none
+Hardware Transmit Timestamp Modes: none
+Hardware Receive Filter Modes: none
 #+END_EXAMPLE
 
-   Here is a table of kernel configuration options needed for PTP
-   support. In addtion to these, you should enable the specific
-   Ethernet MAC and PHY drivers for your hardware.
-
-   |---------------------------------+-----------------------------|
-   | Option                          | Description                 |
-   |---------------------------------+-----------------------------|
-   | CONFIG_PPS                      | Required                    |
-   | CONFIG_NETWORK_PHY_TIMESTAMPING | Timestamping in PHY devices |
-   | PTP_1588_CLOCK                  | PTP clock support           |
-   |---------------------------------+-----------------------------|
+  Note the ~software-transmit (SOF_TIMESTAMPING_TX_SOFTWARE)~
+  capability.  If this is lacking, then the MAC cannot be used at
+  all.  However, adding this capability entails adding a single line
+  of code to the device driver.
 
-** PTP stack
+* Installation
 
    1. Just type 'make'
 
-- 
2.17.1


From 1b7a1e2cda1da59cee9aea38009663cdaf278487 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 25 Mar 2019 06:04:40 -0700
Subject: [PATCH 038/173] ptp4l: Remove bogus command line option.

Commit c8107c8d ("config: Add a configuration option for TC mode.")
added a new TC mode.  An early version of the patch series included a
new '-t' command line option, but this was dropped considering the
fact that long options are always available.  IOW the TC user can
simply add '--clock_type=P2P_TC' to the command line, making the
single dash option redundant.

This patch fixes the misleading usage message by removing the
non-existing option.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ptp4l.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/ptp4l.c b/ptp4l.c
index 17db31f..84661c5 100644
--- a/ptp4l.c
+++ b/ptp4l.c
@@ -59,7 +59,6 @@ static void usage(char *progname)
 		" -p [dev]  Clock device to use, default auto\n"
 		"           (ignored for SOFTWARE/LEGACY HW time stamping)\n"
 		" -s        slave only mode (overrides configuration file)\n"
-		" -t        transparent clock\n"
 		" -l [num]  set the logging level to 'num'\n"
 		" -m        print messages to stdout\n"
 		" -q        do not print messages to the syslog\n"
-- 
2.17.1


From 6b61ba29c78e26109426429c6d6b354f6e4443cd Mon Sep 17 00:00:00 2001
From: David Mirabito via Linuxptp-devel <linuxptp-devel@lists.sourceforge.net>
Date: Tue, 19 Mar 2019 13:42:48 +1100
Subject: [PATCH 039/173] Avoid fault when receiving zero length packets

The manpage for recvmsg says -1 will be returned on error, Zero indicates an
"orderly shutdown", presumably only in case of stream sockets.
Further, UNIX Network Programming, Vol 1 says ".. a return value of 0 from
recvfrom is acceptable for a datagram protocol"

Such packets have been observed in the wild, aimed at PTP's multicast
address and port, possibly related to malformed management queries.

Patch to properly check return from recvmesg and not trigger the fault
codepath. Instead, such packets are treated as "Bad Message" the same as
non-zero but still too-short UDP payloads.

Signed-off-by: David Mirabito <davidjm@arista.com>
---
 port.c | 2 +-
 sk.c   | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/port.c b/port.c
index ad9554f..9264211 100644
--- a/port.c
+++ b/port.c
@@ -2563,7 +2563,7 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 	msg->hwts.type = p->timestamping;
 
 	cnt = transport_recv(p->trp, fd, msg);
-	if (cnt <= 0) {
+	if (cnt < 0) {
 		pr_err("port %hu: recv message failed", portnum(p));
 		msg_put(msg);
 		return EV_FAULT_DETECTED;
diff --git a/sk.c b/sk.c
index 30162eb..93ba77a 100644
--- a/sk.c
+++ b/sk.c
@@ -359,7 +359,7 @@ int sk_receive(int fd, void *buf, int buflen,
 	}
 
 	cnt = recvmsg(fd, &msg, flags);
-	if (cnt < 1)
+	if (cnt < 0)
 		pr_err("recvmsg%sfailed: %m",
 		       flags == MSG_ERRQUEUE ? " tx timestamp " : " ");
 
-- 
2.17.1


From 51d76bdfb7423947dbb3e250c86d83f9edb0a15b Mon Sep 17 00:00:00 2001
From: Hangbin Liu <liuhangbin@gmail.com>
Date: Wed, 20 Mar 2019 14:44:13 +0800
Subject: [PATCH 040/173] port: should check the new phc_index before switching

In logic, when we want to switch phc, we should check if the new phc
index is valid instead of checking the previous one.

In reality, if we use linux team interface with activebackup mode. As
teamd is a userspace tool, it sets the new slave as active port after
receiving link change message. If we set current active port down and
another slave up. There is a race that we receive the new slave's link
up message while active port(ts_index) is still the old one. This means
we may use a link down interface as ts_index and get phc_index with -1.

If we update the p->phc_index to -1, there will be no possibility to
change it back to other value as we swith phc only when p->phc_index >= 0.

With this fix, we will not switch phc_index until receiving the real
active port(p->iface->ts_info.phc_index >= 0) update message.

Reported-by: Miroslav Lichvar <mlichvar@redhat.com>
Fixes: 536a71031d5c ("ptp4l: use ts label to get ts info")
Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
---
 port.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/port.c b/port.c
index 9264211..facebd2 100644
--- a/port.c
+++ b/port.c
@@ -2442,7 +2442,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 		sk_get_ts_info(p->iface->ts_label, &p->iface->ts_info);
 
 		/* Only switch phc with HW time stamping mode */
-		if (p->phc_index >= 0 && p->iface->ts_info.valid) {
+		if (p->iface->ts_info.valid && p->iface->ts_info.phc_index >= 0) {
 			required_modes = clock_required_modes(p->clock);
 			if ((p->iface->ts_info.so_timestamping & required_modes) != required_modes) {
 				pr_err("interface '%s' does not support requested "
-- 
2.17.1


From 86723cfc6a7ac1d9b1bff5e90b7f4696d6460a0e Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Thu, 21 Mar 2019 17:12:03 +0100
Subject: [PATCH 041/173] pmc: Don't leak memory when msg_tlv_append() fails.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 pmc_common.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/pmc_common.c b/pmc_common.c
index 4a160f6..4d48e3a 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -546,6 +546,7 @@ int pmc_send_set_action(struct pmc *pmc, int id, void *data, int datasize)
 	}
 	extra = msg_tlv_append(msg, sizeof(*mgt) + datasize);
 	if (!extra) {
+		msg_put(msg);
 		return -ENOMEM;
 	}
 	mgt = (struct management_tlv *) extra->tlv;
-- 
2.17.1


From dd30b3a0d94d1c087066066e5df6bc84e3019b0b Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Mon, 25 Mar 2019 11:38:13 +0100
Subject: [PATCH 042/173] util: Fix addreq() to not read past addresses.

Fix the length of compared data to be the size of the IPv4/IPv6 address.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 util.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/util.c b/util.c
index 9ad23e0..42c0977 100644
--- a/util.c
+++ b/util.c
@@ -78,12 +78,12 @@ int addreq(enum transport_type type, struct address *a, struct address *b)
 	case TRANS_UDP_IPV4:
 		bufa = &a->sin.sin_addr;
 		bufb = &b->sin.sin_addr;
-		len = sizeof(a->sin);
+		len = sizeof(a->sin.sin_addr);
 		break;
 	case TRANS_UDP_IPV6:
 		bufa = &a->sin6.sin6_addr;
 		bufb = &b->sin6.sin6_addr;
-		len = sizeof(a->sin6);
+		len = sizeof(a->sin6.sin6_addr);
 		break;
 	case TRANS_IEEE_802_3:
 		bufa = &a->sll.sll_addr;
-- 
2.17.1


From cc54cdef27c7e2e910172f839d54af691a207fce Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 6 May 2019 22:06:39 -0700
Subject: [PATCH 043/173] Update the unciast discovery options sections of the
 man page.

Ever since commit d88b4ff2298b ("util: Added IPv6 support in help
funtions addreq and str2addr"), the unicast master table supports
entries with IPv6 addresses.  This patch updates the man page to
reflect this fact.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ptp4l.8 | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ptp4l.8 b/ptp4l.8
index 99b085c..46e6715 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -736,7 +736,7 @@ will negotiate unicast peer delay responses from the machine at the
 given remote address, otherwise the port will send multicast peer
 delay requests.
 .TP
-.B L2|UDPv4
+.B L2|UDPv4|UDPv6
 Each table entry specifies the transport type and network address of a
 potential remote master.  If multiple masters are specified, then
 unicast negotiation will be performed with each if them.
-- 
2.17.1


From b59a739d0fa7fda2d91328a025b6db40dc35ba6d Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 6 May 2019 21:04:25 -0700
Subject: [PATCH 044/173] Ignore signaling messages on target port mismatch.

IEEE 1588 specifies dropping signaling messages if the
targetPortIdentity does not match the receiving port.  Up until now
the unicast code did check that field, but only for the unicast
transmission request and cancel operations.

This patch moves the target port identity check so that it applies to
each and every received signaling message.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port_signaling.c | 13 +++++++++++++
 unicast_client.c | 11 -----------
 2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/port_signaling.c b/port_signaling.c
index f845d36..ec3ad87 100644
--- a/port_signaling.c
+++ b/port_signaling.c
@@ -21,6 +21,13 @@
 #include "unicast_client.h"
 #include "unicast_service.h"
 
+static struct PortIdentity wildcard = {
+	.clockIdentity = {
+		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
+	},
+	.portNumber = 0xffff,
+};
+
 struct ptp_message *port_signaling_construct(struct port *p,
 					     struct address *address,
 					     struct PortIdentity *tpid)
@@ -67,6 +74,12 @@ int process_signaling(struct port *p, struct ptp_message *m)
 		break;
 	}
 
+	/* Ignore signaling messages not addressed to this port. */
+	if (!pid_eq(&m->signaling.targetPortIdentity, &p->portIdentity) &&
+	    !pid_eq(&m->signaling.targetPortIdentity, &wildcard)) {
+		return 0;
+	}
+
 	TAILQ_FOREACH(extra, &m->tlv_list, list) {
 		switch (extra->tlv->type) {
 		case TLV_REQUEST_UNICAST_TRANSMISSION:
diff --git a/unicast_client.c b/unicast_client.c
index de5eee9..91b99ed 100644
--- a/unicast_client.c
+++ b/unicast_client.c
@@ -25,13 +25,6 @@
 #define E2E_SYDY_MASK	(1 << ANNOUNCE | 1 << SYNC | 1 << DELAY_RESP)
 #define P2P_SYDY_MASK	(1 << ANNOUNCE | 1 << SYNC)
 
-static struct PortIdentity wildcard = {
-	.clockIdentity = {
-		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
-	},
-	.portNumber = 0xffff,
-};
-
 static int attach_ack(struct ptp_message *msg, uint8_t message_type_flags)
 {
 	struct ack_cancel_unicast_xmit_tlv *ack;
@@ -101,10 +94,6 @@ static struct unicast_master_address *unicast_client_ok(struct port *p,
 	if (!unicast_client_enabled(p)) {
 		return NULL;
 	}
-	if (!pid_eq(&m->signaling.targetPortIdentity, &p->portIdentity) &&
-	    !pid_eq(&m->signaling.targetPortIdentity, &wildcard)) {
-		return NULL;
-	}
 	STAILQ_FOREACH(ucma, &p->unicast_master_table->addrs, list) {
 		if (addreq(transport_type(p->trp), &ucma->address, &m->address)) {
 			break;
-- 
2.17.1


From 705e5a32faf20c1ca4595840ae486d71d422aa58 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:25 -0700
Subject: [PATCH 045/173] port: Make port_capable() accessible outside port.c

Make sure port_capable() can be accessed by the signaling construct in
port_signaling.c

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 port.c         | 3 +--
 port_private.h | 1 +
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/port.c b/port.c
index facebd2..b8ae77e 100644
--- a/port.c
+++ b/port.c
@@ -55,7 +55,6 @@ enum syfu_event {
 	FUP_MATCH,
 };
 
-static int port_capable(struct port *p);
 static int port_is_ieee8021as(struct port *p);
 static void port_nrate_initialize(struct port *p);
 
@@ -602,7 +601,7 @@ static int peer_prepare_and_send(struct port *p, struct ptp_message *msg,
 	return 0;
 }
 
-static int port_capable(struct port *p)
+int port_capable(struct port *p)
 {
 	if (!port_is_ieee8021as(p)) {
 		/* Normal 1588 ports are always capable. */
diff --git a/port_private.h b/port_private.h
index 593eb76..b0b2a5d 100644
--- a/port_private.h
+++ b/port_private.h
@@ -157,6 +157,7 @@ void delay_req_prune(struct port *p);
 void fc_clear(struct foreign_clock *fc);
 void flush_delay_req(struct port *p);
 void flush_last_sync(struct port *p);
+int port_capable(struct port *p);
 int port_clr_tmo(int fd);
 int port_delay_request(struct port *p);
 void port_disable(struct port *p);
-- 
2.17.1


From 43085ab741a9c07aff51dbefa597b5fabc76392f Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:26 -0700
Subject: [PATCH 046/173] port: Separate unicast specific code from
 port_signaling_construct()

Make port_signaling_construct() to create a generic signaling
ptp_message. Move the unicast specific code to
port_signaling_uc_construct().

This is done to support the creation of Message Interval Request TLV (as
defined in 802.1AS Section 10.5.4.3). This TLV can be used to request
change in Announce Interval, Sync Interval or Link Delay Interval on a
remote system.

[ RC - fix trivial rebase conflict on top of targetPortIdentity check. ]

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port_private.h    |  6 +++---
 port_signaling.c  | 20 +++++++++++++++++---
 unicast_client.c  | 10 +++++-----
 unicast_service.c |  4 ++--
 4 files changed, 27 insertions(+), 13 deletions(-)

diff --git a/port_private.h b/port_private.h
index b0b2a5d..1bc1c3f 100644
--- a/port_private.h
+++ b/port_private.h
@@ -169,9 +169,9 @@ int port_set_delay_tmo(struct port *p);
 int port_set_qualification_tmo(struct port *p);
 void port_show_transition(struct port *p, enum port_state next,
 			  enum fsm_event event);
-struct ptp_message *port_signaling_construct(struct port *p,
-					     struct address *address,
-					     struct PortIdentity *tpid);
+struct ptp_message *port_signaling_uc_construct(struct port *p,
+						struct address *address,
+						struct PortIdentity *tpid);
 int port_tx_announce(struct port *p, struct address *dst);
 int port_tx_sync(struct port *p, struct address *dst);
 int process_announce(struct port *p, struct ptp_message *m);
diff --git a/port_signaling.c b/port_signaling.c
index ec3ad87..09d4506 100644
--- a/port_signaling.c
+++ b/port_signaling.c
@@ -28,9 +28,8 @@ static struct PortIdentity wildcard = {
 	.portNumber = 0xffff,
 };
 
-struct ptp_message *port_signaling_construct(struct port *p,
-					     struct address *address,
-					     struct PortIdentity *tpid)
+static struct ptp_message *port_signaling_construct(struct port *p,
+						    struct PortIdentity *tpid)
 {
 	struct ptp_message *msg;
 
@@ -48,6 +47,21 @@ struct ptp_message *port_signaling_construct(struct port *p,
 	msg->header.control            = CTL_OTHER;
 	msg->header.logMessageInterval = 0x7F;
 	msg->signaling.targetPortIdentity = *tpid;
+
+	return msg;
+}
+
+struct ptp_message *port_signaling_uc_construct(struct port *p,
+						struct address *address,
+						struct PortIdentity *tpid)
+{
+	struct ptp_message *msg;
+
+	msg = port_signaling_construct(p, tpid);
+	if (!msg) {
+		return NULL;
+	}
+
 	msg->header.flagField[0] |= UNICAST;
 	msg->address = *address;
 
diff --git a/unicast_client.c b/unicast_client.c
index 91b99ed..e997672 100644
--- a/unicast_client.c
+++ b/unicast_client.c
@@ -68,7 +68,7 @@ static int unicast_client_announce(struct port *p,
 	struct ptp_message *msg;
 	int err;
 
-	msg = port_signaling_construct(p, &dst->address, &dst->portIdentity);
+	msg = port_signaling_uc_construct(p, &dst->address, &dst->portIdentity);
 	if (!msg) {
 		return -1;
 	}
@@ -129,7 +129,7 @@ static int unicast_client_peer_renew(struct port *p)
 	peer->renewal_tmo = 0;
 	pr_debug("port %d: time to renew P2P unicast subscription", portnum(p));
 
-	msg = port_signaling_construct(p, &peer->address, &peer->portIdentity);
+	msg = port_signaling_uc_construct(p, &peer->address, &peer->portIdentity);
 	if (!msg) {
 		return -1;
 	}
@@ -165,7 +165,7 @@ static int unicast_client_renew(struct port *p,
 	dst->renewal_tmo = 0;
 	pr_debug("port %d: time to renew unicast subscriptions", portnum(p));
 
-	msg = port_signaling_construct(p, &dst->address, &dst->portIdentity);
+	msg = port_signaling_uc_construct(p, &dst->address, &dst->portIdentity);
 	if (!msg) {
 		return -1;
 	}
@@ -225,7 +225,7 @@ static int unicast_client_sydy(struct port *p,
 	struct ptp_message *msg;
 	int err;
 
-	msg = port_signaling_construct(p, &dst->address, &dst->portIdentity);
+	msg = port_signaling_uc_construct(p, &dst->address, &dst->portIdentity);
 	if (!msg) {
 		return -1;
 	}
@@ -285,7 +285,7 @@ int unicast_client_cancel(struct port *p, struct ptp_message *m,
 	ucma->granted &= ~(1 << mtype);
 
 	/* Respond with ACK. */
-	msg = port_signaling_construct(p, &ucma->address, &ucma->portIdentity);
+	msg = port_signaling_uc_construct(p, &ucma->address, &ucma->portIdentity);
 	if (!msg) {
 		return -1;
 	}
diff --git a/unicast_service.c b/unicast_service.c
index 9c9b95b..ec5ee6c 100644
--- a/unicast_service.c
+++ b/unicast_service.c
@@ -241,8 +241,8 @@ static int unicast_service_reply(struct port *p, struct ptp_message *dst,
 	struct ptp_message *msg;
 	int err;
 
-	msg = port_signaling_construct(p, &dst->address,
-				       &dst->header.sourcePortIdentity);
+	msg = port_signaling_uc_construct(p, &dst->address,
+					  &dst->header.sourcePortIdentity);
 	if (!msg) {
 		return -1;
 	}
-- 
2.17.1


From 888afcdbae756e0a1bc5bfcbe3089a5f37e69d4e Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:27 -0700
Subject: [PATCH 047/173] port: Add logPdelayReqInterval.

It will be used to store the current value of Pdelay Request Interval.
It will be represented as power of two in seconds.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 port.c           | 7 ++++---
 port_private.h   | 1 +
 unicast_client.c | 4 ++--
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/port.c b/port.c
index b8ae77e..d86900d 100644
--- a/port.c
+++ b/port.c
@@ -1025,7 +1025,7 @@ static void port_nrate_calculate(struct port *p, tmv_t origin, tmv_t ingress)
 
 static void port_nrate_initialize(struct port *p)
 {
-	int shift = p->freq_est_interval - p->logMinPdelayReqInterval;
+	int shift = p->freq_est_interval - p->logPdelayReqInterval;
 
 	if (shift < 0)
 		shift = 0;
@@ -1058,7 +1058,7 @@ int port_set_delay_tmo(struct port *p)
 {
 	if (p->delayMechanism == DM_P2P) {
 		return set_tmo_log(p->fda.fd[FD_DELAY_TIMER], 1,
-			       p->logMinPdelayReqInterval);
+			       p->logPdelayReqInterval);
 	} else {
 		return set_tmo_random(p->fda.fd[FD_DELAY_TIMER], 0, 2,
 				p->logMinDelayReqInterval);
@@ -1254,7 +1254,7 @@ static int port_pdelay_request(struct port *p)
 	msg->header.sequenceId         = p->seqnum.delayreq++;
 	msg->header.control            = CTL_OTHER;
 	msg->header.logMessageInterval = port_is_ieee8021as(p) ?
-		p->logMinPdelayReqInterval : 0x7f;
+		p->logPdelayReqInterval : 0x7f;
 
 	if (unicast_client_enabled(p) && p->unicast_master_table->peer_name) {
 		msg->address = p->unicast_master_table->peer_addr.address;
@@ -1612,6 +1612,7 @@ int port_initialize(struct port *p)
 	p->localPriority           = config_get_int(cfg, p->name, "G.8275.portDS.localPriority");
 	p->logSyncInterval         = config_get_int(cfg, p->name, "logSyncInterval");
 	p->logMinPdelayReqInterval = config_get_int(cfg, p->name, "logMinPdelayReqInterval");
+	p->logPdelayReqInterval    = p->logMinPdelayReqInterval;
 	p->neighborPropDelayThresh = config_get_int(cfg, p->name, "neighborPropDelayThresh");
 	p->min_neighbor_prop_delay = config_get_int(cfg, p->name, "min_neighbor_prop_delay");
 
diff --git a/port_private.h b/port_private.h
index 1bc1c3f..37dc4b3 100644
--- a/port_private.h
+++ b/port_private.h
@@ -116,6 +116,7 @@ struct port {
 	Integer8            logSyncInterval;
 	Enumeration8        delayMechanism;
 	Integer8            logMinPdelayReqInterval;
+	Integer8            logPdelayReqInterval;
 	UInteger32          neighborPropDelayThresh;
 	int                 follow_up_info;
 	int                 freq_est_interval;
diff --git a/unicast_client.c b/unicast_client.c
index e997672..6495d6f 100644
--- a/unicast_client.c
+++ b/unicast_client.c
@@ -133,7 +133,7 @@ static int unicast_client_peer_renew(struct port *p)
 	if (!msg) {
 		return -1;
 	}
-	err = attach_request(msg, p->logMinPdelayReqInterval, PDELAY_RESP,
+	err = attach_request(msg, p->logPdelayReqInterval, PDELAY_RESP,
 			     p->unicast_req_duration);
 	if (err) {
 		goto out;
@@ -392,7 +392,7 @@ void unicast_client_grant(struct port *p, struct ptp_message *m,
 			unicast_client_set_renewal(p,
 				&p->unicast_master_table->peer_addr,
 				g->durationField);
-			p->logMinPdelayReqInterval = g->logInterMessagePeriod;
+			p->logPdelayReqInterval = g->logInterMessagePeriod;
 			return;
 		default:
 			break;
-- 
2.17.1


From 630ce719fc518227d59900a66d499de836987fc2 Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:28 -0700
Subject: [PATCH 048/173] port: implement message interval request processing

This implements transmission and receipt of message interval requests.
Using this mechanism, a time-aware device can request change in sync,
link delay and announce intervals on the device connected on the other
end.

As part of the commit, we are also saving the initial values of Announce
and Sync Interval.

For more information look at sections 10.2.4.4, 10.3.9.5, 10.3.14, 10.4,
10.5.4 and 11.2.17 of 802.1AS standard

Please note that this commit does not implement logic related to
computeNeighborRateRatio and computeNeighborPropDelay flags mentioned in
Section 10.5.4.3.9 of 802.1AS Standard.

[ RC - memset the targetPortIdentity to all ones. ]

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 msg.h            |  6 ++++
 port.c           |  6 ++--
 port_private.h   |  6 ++++
 port_signaling.c | 87 ++++++++++++++++++++++++++++++++++++++++++++++++
 tlv.c            |  4 +++
 tlv.h            | 12 +++++++
 6 files changed, 119 insertions(+), 2 deletions(-)

diff --git a/msg.h b/msg.h
index 02e45fd..c1294c2 100644
--- a/msg.h
+++ b/msg.h
@@ -57,6 +57,12 @@
 #define TIME_TRACEABLE (1<<4)
 #define FREQ_TRACEABLE (1<<5)
 
+/*
+ * Signaling interval special values. For more info look at 802.1AS table 10-11
+ */
+#define SIGNAL_NO_CHANGE   -128
+#define SIGNAL_SET_INITIAL 126
+
 enum timestamp_type {
 	TS_SOFTWARE,
 	TS_HARDWARE,
diff --git a/port.c b/port.c
index d86900d..982daf2 100644
--- a/port.c
+++ b/port.c
@@ -1601,7 +1601,8 @@ int port_initialize(struct port *p)
 	p->last_fault_type         = FT_UNSPECIFIED;
 	p->logMinDelayReqInterval  = config_get_int(cfg, p->name, "logMinDelayReqInterval");
 	p->peerMeanPathDelay       = 0;
-	p->logAnnounceInterval     = config_get_int(cfg, p->name, "logAnnounceInterval");
+	p->initialLogAnnounceInterval = config_get_int(cfg, p->name, "logAnnounceInterval");
+	p->logAnnounceInterval     = p->initialLogAnnounceInterval;
 	p->inhibit_announce        = config_get_int(cfg, p->name, "inhibit_announce");
 	p->ignore_source_id        = config_get_int(cfg, p->name, "ignore_source_id");
 	p->announceReceiptTimeout  = config_get_int(cfg, p->name, "announceReceiptTimeout");
@@ -1610,7 +1611,8 @@ int port_initialize(struct port *p)
 	p->transportSpecific     <<= 4;
 	p->match_transport_specific = !config_get_int(cfg, p->name, "ignore_transport_specific");
 	p->localPriority           = config_get_int(cfg, p->name, "G.8275.portDS.localPriority");
-	p->logSyncInterval         = config_get_int(cfg, p->name, "logSyncInterval");
+	p->initialLogSyncInterval  = config_get_int(cfg, p->name, "logSyncInterval");
+	p->logSyncInterval         = p->initialLogSyncInterval;
 	p->logMinPdelayReqInterval = config_get_int(cfg, p->name, "logMinPdelayReqInterval");
 	p->logPdelayReqInterval    = p->logMinPdelayReqInterval;
 	p->neighborPropDelayThresh = config_get_int(cfg, p->name, "neighborPropDelayThresh");
diff --git a/port_private.h b/port_private.h
index 37dc4b3..d28ab07 100644
--- a/port_private.h
+++ b/port_private.h
@@ -107,12 +107,14 @@ struct port {
 	enum as_capable     asCapable;
 	Integer8            logMinDelayReqInterval;
 	TimeInterval        peerMeanPathDelay;
+	Integer8            initialLogAnnounceInterval;
 	Integer8            logAnnounceInterval;
 	UInteger8           announceReceiptTimeout;
 	int                 announce_span;
 	UInteger8           syncReceiptTimeout;
 	UInteger8           transportSpecific;
 	UInteger8           localPriority;
+	Integer8            initialLogSyncInterval;
 	Integer8            logSyncInterval;
 	Enumeration8        delayMechanism;
 	Integer8            logMinPdelayReqInterval;
@@ -174,6 +176,10 @@ struct ptp_message *port_signaling_uc_construct(struct port *p,
 						struct address *address,
 						struct PortIdentity *tpid);
 int port_tx_announce(struct port *p, struct address *dst);
+int port_tx_interval_request(struct port *p,
+			     Integer8 announceInterval,
+			     Integer8 timeSyncInterval,
+			     Integer8 linkDelayInterval);
 int port_tx_sync(struct port *p, struct address *dst);
 int process_announce(struct port *p, struct ptp_message *m);
 void process_delay_resp(struct port *p, struct ptp_message *m);
diff --git a/port_signaling.c b/port_signaling.c
index 09d4506..c4d5469 100644
--- a/port_signaling.c
+++ b/port_signaling.c
@@ -17,7 +17,9 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA.
  */
+#include "port.h"
 #include "port_private.h"
+#include "print.h"
 #include "unicast_client.h"
 #include "unicast_service.h"
 
@@ -68,9 +70,43 @@ struct ptp_message *port_signaling_uc_construct(struct port *p,
 	return msg;
 }
 
+static int8_t set_interval(int8_t current_interval,
+			   int8_t new_interval,
+			   int8_t initial_interval)
+{
+	switch (new_interval) {
+	case SIGNAL_NO_CHANGE:
+		return current_interval;
+	case SIGNAL_SET_INITIAL:
+		return initial_interval;
+	default:
+		return new_interval;
+	}
+}
+
+static int process_interval_request(struct port *p,
+				    struct msg_interval_req_tlv *r)
+{
+
+	p->logAnnounceInterval = set_interval(p->logAnnounceInterval,
+					      r->announceInterval,
+					      p->initialLogAnnounceInterval);
+
+	p->logSyncInterval = set_interval(p->logSyncInterval,
+					  r->timeSyncInterval,
+					  p->initialLogSyncInterval);
+
+	p->logPdelayReqInterval = set_interval(p->logPdelayReqInterval,
+					       r->linkDelayInterval,
+					       p->logMinPdelayReqInterval);
+
+	return 0;
+}
+
 int process_signaling(struct port *p, struct ptp_message *m)
 {
 	struct tlv_extra *extra;
+	struct msg_interval_req_tlv *r;
 	int err = 0, result;
 
 	switch (p->state) {
@@ -122,7 +158,58 @@ int process_signaling(struct port *p, struct ptp_message *m)
 
 		case TLV_ACKNOWLEDGE_CANCEL_UNICAST_TRANSMISSION:
 			break;
+
+		case TLV_ORGANIZATION_EXTENSION:
+			r = (struct msg_interval_req_tlv *) extra->tlv;
+
+			if (0 == memcmp(r->id, ieee8021_id, sizeof(ieee8021_id)) &&
+			    r->subtype[0] == 0 && r->subtype[1] == 0 && r->subtype[2] == 2)
+				err = process_interval_request(p, r);
+			break;
 		}
 	}
 	return err;
 }
+
+int port_tx_interval_request(struct port *p,
+			     Integer8 announceInterval,
+			     Integer8 timeSyncInterval,
+			     Integer8 linkDelayInterval)
+{
+	struct msg_interval_req_tlv *mir;
+	struct PortIdentity tpid;
+	struct ptp_message *msg;
+	struct tlv_extra *extra;
+	int err;
+
+	if (!port_capable(p)) {
+		return 0;
+	}
+	memset(&tpid, 0xff, sizeof(tpid));
+	msg = port_signaling_construct(p, &tpid);
+	if (!msg) {
+		return -1;
+	}
+	extra = msg_tlv_append(msg, sizeof(*mir));
+	if (!extra) {
+		err = -1;
+		goto out;
+	}
+	mir = (struct msg_interval_req_tlv *) extra->tlv;
+	mir->type = TLV_ORGANIZATION_EXTENSION;
+	mir->length = sizeof(*mir) - sizeof(mir->type) - sizeof(mir->length);
+	memcpy(mir->id, ieee8021_id, sizeof(ieee8021_id));
+	mir->subtype[2] = 2;
+	mir->timeSyncInterval = timeSyncInterval;
+	mir->announceInterval = announceInterval;
+	mir->linkDelayInterval = linkDelayInterval;
+	mir->flags = 0;
+
+	err = port_prepare_and_send(p, msg, TRANS_GENERAL);
+	if (err) {
+		pr_err("port %hu: send signaling failed", portnum(p));
+	}
+out:
+	msg_put(msg);
+	return err;
+}
diff --git a/tlv.c b/tlv.c
index b647160..6a5387e 100644
--- a/tlv.c
+++ b/tlv.c
@@ -517,6 +517,10 @@ static int org_post_recv(struct organization_tlv *org)
 			scaled_ns_n2h(&f->lastGmPhaseChange);
 			f->scaledLastGmPhaseChange = ntohl(f->scaledLastGmPhaseChange);
 			break;
+
+		case 2:
+			if (org->length + sizeof(struct TLV) != sizeof(struct msg_interval_req_tlv))
+				goto bad_length;
 		}
 	}
 	return 0;
diff --git a/tlv.h b/tlv.h
index 958555c..bcbfdd9 100644
--- a/tlv.h
+++ b/tlv.h
@@ -230,6 +230,18 @@ struct follow_up_info_tlv {
 	Integer32     scaledLastGmPhaseChange;
 } PACKED;
 
+struct msg_interval_req_tlv {
+	Enumeration16 type;
+	UInteger16    length;
+	Octet         id[3];
+	Octet         subtype[3];
+	Integer8      linkDelayInterval;
+	Integer8      timeSyncInterval;
+	Integer8      announceInterval;
+	Octet         flags;
+	Octet         reserved[2];
+} PACKED;
+
 struct time_status_np {
 	int64_t       master_offset; /*nanoseconds*/
 	int64_t       ingress_time;  /*nanoseconds*/
-- 
2.17.1


From 78b4b780da5589eb4e2a69bc7c322b3a81c68daf Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:29 -0700
Subject: [PATCH 049/173] clock: add APIs to access servo and servo_state

Make servo and it's current state available outside clock.c

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 clock.c | 10 ++++++++++
 clock.h | 14 ++++++++++++++
 2 files changed, 24 insertions(+)

diff --git a/clock.c b/clock.c
index 8533b39..beca9d6 100644
--- a/clock.c
+++ b/clock.c
@@ -1835,3 +1835,13 @@ double clock_rate_ratio(struct clock *c)
 	}
 	return servo_rate_ratio(c->servo);
 }
+
+struct servo *clock_servo(struct clock *c)
+{
+	return c->servo;
+}
+
+enum servo_state clock_servo_state(struct clock *c)
+{
+	return c->servo_state;
+}
diff --git a/clock.h b/clock.h
index 07aba18..9d3133a 100644
--- a/clock.h
+++ b/clock.h
@@ -253,6 +253,20 @@ void clock_set_sde(struct clock *c, int sde);
  */
 int clock_poll(struct clock *c);
 
+/**
+ * Obtain the servo struct.
+ * @param c The clock instance.
+ * @return  A pointer to the clock's servo.
+ */
+struct servo *clock_servo(struct clock *c);
+
+/**
+ * Obtain the current state of clock's servo.
+ * @param c The clock instance.
+ * @return  The current state of the clock's servo.
+ */
+enum servo_state clock_servo_state(struct clock *c);
+
 /**
  * Obtain the slave-only flag from a clock's default data set.
  * @param c  The clock instance.
-- 
2.17.1


From 3f5f5653d7966da8ba96d64fbf74aa472e9f078c Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:30 -0700
Subject: [PATCH 050/173] port: Add interval update mechanism.

This commit adds functionality to increase the sync and pdelay request
intervals once gptp synchronization has been achieved. This is useful
while running Automotive Profile where the network is usually static.

Here, we are assuming that the gPTP synchronization is achieved whenever
the last 'n' offsets calculated using the Sync messages are below a
certain threshold. Both, the number of offsets to consider and the offset
threshold are configurable.

In order to support the interval update, a new clock servo state
CLOCK_SERVO_STABLE has been added. The clock will transition to this
state whenever the above condition is satisfied. When this transition
occurs, the slave will send an "interval request" signaling message
asking the master to change the sync interval. It will also update the
pdelay request interval locally.

Four new config options have been added to provide this functionality:

- servo_offset_threshold: All the offset values being considered should
  be below this value.
- servo_num_offset_values: number of previously received offset values
  to consider.
- operLogSyncInterval: slave will ask the master to switch to this
  interval for sending sync messages when the offset stabilizes.
- operLogPdelayReqInterval: the slave will set this interval for pdelay
  request messages when the offset stabilizes.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 clock.c                      |  1 +
 config.c                     |  4 ++++
 configs/automotive-slave.cfg |  4 ++++
 configs/default.cfg          |  4 ++++
 phc2sys.c                    |  1 +
 port.c                       | 44 +++++++++++++++++++++++++++++++----
 port_private.h               |  2 ++
 ptp4l.8                      | 30 ++++++++++++++++++++++++
 servo.c                      | 45 +++++++++++++++++++++++++++++++++++-
 servo.h                      | 13 +++++++++++
 servo_private.h              |  3 +++
 11 files changed, 145 insertions(+), 6 deletions(-)

diff --git a/clock.c b/clock.c
index beca9d6..642f688 100644
--- a/clock.c
+++ b/clock.c
@@ -1690,6 +1690,7 @@ enum servo_state clock_synchronize(struct clock *c, tmv_t ingress, tmv_t origin)
 		tsproc_reset(c->tsproc, 0);
 		break;
 	case SERVO_LOCKED:
+	case SERVO_LOCKED_STABLE:
 		clockadj_set_freq(c->clkid, -adj);
 		if (c->clkid == CLOCK_REALTIME) {
 			sysclk_set_sync();
diff --git a/config.c b/config.c
index 2321310..0da7ce4 100644
--- a/config.c
+++ b/config.c
@@ -263,6 +263,8 @@ struct config_item config_tab[] = {
 	PORT_ITEM_ENU("network_transport", TRANS_UDP_IPV4, nw_trans_enu),
 	GLOB_ITEM_INT("ntpshm_segment", 0, INT_MIN, INT_MAX),
 	GLOB_ITEM_INT("offsetScaledLogVariance", 0xffff, 0, UINT16_MAX),
+	PORT_ITEM_INT("operLogPdelayReqInterval", 0, INT8_MIN, INT8_MAX),
+	PORT_ITEM_INT("operLogSyncInterval", 0, INT8_MIN, INT8_MAX),
 	PORT_ITEM_INT("path_trace_enabled", 0, 0, 1),
 	GLOB_ITEM_DBL("pi_integral_const", 0.0, 0.0, DBL_MAX),
 	GLOB_ITEM_DBL("pi_integral_exponent", 0.4, -DBL_MAX, DBL_MAX),
@@ -279,6 +281,8 @@ struct config_item config_tab[] = {
 	PORT_ITEM_STR("p2p_dst_mac", "01:80:C2:00:00:0E"),
 	GLOB_ITEM_STR("revisionData", ";;"),
 	GLOB_ITEM_INT("sanity_freq_limit", 200000000, 0, INT_MAX),
+	GLOB_ITEM_INT("servo_num_offset_values", 10, 0, INT_MAX),
+	GLOB_ITEM_INT("servo_offset_threshold", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("slaveOnly", 0, 0, 1),
 	GLOB_ITEM_DBL("step_threshold", 0.0, 0.0, DBL_MAX),
 	GLOB_ITEM_INT("summary_interval", 0, INT_MIN, INT_MAX),
diff --git a/configs/automotive-slave.cfg b/configs/automotive-slave.cfg
index 94d45b6..8cc7221 100644
--- a/configs/automotive-slave.cfg
+++ b/configs/automotive-slave.cfg
@@ -31,3 +31,7 @@ asCapable               true
 ignore_source_id	1
 # Required to quickly correct Time Jumps in master
 step_threshold          1
+operLogSyncInterval     0
+operLogPdelayReqInterval 2
+servo_offset_threshold   30
+servo_num_offset_values  10
diff --git a/configs/default.cfg b/configs/default.cfg
index 3ee3a9b..2433553 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -23,8 +23,10 @@ maxStepsRemoved		255
 #
 logAnnounceInterval	1
 logSyncInterval		0
+operLogSyncInterval	0
 logMinDelayReqInterval	0
 logMinPdelayReqInterval	0
+operLogPdelayReqInterval 0
 announceReceiptTimeout	3
 syncReceiptTimeout	0
 delayAsymmetry		0
@@ -73,6 +75,8 @@ max_frequency		900000000
 clock_servo		pi
 sanity_freq_limit	200000000
 ntpshm_segment		0
+servo_num_offset_values 10
+servo_offset_threshold  0
 #
 # Transport options
 #
diff --git a/phc2sys.c b/phc2sys.c
index a476e63..cc48f18 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -619,6 +619,7 @@ static void update_clock(struct node *node, struct clock *clock,
 			clockcheck_step(clock->sanity_check, -offset);
 		/* Fall through. */
 	case SERVO_LOCKED:
+	case SERVO_LOCKED_STABLE:
 		clockadj_set_freq(clock->clkid, -ppb);
 		if (clock->clkid == CLOCK_REALTIME)
 			sysclk_set_sync();
diff --git a/port.c b/port.c
index 982daf2..0aaf846 100644
--- a/port.c
+++ b/port.c
@@ -1110,10 +1110,12 @@ static void port_slave_priority_warning(struct port *p)
 static void port_synchronize(struct port *p,
 			     tmv_t ingress_ts,
 			     struct timestamp origin_ts,
-			     Integer64 correction1, Integer64 correction2)
+			     Integer64 correction1, Integer64 correction2,
+			     Integer8 sync_interval)
 {
-	enum servo_state state;
+	enum servo_state state, last_state;
 	tmv_t t1, t1c, t2, c1, c2;
+	struct servo *s;
 
 	port_set_sync_rx_tmo(p);
 
@@ -1123,10 +1125,20 @@ static void port_synchronize(struct port *p,
 	c2 = correction_to_tmv(correction2);
 	t1c = tmv_add(t1, tmv_add(c1, c2));
 
+	s = clock_servo(p->clock);
+	last_state = clock_servo_state(p->clock);
 	state = clock_synchronize(p->clock, t2, t1c);
 	switch (state) {
 	case SERVO_UNLOCKED:
 		port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
+		if (servo_offset_threshold(s) != 0 &&
+		    sync_interval != p->initialLogSyncInterval) {
+			p->logPdelayReqInterval = p->logMinPdelayReqInterval;
+			p->logSyncInterval = p->initialLogSyncInterval;
+			port_tx_interval_request(p, SIGNAL_NO_CHANGE,
+						 SIGNAL_SET_INITIAL,
+						 SIGNAL_NO_CHANGE);
+		}
 		break;
 	case SERVO_JUMP:
 		port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
@@ -1139,6 +1151,23 @@ static void port_synchronize(struct port *p,
 	case SERVO_LOCKED:
 		port_dispatch(p, EV_MASTER_CLOCK_SELECTED, 0);
 		break;
+	case SERVO_LOCKED_STABLE:
+		if (last_state == SERVO_LOCKED) {
+			p->logPdelayReqInterval = p->operLogPdelayReqInterval;
+			p->logSyncInterval = p->operLogSyncInterval;
+			port_tx_interval_request(p, SIGNAL_NO_CHANGE,
+						 p->logSyncInterval,
+						 SIGNAL_NO_CHANGE);
+			port_dispatch(p, EV_MASTER_CLOCK_SELECTED, 0);
+		} else if (sync_interval != p->operLogSyncInterval) {
+			/*
+			 * The most likely reason for this to happen is the
+			 * master daemon re-initialized due to some fault.
+			 */
+			servo_reset(s);
+			port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
+		}
+		break;
 	}
 }
 
@@ -1192,7 +1221,8 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 			syn = p->last_syncfup;
 			port_synchronize(p, syn->hwts.ts, m->ts.pdu,
 					 syn->header.correction,
-					 m->header.correction);
+					 m->header.correction,
+					 m->header.logMessageInterval);
 			msg_put(p->last_syncfup);
 			p->syfu = SF_EMPTY;
 			break;
@@ -1211,7 +1241,8 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 			fup = p->last_syncfup;
 			port_synchronize(p, m->hwts.ts, fup->ts.pdu,
 					 m->header.correction,
-					 fup->header.correction);
+					 fup->header.correction,
+					 m->header.logMessageInterval);
 			msg_put(p->last_syncfup);
 			p->syfu = SF_EMPTY;
 			break;
@@ -1613,8 +1644,10 @@ int port_initialize(struct port *p)
 	p->localPriority           = config_get_int(cfg, p->name, "G.8275.portDS.localPriority");
 	p->initialLogSyncInterval  = config_get_int(cfg, p->name, "logSyncInterval");
 	p->logSyncInterval         = p->initialLogSyncInterval;
+	p->operLogSyncInterval     = config_get_int(cfg, p->name, "operLogSyncInterval");
 	p->logMinPdelayReqInterval = config_get_int(cfg, p->name, "logMinPdelayReqInterval");
 	p->logPdelayReqInterval    = p->logMinPdelayReqInterval;
+	p->operLogPdelayReqInterval = config_get_int(cfg, p->name, "operLogPdelayReqInterval");
 	p->neighborPropDelayThresh = config_get_int(cfg, p->name, "neighborPropDelayThresh");
 	p->min_neighbor_prop_delay = config_get_int(cfg, p->name, "min_neighbor_prop_delay");
 
@@ -2224,7 +2257,8 @@ void process_sync(struct port *p, struct ptp_message *m)
 
 	if (one_step(m)) {
 		port_synchronize(p, m->hwts.ts, m->ts.pdu,
-				 m->header.correction, 0);
+				 m->header.correction, 0,
+				 m->header.logMessageInterval);
 		flush_last_sync(p);
 		return;
 	}
diff --git a/port_private.h b/port_private.h
index d28ab07..bb1d86e 100644
--- a/port_private.h
+++ b/port_private.h
@@ -115,9 +115,11 @@ struct port {
 	UInteger8           transportSpecific;
 	UInteger8           localPriority;
 	Integer8            initialLogSyncInterval;
+	Integer8	    operLogSyncInterval;
 	Integer8            logSyncInterval;
 	Enumeration8        delayMechanism;
 	Integer8            logMinPdelayReqInterval;
+	Integer8            operLogPdelayReqInterval;
 	Integer8            logPdelayReqInterval;
 	UInteger32          neighborPropDelayThresh;
 	int                 follow_up_info;
diff --git a/ptp4l.8 b/ptp4l.8
index 46e6715..df7da82 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -161,6 +161,13 @@ The mean time interval between Sync messages. A shorter interval may improve
 accuracy of the local clock. It's specified as a power of two in seconds.
 The default is 0 (1 second).
 .TP
+.B operLogSyncInterval
+The mean time interval between Sync messages. This value is only used by the
+slave device when interval_update_timer is enabled. Slave will send this
+interval to the master to switch to. This is done via a signaling message after
+interval_update_timer expires. It's specified as a power of two in seconds. The
+default value is 0 (1 second).
+.TP
 .B logMinDelayReqInterval
 The minimum permitted mean time interval between Delay_Req messages. A shorter
 interval makes ptp4l react faster to the changes in the path delay. It's
@@ -172,6 +179,13 @@ The minimum permitted mean time interval between Pdelay_Req messages. It's
 specified as a power of two in seconds.
 The default is 0 (1 second).
 .TP
+.B operLogPdelayReqInterval
+The mean time interval between Pdelay Request messages. This value is only used
+by the slave device when interval_update_timer is enabled. Slave will switch to
+the interval specified by this config option after the interval_update_timer
+expires. It's specified as a power of two in seconds. The default value is 0 (1
+second).
+.TP
 .B announceReceiptTimeout
 The number of missed Announce messages before the last Announce messages
 expires.
@@ -715,6 +729,22 @@ This will disable source port identity checking for Sync and Follow_Up
 messages. This is useful when the announce messages are disabled in the master
 and the slave does not have any way to know it's identity. The default is 0
 (disabled).
+.TP
+.B servo_num_offset_values
+The number of offset values calculated in previously received Sync messages to
+consider when adjusting the Sync and Pdelay request intervals. More information
+provided in the description of 'offset_threshold'. The default value is 10.
+.TP
+.B servo_offset_threshold
+This value is used by the slave for adjusting the intervals for Sync and Pdelay
+request messages. The slave will check the last 'num_offset_values' offsets and
+if all those offsets are less than the offset_threshold, it will adjust both
+the intervals. The Sync interval is adjusted via the signaling mechanism and
+the pdelay request interval is just adjusted locally. The new values to use for
+sync message intervals and pdelay request intervals can be indicated by
+operLogSyncInterval and operLogPdelayReqInterval respectively. This mechanism
+is currently only supported when BMCA == 'noop'. The default
+value of offset_threshold is 0 (disabled).
 
 .SH UNICAST DISCOVERY OPTIONS
 
diff --git a/servo.c b/servo.c
index 8be4b92..46042aa 100644
--- a/servo.c
+++ b/servo.c
@@ -17,6 +17,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 #include <string.h>
+#include <stdlib.h>
 
 #include "config.h"
 #include "linreg.h"
@@ -25,6 +26,8 @@
 #include "pi.h"
 #include "servo_private.h"
 
+#include "print.h"
+
 #define NSEC_PER_SEC 1000000000
 
 struct servo *servo_create(struct config *cfg, enum servo_type type,
@@ -79,6 +82,9 @@ struct servo *servo_create(struct config *cfg, enum servo_type type,
 	}
 
 	servo->first_update = 1;
+	servo->offset_threshold = config_get_int(cfg, NULL, "servo_offset_threshold");
+	servo->num_offset_values = config_get_int(cfg, NULL, "servo_num_offset_values");
+	servo->curr_offset_values = servo->num_offset_values;
 
 	return servo;
 }
@@ -88,6 +94,18 @@ void servo_destroy(struct servo *servo)
 	servo->destroy(servo);
 }
 
+static int check_offset_threshold(struct servo *s, int64_t offset)
+{
+	long long int abs_offset = llabs(offset);
+
+	if (s->offset_threshold) {
+		if (abs_offset < s->offset_threshold && s->curr_offset_values)
+			s->curr_offset_values--;
+		return s->curr_offset_values ? 0 : 1;
+	}
+	return 0;
+}
+
 double servo_sample(struct servo *servo,
 		    int64_t offset,
 		    uint64_t local_ts,
@@ -98,8 +116,28 @@ double servo_sample(struct servo *servo,
 
 	r = servo->sample(servo, offset, local_ts, weight, state);
 
-	if (*state != SERVO_UNLOCKED)
+	switch (*state) {
+	case SERVO_UNLOCKED:
+		servo->curr_offset_values = servo->num_offset_values;
+		break;
+	case SERVO_JUMP:
+		servo->curr_offset_values = servo->num_offset_values;
 		servo->first_update = 0;
+		break;
+	case SERVO_LOCKED:
+		if (check_offset_threshold(servo, offset)) {
+			*state = SERVO_LOCKED_STABLE;
+		}
+		servo->first_update = 0;
+		break;
+	case SERVO_LOCKED_STABLE:
+		/*
+		 * This case will never occur since the only place
+		 * SERVO_LOCKED_STABLE is set is in this switch/case block
+		 * (case SERVO_LOCKED).
+		 */
+		break;
+	}
 
 	return r;
 }
@@ -127,3 +165,8 @@ void servo_leap(struct servo *servo, int leap)
 	if (servo->leap)
 		servo->leap(servo, leap);
 }
+
+int servo_offset_threshold(struct servo *servo)
+{
+	return servo->offset_threshold;
+}
diff --git a/servo.h b/servo.h
index f90befd..6c30d33 100644
--- a/servo.h
+++ b/servo.h
@@ -57,6 +57,12 @@ enum servo_state {
 	 * The servo is tracking the master clock.
 	 */
 	SERVO_LOCKED,
+
+	/**
+	 * The Servo has stabilized. The last 'servo_num_offset_values' values
+	 * of the estimated threshold are less than servo_offset_threshold.
+	 */
+	SERVO_LOCKED_STABLE,
 };
 
 /**
@@ -123,4 +129,11 @@ double servo_rate_ratio(struct servo *servo);
  */
 void servo_leap(struct servo *servo, int leap);
 
+/**
+ * Get the offset threshold for triggering the interval change request.
+ * @param servo   Pointer to a servo obtained via @ref servo_create().
+ * @return        The offset threshold set by the user.
+ */
+int servo_offset_threshold(struct servo *servo);
+
 #endif
diff --git a/servo_private.h b/servo_private.h
index 1c5cfdf..4d74ca2 100644
--- a/servo_private.h
+++ b/servo_private.h
@@ -29,6 +29,9 @@ struct servo {
 	double step_threshold;
 	double first_step_threshold;
 	int first_update;
+	int64_t offset_threshold;
+	int num_offset_values;
+	int curr_offset_values;
 
 	void (*destroy)(struct servo *servo);
 
-- 
2.17.1


From 450b1ed844f6f5e0e2a0881b08a0afd1d6a2d76a Mon Sep 17 00:00:00 2001
From: Vedang Patel <vedang.patel@intel.com>
Date: Thu, 28 Mar 2019 20:32:31 -0700
Subject: [PATCH 051/173] port: Add inhibit_delay_req.

Add provision to disable delay requests. Designated masters who do not
need to calculate pdelay can use this option. This is required by
Automotive Profile to reduce network load.

Signed-off-by: Vedang Patel <vedang.patel@intel.com>
---
 config.c                      |  3 ++-
 configs/automotive-master.cfg |  1 +
 configs/default.cfg           |  1 +
 port.c                        | 10 ++++++++++
 port_private.h                |  1 +
 ptp4l.8                       |  5 +++++
 6 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/config.c b/config.c
index 0da7ce4..93ea5da 100644
--- a/config.c
+++ b/config.c
@@ -244,8 +244,9 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("ignore_transport_specific", 0, 0, 1),
 	PORT_ITEM_INT("ingressLatency", 0, INT_MIN, INT_MAX),
 	PORT_ITEM_INT("inhibit_announce", 0, 0, 1),
-	PORT_ITEM_INT("inhibit_multicast_service", 0, 0, 1),
 	GLOB_ITEM_INT("initial_delay", 0, 0, INT_MAX),
+	PORT_ITEM_INT("inhibit_delay_req", 0, 0, 1),
+	PORT_ITEM_INT("inhibit_multicast_service", 0, 0, 1),
 	GLOB_ITEM_INT("kernel_leap", 1, 0, 1),
 	PORT_ITEM_INT("logAnnounceInterval", 1, INT8_MIN, INT8_MAX),
 	PORT_ITEM_INT("logMinDelayReqInterval", 0, INT8_MIN, INT8_MAX),
diff --git a/configs/automotive-master.cfg b/configs/automotive-master.cfg
index e3ad5a3..2edee76 100644
--- a/configs/automotive-master.cfg
+++ b/configs/automotive-master.cfg
@@ -26,3 +26,4 @@ BMCA			noop
 masterOnly		1
 inhibit_announce	1
 asCapable               true
+inhibit_delay_req       1
diff --git a/configs/default.cfg b/configs/default.cfg
index 2433553..e23dfd7 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -37,6 +37,7 @@ G.8275.portDS.localPriority	128
 asCapable               auto
 BMCA                    ptp
 inhibit_announce        0
+inhibit_pdelay_req      0
 ignore_source_id        0
 #
 # Run time options
diff --git a/port.c b/port.c
index 0aaf846..5a4a116 100644
--- a/port.c
+++ b/port.c
@@ -1056,6 +1056,10 @@ int port_set_announce_tmo(struct port *p)
 
 int port_set_delay_tmo(struct port *p)
 {
+	if (p->inhibit_delay_req) {
+		return 0;
+	}
+
 	if (p->delayMechanism == DM_P2P) {
 		return set_tmo_log(p->fda.fd[FD_DELAY_TIMER], 1,
 			       p->logPdelayReqInterval);
@@ -1657,6 +1661,12 @@ int port_initialize(struct port *p)
 		p->asCapable = NOT_CAPABLE;
 	}
 
+	p->inhibit_delay_req = config_get_int(cfg, p->name, "inhibit_delay_req");
+	if (p->inhibit_delay_req && p->asCapable != ALWAYS_CAPABLE) {
+		pr_err("inhibit_delay_req can only be set when asCapable == 'true'.");
+		return -1;
+	}
+
 	for (i = 0; i < N_TIMER_FDS; i++) {
 		fd[i] = -1;
 	}
diff --git a/port_private.h b/port_private.h
index bb1d86e..9a5022d 100644
--- a/port_private.h
+++ b/port_private.h
@@ -100,6 +100,7 @@ struct port {
 	int bmca;
 	int inhibit_announce;
 	int ignore_source_id;
+	int inhibit_delay_req;
 	/* portDS */
 	struct PortIdentity portIdentity;
 	enum port_state     state; /*portState*/
diff --git a/ptp4l.8 b/ptp4l.8
index df7da82..1a01108 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -186,6 +186,11 @@ the interval specified by this config option after the interval_update_timer
 expires. It's specified as a power of two in seconds. The default value is 0 (1
 second).
 .TP
+.B inhibit_delay_req
+Don't send any delay requests. This will need the asCapable config option to be
+set to 'true'. This is useful when running as a designated master who does not
+need to calculate offset from slave. The default is 0 (disabled).
+.TP
 .B announceReceiptTimeout
 The number of missed Announce messages before the last Announce messages
 expires.
-- 
2.17.1


From 268be957d275e367a86830d8b8c3724515a05785 Mon Sep 17 00:00:00 2001
From: Hangbin Liu <liuhangbin@gmail.com>
Date: Fri, 22 Mar 2019 15:02:46 +0800
Subject: [PATCH 052/173] rtnl: add team activebackup support

This patch add team interface activebackup mode support. As linux team use
genl netlink message, when we get a rtnl link change notify, we have to setup
a new genl socket and request the current active port.

v2: check nlmsg_len before copy rta_data
v3: a) Do not make rtnl_buf global as it may be freed by calling rtnl_close()
       while we are using it in rtnl_link_status()
    b) Reorder declarations of variables as reversed Christmas tree for
       function rtnl_link_status()
    c) remove rtnl_len
v4: Remove the first !rtnl_buf check in rtnl_link_status as it's alway true
v5: a) Re-order {nl, rtnl}_open and add function nl_close()
    b) revert the v3_{a,c}, v4 changes, use nl_close to close genl fd
    c) do not use len in get_team_active_iface() as it may mislead reader
v6: Return index at the end to fix fd leak in get_team_active_iface()

Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
---
 missing.h |  16 ++++
 phc2sys.8 |   4 +-
 rtnl.c    | 243 ++++++++++++++++++++++++++++++++++++++++++++++++------
 3 files changed, 234 insertions(+), 29 deletions(-)

diff --git a/missing.h b/missing.h
index 2f7adb9..8f92079 100644
--- a/missing.h
+++ b/missing.h
@@ -118,6 +118,22 @@ enum {
 #define IFLA_BOND_MAX   (__IFLA_BOND_MAX - 1)
 #endif	/*IFLA_BOND_MAX*/
 
+#ifndef NLA_TYPE_MAX
+enum {
+        NLA_UNSPEC,
+        NLA_U8,
+        NLA_U16,
+        NLA_U32,
+        NLA_U64,
+        NLA_STRING,
+        NLA_FLAG,
+        NLA_MSECS,
+        NLA_NESTED,
+        __NLA_TYPE_MAX,
+};
+#define NLA_TYPE_MAX (__NLA_TYPE_MAX - 1)
+#endif /*NLA_TYPE_MAX*/
+
 #ifdef __UCLIBC__
 
 #if (_XOPEN_SOURCE >= 600 || _POSIX_C_SOURCE >= 200112L) && \
diff --git a/phc2sys.8 b/phc2sys.8
index 45cb0e3..b3a3de3 100644
--- a/phc2sys.8
+++ b/phc2sys.8
@@ -108,9 +108,9 @@ together with the
 option, the master clock is used only to correct the offset by whole number of
 seconds, which cannot be fixed with PPS alone. Not compatible with the
 .B \-a
-option. This option does not support bonded interface (e.g. bond0). If
+option. This option does not support bonded interface (e.g. bond0, team0). If
 .B ptp4l
-has a port on an active-backup bond interface, the
+has a port on an active-backup bond or team interface, the
 .B \-a
 option can be used to track the active interface.
 .TP
diff --git a/rtnl.c b/rtnl.c
index f9a572b..59ed0ec 100644
--- a/rtnl.c
+++ b/rtnl.c
@@ -20,6 +20,8 @@
 #include <sys/socket.h> /* Must come before linux/netlink.h on some systems. */
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
+#include <linux/genetlink.h>
+#include <linux/if_team.h>
 #include <net/if.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -30,8 +32,39 @@
 #include "print.h"
 #include "rtnl.h"
 
+#define BUF_SIZE 4096
+#define GENLMSG_DATA(glh) ((void *)(NLMSG_DATA(glh) + GENL_HDRLEN))
+
 static int rtnl_len;
 static char *rtnl_buf;
+static int get_team_active_iface(int master_index);
+
+static int nl_close(int fd)
+{
+	return close(fd);
+}
+
+static int nl_open(int family)
+{
+	int fd;
+	struct sockaddr_nl sa;
+
+	memset(&sa, 0, sizeof(sa));
+	sa.nl_family = AF_NETLINK;
+	sa.nl_groups = RTNLGRP_LINK;
+
+	fd = socket(AF_NETLINK, SOCK_RAW, family);
+	if (fd < 0) {
+		pr_err("failed to open netlink socket: %m");
+		return -1;
+	}
+	if (bind(fd, (struct sockaddr *) &sa, sizeof(sa))) {
+		pr_err("failed to bind netlink socket: %m");
+		close(fd);
+		return -1;
+	}
+	return fd;
+}
 
 int rtnl_close(int fd)
 {
@@ -40,7 +73,12 @@ int rtnl_close(int fd)
 		rtnl_buf = NULL;
 		rtnl_len = 0;
 	}
-	return close(fd);
+	return nl_close(fd);
+}
+
+int rtnl_open(void)
+{
+	return nl_open(NETLINK_ROUTE);
 }
 
 static void rtnl_get_ts_device_callback(void *ctx, int linkup, int ts_index)
@@ -116,14 +154,24 @@ int rtnl_link_query(int fd, char *device)
 	return 0;
 }
 
-static inline __u32 rta_getattr_u32(const struct rtattr *rta)
+static inline __u8 rta_getattr_u8(struct rtattr *rta)
+{
+	return *(__u8 *)RTA_DATA(rta);
+}
+
+static inline __u16 rta_getattr_u16(struct rtattr *rta)
+{
+	return *(__u16 *)RTA_DATA(rta);
+}
+
+static inline __u32 rta_getattr_u32(struct rtattr *rta)
 {
 	return *(__u32 *)RTA_DATA(rta);
 }
 
-static inline const char *rta_getattr_str(const struct rtattr *rta)
+static inline char *rta_getattr_str(struct rtattr *rta)
 {
-	return (const char *)RTA_DATA(rta);
+	return (char *)RTA_DATA(rta);
 }
 
 static int rtnl_rtattr_parse(struct rtattr *tb[], int max, struct rtattr *rta, int len)
@@ -150,12 +198,12 @@ static inline int rtnl_nested_rtattr_parse(struct rtattr *tb[], int max, struct
 	return rtnl_rtattr_parse(tb, max, RTA_DATA(rta), RTA_PAYLOAD(rta));
 }
 
-static int rtnl_linkinfo_parse(struct rtattr *rta)
+static int rtnl_linkinfo_parse(int master_index, struct rtattr *rta)
 {
-	int index = -1;
-	const char *kind;
 	struct rtattr *linkinfo[IFLA_INFO_MAX];
 	struct rtattr *bond[IFLA_BOND_MAX];
+	int index = -1;
+	char *kind;
 
 	if (rtnl_nested_rtattr_parse(linkinfo, IFLA_INFO_MAX, rta) < 0)
 		return -1;
@@ -172,6 +220,8 @@ static int rtnl_linkinfo_parse(struct rtattr *rta)
 			if (bond[IFLA_BOND_ACTIVE_SLAVE]) {
 				index = rta_getattr_u32(bond[IFLA_BOND_ACTIVE_SLAVE]);
 			}
+		} else if (kind && !strncmp(kind, "team", 4)) {
+			index = get_team_active_iface(master_index);
 		}
 	}
 	return index;
@@ -179,18 +229,18 @@ static int rtnl_linkinfo_parse(struct rtattr *rta)
 
 int rtnl_link_status(int fd, char *device, rtnl_callback cb, void *ctx)
 {
+	struct rtattr *tb[IFLA_MAX+1];
+	struct ifinfomsg *info = NULL;
 	int index, len, link_up;
-	int slave_index = -1;
-	struct iovec iov;
 	struct sockaddr_nl sa;
-	struct msghdr msg;
+	int slave_index = -1;
 	struct nlmsghdr *nh;
-	struct ifinfomsg *info = NULL;
-	struct rtattr *tb[IFLA_MAX+1];
+	struct msghdr msg;
+	struct iovec iov;
 
 	index = if_nametoindex(device);
 	if (!rtnl_buf) {
-		rtnl_len = 4096;
+		rtnl_len = BUF_SIZE;
 		rtnl_buf = malloc(rtnl_len);
 		if (!rtnl_buf) {
 			pr_err("rtnl: low memory");
@@ -246,7 +296,7 @@ int rtnl_link_status(int fd, char *device, rtnl_callback cb, void *ctx)
 				  IFLA_PAYLOAD(nh));
 
 		if (tb[IFLA_LINKINFO])
-			slave_index = rtnl_linkinfo_parse(tb[IFLA_LINKINFO]);
+			slave_index = rtnl_linkinfo_parse(index, tb[IFLA_LINKINFO]);
 
 		if (cb)
 			cb(ctx, link_up, slave_index);
@@ -255,24 +305,163 @@ int rtnl_link_status(int fd, char *device, rtnl_callback cb, void *ctx)
 	return 0;
 }
 
-int rtnl_open(void)
+static int genl_send_msg(int fd, int family_id, int genl_cmd, int genl_version,
+		  int rta_type, void *rta_data, int rta_len)
 {
-	int fd;
-	struct sockaddr_nl sa;
+	struct sockaddr_nl daddr;
+	struct genlmsghdr *gnlh;
+	struct nlmsghdr *nlh;
+	struct rtattr *attr;
+	char msg[BUF_SIZE];
 
-	memset(&sa, 0, sizeof(sa));
-	sa.nl_family = AF_NETLINK;
-	sa.nl_groups = RTNLGRP_LINK;
+	memset(&daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
 
-	fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
-	if (fd < 0) {
-		pr_err("failed to open netlink socket: %m");
+	memset(&msg, 0, sizeof(msg));
+	nlh = (struct nlmsghdr *) msg;
+	nlh->nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	nlh->nlmsg_type = family_id;
+	nlh->nlmsg_flags = NLM_F_REQUEST;
+
+	gnlh = (struct genlmsghdr *) NLMSG_DATA(nlh);
+	gnlh->cmd = genl_cmd;
+	gnlh->version = genl_version;
+
+	if (rta_data && rta_len > 0) {
+		attr = (struct rtattr *) GENLMSG_DATA(msg);
+		attr->rta_type = rta_type;
+		attr->rta_len = RTA_LENGTH(rta_len);
+		nlh->nlmsg_len += NLMSG_ALIGN(attr->rta_len);
+		if (nlh->nlmsg_len < sizeof(msg))
+			memcpy(RTA_DATA(attr), rta_data, rta_len);
+		else
+			return -1;
+	}
+
+	return sendto(fd, &msg, nlh->nlmsg_len, 0,
+		      (struct sockaddr *)&daddr, sizeof(daddr));
+}
+
+static int genl_get_family_id(int fd, void *family_name)
+{
+	struct rtattr *tb[CTRL_ATTR_MAX+1];
+	struct nlmsghdr *nlh;
+	struct rtattr *attr;
+	char msg[BUF_SIZE];
+	int len, gf_id;
+
+	len = genl_send_msg(fd, GENL_ID_CTRL, CTRL_CMD_GETFAMILY, 1,
+			    CTRL_ATTR_FAMILY_NAME, family_name,
+			    strlen(family_name) + 1);
+	if (len < 0)
+		return len;
+
+	len = recv(fd, &msg, sizeof(msg), 0);
+	if (len < 0)
+		return len;
+
+	nlh = (struct nlmsghdr *) msg;
+	if (nlh->nlmsg_type == NLMSG_ERROR || !NLMSG_OK(nlh, len))
 		return -1;
+
+	attr = (struct rtattr *) GENLMSG_DATA(msg);
+	rtnl_rtattr_parse(tb, CTRL_ATTR_MAX, attr, NLMSG_PAYLOAD(nlh, GENL_HDRLEN));
+
+	if (tb[CTRL_ATTR_FAMILY_ID])
+		gf_id = rta_getattr_u16(tb[CTRL_ATTR_FAMILY_ID]);
+	else
+		gf_id = -1;
+
+	return gf_id;
+}
+
+static int parase_team_list_option(struct rtattr *attr)
+{
+	struct rtattr *tb[TEAM_ATTR_OPTION_MAX+1];
+	int len = RTA_PAYLOAD(attr);
+	const char *optname = "";
+	const char *mode = "";
+	int active_index = -1;
+
+	for (attr = RTA_DATA(attr); RTA_OK(attr, len); attr = RTA_NEXT(attr, len)) {
+		rtnl_nested_rtattr_parse(tb, TEAM_ATTR_OPTION_MAX, attr);
+
+		if (tb[TEAM_ATTR_OPTION_NAME])
+			optname = rta_getattr_str(tb[TEAM_ATTR_OPTION_NAME]);
+
+		if (!strcmp(optname, "mode") && tb[TEAM_ATTR_OPTION_TYPE] &&
+		    rta_getattr_u8(tb[TEAM_ATTR_OPTION_TYPE]) == NLA_STRING)
+			mode = rta_getattr_str(tb[TEAM_ATTR_OPTION_DATA]);
+
+		if (!strcmp(optname, "activeport") && tb[TEAM_ATTR_OPTION_TYPE] &&
+		    rta_getattr_u8(tb[TEAM_ATTR_OPTION_TYPE]) == NLA_U32)
+			active_index = rta_getattr_u32(tb[TEAM_ATTR_OPTION_DATA]);
 	}
-	if (bind(fd, (struct sockaddr *) &sa, sizeof(sa))) {
-		pr_err("failed to bind netlink socket: %m");
-		close(fd);
+
+	if (strcmp(mode, "activebackup")) {
+		pr_err("team supported only in activebackup mode");
 		return -1;
+	} else {
+		return active_index;
 	}
-	return fd;
+}
+
+static int get_team_active_iface(int master_index)
+{
+	struct rtattr *tb[TEAM_ATTR_MAX+1];
+	struct genlmsghdr *gnlh;
+	struct nlmsghdr *nlh;
+	char msg[BUF_SIZE];
+	int fd, gf_id, len;
+	int index = -1;
+
+	fd = nl_open(NETLINK_GENERIC);
+	if (fd < 0)
+		return fd;
+
+	gf_id = genl_get_family_id(fd, TEAM_GENL_NAME);
+	if (gf_id < 0) {
+		pr_err("get genl family failed");
+		goto no_info;
+	}
+
+	len = genl_send_msg(fd, gf_id, TEAM_CMD_OPTIONS_GET,
+			    TEAM_GENL_VERSION, TEAM_ATTR_TEAM_IFINDEX,
+			    &master_index, sizeof(master_index));
+	if (len < 0) {
+		pr_err("send team info request failed: %m");
+		goto no_info;
+	}
+
+	len = recv(fd, msg, sizeof(msg), 0);
+	if (len < 0) {
+		pr_err("recv team info failed: %m");
+		goto no_info;
+	}
+
+	nlh = (struct nlmsghdr *) msg;
+	for ( ; NLMSG_OK(nlh, len); nlh = NLMSG_NEXT(nlh, len)) {
+		if (nlh->nlmsg_type != gf_id)
+			continue;
+
+		gnlh = (struct genlmsghdr *) NLMSG_DATA(nlh);
+		if (gnlh->cmd != TEAM_CMD_OPTIONS_GET)
+			continue;
+
+		rtnl_rtattr_parse(tb, TEAM_ATTR_MAX, (struct rtattr *)GENLMSG_DATA(msg),
+				  NLMSG_PAYLOAD(nlh, GENL_HDRLEN));
+
+		if (tb[TEAM_ATTR_TEAM_IFINDEX] &&
+		    master_index != rta_getattr_u32(tb[TEAM_ATTR_TEAM_IFINDEX]))
+			continue;
+
+		if (tb[TEAM_ATTR_LIST_OPTION]) {
+			index = parase_team_list_option(tb[TEAM_ATTR_LIST_OPTION]);
+			break;
+		}
+	}
+
+no_info:
+	nl_close(fd);
+	return index;
 }
-- 
2.17.1


From 27657d0118fa03f6491e164ebb2bb70aaf5fb7d7 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Fri, 10 May 2019 13:20:36 +0200
Subject: [PATCH 053/173] Improve G.8275.[12] example configs.

Set the announce, sync and delay request intervals in the example
configs per the G.8275.1 and G.8275.2 recommendations. Enable the L2
transport in G.8275.1.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 configs/G.8275.1.cfg | 5 +++++
 configs/G.8275.2.cfg | 1 +
 2 files changed, 6 insertions(+)

diff --git a/configs/G.8275.1.cfg b/configs/G.8275.1.cfg
index 288fa4f..258bc78 100644
--- a/configs/G.8275.1.cfg
+++ b/configs/G.8275.1.cfg
@@ -8,5 +8,10 @@
 dataset_comparison		G.8275.x
 G.8275.defaultDS.localPriority	128
 maxStepsRemoved			255
+logAnnounceInterval		-3
+logSyncInterval			-4
+logMinDelayReqInterval		-4
 masterOnly			0
 G.8275.portDS.localPriority	128
+ptp_dst_mac             	01:80:C2:00:00:0E
+network_transport       	L2
diff --git a/configs/G.8275.2.cfg b/configs/G.8275.2.cfg
index 15bc609..4d4fd93 100644
--- a/configs/G.8275.2.cfg
+++ b/configs/G.8275.2.cfg
@@ -8,6 +8,7 @@
 dataset_comparison		G.8275.x
 G.8275.defaultDS.localPriority	128
 maxStepsRemoved			255
+logAnnounceInterval		0
 masterOnly			0
 G.8275.portDS.localPriority	128
 hybrid_e2e			1
-- 
2.17.1


From 3962f638410dd51cc3ab897d641470f85a4154f1 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Wed, 5 Jun 2019 18:18:32 +0200
Subject: [PATCH 054/173] nsm: Add man page.

Add a man page for the nsm program based on the pmc man page.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 nsm.8 | 124 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 124 insertions(+)
 create mode 100644 nsm.8

diff --git a/nsm.8 b/nsm.8
new file mode 100644
index 0000000..ec0b077
--- /dev/null
+++ b/nsm.8
@@ -0,0 +1,124 @@
+.TH NSM 8 "June 2019" "linuxptp"
+.SH NAME
+nsm \- NetSync Monitor client
+
+.SH SYNOPSIS
+.B nsm
+[
+.BI \-f " config"
+] [
+.BI \-i " interface"
+] [
+.I long-options
+] [ command ] ...
+
+.SH DESCRIPTION
+.B nsm
+is a program which implements a NetSync Monitor (NSM) client. NSM is an
+extension to the Precision Time Protocol (PTP), which enables a client to
+measure the offset of its clock against any PTP clock in the network which
+supports NSM. It uses unicast messages, but unlike PTP in the unicast mode it
+does not require the server to keep any state specific to the client. It is
+particularly useful for monitoring.
+
+The program reads commands from the standard input or from the command line.
+
+.SH COMMANDS
+
+.TP
+.BI NSM " address"
+Send a NetSync Monitor request to the specified network address (IPv4 or MAC)
+and print the measured offset with the response.
+.TP
+.B help
+Display a help message.
+
+.SH OPTIONS
+
+.TP
+.BI \-f " config"
+Read configuration from the specified file. No configuration file is read by
+default.
+.TP
+.BI \-i " interface"
+Specify the network interface.
+.TP
+.B \-h
+Display a help message.
+.TP
+.B \-v
+Print the software version and exit.
+
+.SH LONG OPTIONS
+
+Each and every configuration file option (see below in sections
+.BR PROGRAM\ OPTIONS
+and
+.BR PORT\ OPTIONS )
+may also appear
+as a "long" style command line argument. For example, the transportSpecific
+option may be set using either of these two forms:
+
+.RS
+\f(CW\-\-transportSpecific 1   \-\-transportSpecific=1\fP
+.RE
+
+Option values given on the command line override values in the global
+section of the configuration file (which, in turn, overrides default
+values).
+
+.SH CONFIGURATION FILE
+
+The configuration file is divided into sections. Each section starts with a
+line containing its name enclosed in brackets and it follows with settings.
+Each setting is placed on a separate line, it contains the name of the
+option and the value separated by whitespace characters. Empty lines and lines
+starting with # are ignored.
+
+The global section (indicated as
+.BR [global] )
+sets the global program options as well as the default port specific options.
+Other sections are port specific sections and they override the default port
+options. The name of the section is the name of the configured port (e.g.
+.BR [eth0]
+).
+
+.SH PORT OPTIONS
+.TP
+.B delayAsymmetry
+The time difference in nanoseconds of the transmit and receive
+paths. This value should be positive when the master-to-slave
+propagation time is longer and negative when the slave-to-master time
+is longer. The default is 0 nanoseconds.
+.TP
+.B network_transport
+Select the network transport. Possible values are UDPv4 and L2. The default
+is UDPv4.
+.TP
+.B transportSpecific
+The transport specific field. Must be in the range 0 to 255.
+The default is 0.
+
+.SH PROGRAM OPTIONS
+
+.TP
+.B domainNumber
+The domain attribute of the local clock. The default is 0.
+.B time_stamping
+The time stamping method. The allowed values are hardware, software and legacy.
+The default is hardware.
+
+.SH WARNING
+
+Be cautious when the same configuration file is used for both ptp4l
+and nsm.  Keep in mind that values specified in the configuration file
+take precedence over their default values. If a certain option which
+is common to ptp4l and nsm is specified to a non-default value in the
+configuration file (e.g. for ptp4l), then this non-default value
+applies also for nsm. This might be not what is expected.
+
+To avoid securely these unexpected behaviour, different configuration files
+for ptp4l and nsm are recommended.
+
+.SH SEE ALSO
+.BR ptp4l (8)
-- 
2.17.1


From 40e5868e66c9a2d26ff37508a115865762b55ba2 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Wed, 5 Jun 2019 18:18:33 +0200
Subject: [PATCH 055/173] pmc: Describe -f option in man page.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 pmc.8 | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/pmc.8 b/pmc.8
index db472d3..ff85cd6 100644
--- a/pmc.8
+++ b/pmc.8
@@ -58,6 +58,10 @@ can be used to get a list of supported actions and management IDs.
 
 .SH OPTIONS
 .TP
+.BI \-f " config-file"
+Read configuration from the specified file. No configuration file is read by
+default.
+.TP
 .B \-2
 Select the IEEE 802.3 network transport.
 .TP
-- 
2.17.1


From ba3705a0f05e4164313e9ce8411612fa61d3448c Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Tue, 11 Jun 2019 16:35:09 +0000
Subject: [PATCH 056/173] sk: Recognize HWTSTAMP_FILTER_SOME

struct hwtstamp_config.rx_filter passed to SIOCSHWTSTAMP can be updated by
the kernel with the value of HWTSTAMP_FILTER_SOME. That indicates that all
requested packets will be timestamped, and some others as well.

Update hwts_init() to recognize this as a valid response in HWTS_FILTER_NORMAL
mode, instead of rejecting it as mismatch.

Cc: "Keller, Jacob E" <jacob.e.keller@intel.com>
Cc: "Geva, Erez" <erez.geva.ext@siemens.com>
Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 sk.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/sk.c b/sk.c
index 93ba77a..e211175 100644
--- a/sk.c
+++ b/sk.c
@@ -61,6 +61,7 @@ static int hwts_init(int fd, const char *device, int rx_filter,
 {
 	struct ifreq ifreq;
 	struct hwtstamp_config cfg;
+	int orig_rx_filter;
 	int err;
 
 	init_ifreq(&ifreq, &cfg, device);
@@ -84,14 +85,14 @@ static int hwts_init(int fd, const char *device, int rx_filter,
 		break;
 	case HWTS_FILTER_NORMAL:
 		cfg.tx_type   = tx_type;
-		cfg.rx_filter = rx_filter;
+		cfg.rx_filter = orig_rx_filter = rx_filter;
 		err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
 		if (err < 0) {
 			pr_info("driver rejected most general HWTSTAMP filter");
 
 			init_ifreq(&ifreq, &cfg, device);
 			cfg.tx_type   = tx_type;
-			cfg.rx_filter = rx_filter2;
+			cfg.rx_filter = orig_rx_filter = rx_filter2;
 
 			err = ioctl(fd, SIOCSHWTSTAMP, &ifreq);
 			if (err < 0) {
@@ -99,6 +100,8 @@ static int hwts_init(int fd, const char *device, int rx_filter,
 				return err;
 			}
 		}
+		if (cfg.rx_filter == HWTSTAMP_FILTER_SOME)
+			cfg.rx_filter = orig_rx_filter;
 		break;
 	}
 
-- 
2.17.1


From f2aac1b30ebf65e689a25b313664db4e26841a75 Mon Sep 17 00:00:00 2001
From: Hubert Feurstein <h.feurstein@gmail.com>
Date: Wed, 31 Jul 2019 17:57:15 +0200
Subject: [PATCH 057/173] clock: prepend port number to grandmaster notice

Signed-off-by: Hubert Feurstein <h.feurstein@gmail.com>
---
 clock.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/clock.c b/clock.c
index 642f688..146576a 100644
--- a/clock.c
+++ b/clock.c
@@ -1790,7 +1790,8 @@ static void handle_state_decision_event(struct clock *c)
 			event = EV_NONE;
 			break;
 		case PS_GRAND_MASTER:
-			pr_notice("assuming the grand master role");
+			pr_notice("port %d: assuming the grand master role",
+				  port_number(piter));
 			clock_update_grandmaster(c);
 			event = EV_RS_GRAND_MASTER;
 			break;
-- 
2.17.1


From c15e8c76000cdd00335a039f89693b820044ac91 Mon Sep 17 00:00:00 2001
From: "Khor, Isaac Shi Yan" <isaac.shi.yan.khor@intel.com>
Date: Wed, 7 Aug 2019 11:31:18 +0800
Subject: [PATCH 058/173] ptp4l: Add configuration option for socket priority

Users may need to use different socket priorities for ptp4l traffic for
the purpose of traffic shaping. An example is to route ptp4l traffic
through a specific Linux egress queue using the mqprio qdisc.

 - Update raw.c open_socket() to accept a socket_priority parameter
 - Add the socket_priority option to config.c and the default.cfg config
   file. The option defaults to 0.

CC: "Ong, Boon Leong" <boon.leong.ong@intel.com>
CC: "Wong, Vincent Por Yin" <vincent.por.yin.wong@intel.com>
Signed-off-by: Khor, Isaac Shi Yan <isaac.shi.yan.khor@intel.com>
---
 config.c            |  1 +
 configs/default.cfg |  1 +
 ptp4l.8             |  7 +++++++
 raw.c               | 17 +++++++++++++----
 4 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/config.c b/config.c
index 93ea5da..83cb48e 100644
--- a/config.c
+++ b/config.c
@@ -285,6 +285,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("servo_num_offset_values", 10, 0, INT_MAX),
 	GLOB_ITEM_INT("servo_offset_threshold", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("slaveOnly", 0, 0, 1),
+	GLOB_ITEM_INT("socket_priority", 0, 0, 15),
 	GLOB_ITEM_DBL("step_threshold", 0.0, 0.0, DBL_MAX),
 	GLOB_ITEM_INT("summary_interval", 0, INT_MIN, INT_MAX),
 	PORT_ITEM_INT("syncReceiptTimeout", 0, 0, UINT8_MAX),
diff --git a/configs/default.cfg b/configs/default.cfg
index e23dfd7..c52dc37 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -4,6 +4,7 @@
 #
 twoStepFlag		1
 slaveOnly		0
+socket_priority		0
 priority1		128
 priority2		128
 domainNumber		0
diff --git a/ptp4l.8 b/ptp4l.8
index 1a01108..ab156d9 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -384,6 +384,13 @@ The default is 1 (enabled).
 .B slaveOnly
 The local clock is a slave-only clock if enabled. The default is 0 (disabled).
 .TP
+.B socket_priority
+Configure the SO_PRIORITY of sockets. This is to support cases where a user
+wants to route ptp4l traffic using Linux qdiscs for the purpose of traffic
+shaping. This option is only available with the IEEE 802.3 transport (the
+\fB-2\fP option) and is silently ignored when using the UDP IPv4/6 network
+transports. Must be in the range of 0 to 15, inclusive. The default is 0.
+.TP
 .B gmCapable
 If this option is enabled, then the local clock is able to become grand master.
 This is only for use with 802.1AS clocks and has no effect on 1588 clocks.
diff --git a/raw.c b/raw.c
index 8dc50bc..f1c92b9 100644
--- a/raw.c
+++ b/raw.c
@@ -150,7 +150,7 @@ static int raw_close(struct transport *t, struct fdarray *fda)
 }
 
 static int open_socket(const char *name, int event, unsigned char *ptp_dst_mac,
-		       unsigned char *p2p_dst_mac)
+		       unsigned char *p2p_dst_mac, int socket_priority)
 {
 	struct sockaddr_ll addr;
 	int fd, index;
@@ -176,6 +176,13 @@ static int open_socket(const char *name, int event, unsigned char *ptp_dst_mac,
 		pr_err("setsockopt SO_BINDTODEVICE failed: %m");
 		goto no_option;
 	}
+
+	if (socket_priority > 0 &&
+	    setsockopt(fd, SOL_SOCKET, SO_PRIORITY, &socket_priority,
+		       sizeof(socket_priority))) {
+		pr_err("setsockopt SO_PRIORITY failed: %m");
+		goto no_option;
+	}
 	if (raw_configure(fd, event, index, ptp_dst_mac, p2p_dst_mac, 1))
 		goto no_option;
 
@@ -205,7 +212,7 @@ static int raw_open(struct transport *t, struct interface *iface,
 	struct raw *raw = container_of(t, struct raw, t);
 	unsigned char ptp_dst_mac[MAC_LEN];
 	unsigned char p2p_dst_mac[MAC_LEN];
-	int efd, gfd;
+	int efd, gfd, socket_priority;
 	char *str, *name;
 
 	name = iface->ts_label;
@@ -225,11 +232,13 @@ static int raw_open(struct transport *t, struct interface *iface,
 	if (sk_interface_macaddr(name, &raw->src_addr))
 		goto no_mac;
 
-	efd = open_socket(name, 1, ptp_dst_mac, p2p_dst_mac);
+	socket_priority = config_get_int(t->cfg, "global", "socket_priority");
+
+	efd = open_socket(name, 1, ptp_dst_mac, p2p_dst_mac, socket_priority);
 	if (efd < 0)
 		goto no_event;
 
-	gfd = open_socket(name, 0, ptp_dst_mac, p2p_dst_mac);
+	gfd = open_socket(name, 0, ptp_dst_mac, p2p_dst_mac, socket_priority);
 	if (gfd < 0)
 		goto no_general;
 
-- 
2.17.1


From 68337acd10b030f3c46111ba7e7b4624e4609cf9 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Mon, 19 Aug 2019 15:29:31 +0300
Subject: [PATCH 059/173] configs: default.cfg: Fix typo in inhibit_delay_req

ptp4l -f default.cfg complains:

  unknown option inhibit_pdelay_req at line 41 in global section
  failed to parse configuration file /etc/linuxptp/default.cfg

Fixes: 450b1ed844f6 ("port: Add inhibit_delay_req.")
Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 configs/default.cfg | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/configs/default.cfg b/configs/default.cfg
index c52dc37..119df7b 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -38,7 +38,7 @@ G.8275.portDS.localPriority	128
 asCapable               auto
 BMCA                    ptp
 inhibit_announce        0
-inhibit_pdelay_req      0
+inhibit_delay_req       0
 ignore_source_id        0
 #
 # Run time options
-- 
2.17.1


From 46b673792ac01036d5d8345b31dd1761eaef5cf3 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 19 Aug 2019 08:37:23 -0700
Subject: [PATCH 060/173] Keep configuration options in alphabetical order.

The order of the options list has gone a bit astray.  This patch
restores the ordering.

Fixes: 450b1ed844f6 ("port: Add inhibit_delay_req.")
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 config.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/config.c b/config.c
index 83cb48e..12eb1f9 100644
--- a/config.c
+++ b/config.c
@@ -244,9 +244,9 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("ignore_transport_specific", 0, 0, 1),
 	PORT_ITEM_INT("ingressLatency", 0, INT_MIN, INT_MAX),
 	PORT_ITEM_INT("inhibit_announce", 0, 0, 1),
-	GLOB_ITEM_INT("initial_delay", 0, 0, INT_MAX),
 	PORT_ITEM_INT("inhibit_delay_req", 0, 0, 1),
 	PORT_ITEM_INT("inhibit_multicast_service", 0, 0, 1),
+	GLOB_ITEM_INT("initial_delay", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("kernel_leap", 1, 0, 1),
 	PORT_ITEM_INT("logAnnounceInterval", 1, INT8_MIN, INT8_MAX),
 	PORT_ITEM_INT("logMinDelayReqInterval", 0, INT8_MIN, INT8_MAX),
-- 
2.17.1


From d32758aa09b915e84a664d4b4cbc24112b2d15d9 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 7 Jul 2019 18:13:39 -0700
Subject: [PATCH 061/173] phc2sys, phc_ctl: Re-factor common code.

The two programs, phc2sys and phc_ctl, use nearly identical subroutines to
open an instance of a dynamic posix clock.  In anticipation of yet a third
program with similar needs, this patch refactors the common code into the
utilities.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 makefile  |  8 ++++----
 phc2sys.c | 38 ++------------------------------------
 phc_ctl.c | 41 ++++-------------------------------------
 util.c    | 34 ++++++++++++++++++++++++++++++++++
 util.h    |  8 ++++++++
 5 files changed, 52 insertions(+), 77 deletions(-)

diff --git a/makefile b/makefile
index d09a4a9..3397d3e 100644
--- a/makefile
+++ b/makefile
@@ -55,10 +55,10 @@ all: $(PRG)
 
 ptp4l: $(OBJ)
 
-nsm: config.o filter.o hash.o mave.o mmedian.o msg.o nsm.o print.o raw.o \
+nsm: config.o filter.o hash.o mave.o mmedian.o msg.o nsm.o phc.o print.o raw.o \
  rtnl.o sk.o transport.o tlv.o tsproc.o udp.o udp6.o uds.o util.o version.o
 
-pmc: config.o hash.o msg.o pmc.o pmc_common.o print.o raw.o sk.o tlv.o \
+pmc: config.o hash.o msg.o phc.o pmc.o pmc_common.o print.o raw.o sk.o tlv.o \
  transport.o udp.o udp6.o uds.o util.o version.o
 
 phc2sys: clockadj.o clockcheck.o config.o hash.o linreg.o msg.o ntpshm.o \
@@ -69,14 +69,14 @@ hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
-snmp4lptp: config.o hash.o msg.o pmc_common.o print.o raw.o sk.o \
+snmp4lptp: config.o hash.o msg.o phc.o pmc_common.o print.o raw.o sk.o \
  snmp4lptp.o tlv.o transport.o udp.o udp6.o uds.o util.o
 	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
 
 snmp4lptp.o: snmp4lptp.c
 	$(CC) $(CPPFLAGS) $(CFLAGS) $(snmpflg) -c $<
 
-timemaster: print.o rtnl.o sk.o timemaster.o util.o version.o
+timemaster: phc.o print.o rtnl.o sk.o timemaster.o util.o version.o
 
 version.o: .version version.sh $(filter-out version.d,$(DEPEND))
 
diff --git a/phc2sys.c b/phc2sys.c
index cc48f18..28c657a 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -135,40 +135,6 @@ static int run_pmc_port_properties(struct node *node, int timeout,
 				   unsigned int port,
 				   int *state, int *tstamping, char *iface);
 
-static clockid_t clock_open(char *device, int *phc_index)
-{
-	struct sk_ts_info ts_info;
-	char phc_device[19];
-	int clkid;
-
-	/* check if device is CLOCK_REALTIME */
-	if (!strcasecmp(device, "CLOCK_REALTIME"))
-		return CLOCK_REALTIME;
-
-	/* check if device is valid phc device */
-	clkid = phc_open(device);
-	if (clkid != CLOCK_INVALID)
-		return clkid;
-
-	/* check if device is a valid ethernet device */
-	if (sk_get_ts_info(device, &ts_info) || !ts_info.valid) {
-		fprintf(stderr, "unknown clock %s: %m\n", device);
-		return CLOCK_INVALID;
-	}
-
-	if (ts_info.phc_index < 0) {
-		fprintf(stderr, "interface %s does not have a PHC\n", device);
-		return CLOCK_INVALID;
-	}
-
-	sprintf(phc_device, "/dev/ptp%d", ts_info.phc_index);
-	clkid = phc_open(phc_device);
-	if (clkid == CLOCK_INVALID)
-		fprintf(stderr, "cannot open %s: %m\n", device);
-	*phc_index = ts_info.phc_index;
-	return clkid;
-}
-
 static struct servo *servo_add(struct node *node, struct clock *clock)
 {
 	double ppb;
@@ -210,7 +176,7 @@ static struct clock *clock_add(struct node *node, char *device)
 	int phc_index = -1;
 
 	if (device) {
-		clkid = clock_open(device, &phc_index);
+		clkid = posix_clock_open(device, &phc_index);
 		if (clkid == CLOCK_INVALID)
 			return NULL;
 	}
@@ -371,7 +337,7 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 		/* Check if phc index changed */
 		if (!sk_get_ts_info(clock->device, &ts_info) &&
 		    clock->phc_index != ts_info.phc_index) {
-			clkid = clock_open(clock->device, &phc_index);
+			clkid = posix_clock_open(clock->device, &phc_index);
 			if (clkid == CLOCK_INVALID)
 				return;
 
diff --git a/phc_ctl.c b/phc_ctl.c
index b9a9cf4..e55af59 100644
--- a/phc_ctl.c
+++ b/phc_ctl.c
@@ -110,39 +110,6 @@ static int64_t calculate_offset(struct timespec *ts1,
 	return offset;
 }
 
-static clockid_t clock_open(char *device)
-{
-	struct sk_ts_info ts_info;
-	char phc_device[19];
-	int clkid;
-
-	/* check if device is CLOCK_REALTIME */
-	if (!strcasecmp(device, "CLOCK_REALTIME"))
-		return CLOCK_REALTIME;
-
-	/* check if device is valid phc device */
-	clkid = phc_open(device);
-	if (clkid != CLOCK_INVALID)
-		return clkid;
-
-	/* check if device is a valid ethernet device */
-	if (sk_get_ts_info(device, &ts_info) || !ts_info.valid) {
-		pr_err("unknown clock %s: %m", device);
-		return CLOCK_INVALID;
-	}
-
-	if (ts_info.phc_index < 0) {
-		pr_err("interface %s does not have a PHC", device);
-		return CLOCK_INVALID;
-	}
-
-	sprintf(phc_device, "/dev/ptp%d", ts_info.phc_index);
-	clkid = phc_open(phc_device);
-	if (clkid == CLOCK_INVALID)
-		pr_err("cannot open %s for %s: %m", phc_device, device);
-	return clkid;
-}
-
 static void usage(const char *progname)
 {
 	fprintf(stderr,
@@ -503,10 +470,10 @@ static int run_cmds(clockid_t clkid, int cmdc, char *cmdv[])
 
 int main(int argc, char *argv[])
 {
-	const char *progname;
+	int c, cmdc, junk, print_level = LOG_INFO, result;
 	char **cmdv, *default_cmdv[] = { "caps" };
-	int c, result, cmdc;
-	int print_level = LOG_INFO, verbose = 1, use_syslog = 1;
+	int use_syslog = 1, verbose = 1;
+	const char *progname;
 	clockid_t clkid;
 
 	install_handler(SIGALRM, handle_alarm);
@@ -558,7 +525,7 @@ int main(int argc, char *argv[])
 		cmdc = argc - optind - 1;
 	}
 
-	clkid = clock_open(argv[optind]);
+	clkid = posix_clock_open(argv[optind], &junk);
 	if (clkid == CLOCK_INVALID)
 		return -1;
 
diff --git a/util.c b/util.c
index 42c0977..833f1a5 100644
--- a/util.c
+++ b/util.c
@@ -25,6 +25,7 @@
 #include <string.h>
 
 #include "address.h"
+#include "phc.h"
 #include "print.h"
 #include "sk.h"
 #include "util.h"
@@ -171,6 +172,39 @@ char *portaddr2str(struct PortAddress *addr)
 	return buf;
 }
 
+clockid_t posix_clock_open(char *device, int *phc_index)
+{
+	struct sk_ts_info ts_info;
+	char phc_device[19];
+	int clkid;
+
+	/* check if device is CLOCK_REALTIME */
+	if (!strcasecmp(device, "CLOCK_REALTIME")) {
+		return CLOCK_REALTIME;
+	}
+	/* check if device is valid phc device */
+	clkid = phc_open(device);
+	if (clkid != CLOCK_INVALID) {
+		return clkid;
+	}
+	/* check if device is a valid ethernet device */
+	if (sk_get_ts_info(device, &ts_info) || !ts_info.valid) {
+		pr_err("unknown clock %s: %m", device);
+		return CLOCK_INVALID;
+	}
+	if (ts_info.phc_index < 0) {
+		pr_err("interface %s does not have a PHC", device);
+		return CLOCK_INVALID;
+	}
+	snprintf(phc_device, sizeof(phc_device), "/dev/ptp%d", ts_info.phc_index);
+	clkid = phc_open(phc_device);
+	if (clkid == CLOCK_INVALID) {
+		pr_err("cannot open %s for %s: %m", phc_device, device);
+	}
+	*phc_index = ts_info.phc_index;
+	return clkid;
+}
+
 int str2addr(enum transport_type type, const char *s, struct address *addr)
 {
 	unsigned char mac[MAC_LEN];
diff --git a/util.h b/util.h
index 39d602e..9d3f227 100644
--- a/util.h
+++ b/util.h
@@ -103,6 +103,14 @@ char *pid2str(struct PortIdentity *id);
 
 char *portaddr2str(struct PortAddress *addr);
 
+/**
+ * Opens a dynamic posix clock by name.
+ * @param device     The PHC character device or network interface to open.
+ * @param phc_index  Returns the PHC index, if any.
+ * @return           A valid clock ID on success or CLOCK_INVALID otherwise.
+ */
+clockid_t posix_clock_open(char *device, int *phc_index);
+
 /**
  * Compare two port identities for equality.
  *
-- 
2.17.1


From e3f0891996ff6256fc1ab335d6f5b95b0b1fb36f Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Tue, 10 Sep 2019 12:24:00 +0000
Subject: [PATCH 062/173] port: Introduce per-port stats for received and
 transmitted messages

Add struct PortStats to keep per-port number of messages sent and received,
split by message type. Bump TX counters after messages are sent
successfully, and RX counters after a message is received. To keep things
simple, reserve one counter for each theoretically possible message type,
including the reserved ones.

Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 ddt.h          |  7 +++++++
 port.c         | 25 +++++++++++++++++++++++--
 port_private.h |  1 +
 3 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/ddt.h b/ddt.h
index 4acaa4f..56449a3 100644
--- a/ddt.h
+++ b/ddt.h
@@ -100,4 +100,11 @@ struct FaultRecord {
 	struct PTPText   faultDescription;
 };
 
+/* Four bits are dedicated to messageType field */
+#define MAX_MESSAGE_TYPES     16
+struct PortStats {
+	uint64_t rxMsgType[MAX_MESSAGE_TYPES];
+	uint64_t txMsgType[MAX_MESSAGE_TYPES];
+};
+
 #endif
diff --git a/port.c b/port.c
index 5a4a116..471e6f4 100644
--- a/port.c
+++ b/port.c
@@ -580,6 +580,16 @@ static int path_trace_ignore(struct port *p, struct ptp_message *m)
 	return 0;
 }
 
+static void port_stats_inc_rx(struct port *p, const struct ptp_message *msg)
+{
+	p->stats.rxMsgType[msg_type(msg)]++;
+}
+
+static void port_stats_inc_tx(struct port *p, const struct ptp_message *msg)
+{
+	p->stats.txMsgType[msg_type(msg)]++;
+}
+
 static int peer_prepare_and_send(struct port *p, struct ptp_message *msg,
 				 enum transport_event event)
 {
@@ -595,6 +605,7 @@ static int peer_prepare_and_send(struct port *p, struct ptp_message *msg,
 	if (cnt <= 0) {
 		return -1;
 	}
+	port_stats_inc_tx(p, msg);
 	if (msg_sots_valid(msg)) {
 		ts_add(&msg->hwts.ts, p->tx_timestamp_offset);
 	}
@@ -2627,6 +2638,7 @@ static enum fsm_event bc_event(struct port *p, int fd_index)
 		msg_put(msg);
 		return EV_NONE;
 	}
+	port_stats_inc_rx(p, msg);
 	if (port_ignore(p, msg)) {
 		msg_put(msg);
 		return EV_NONE;
@@ -2691,14 +2703,22 @@ int port_forward(struct port *p, struct ptp_message *msg)
 {
 	int cnt;
 	cnt = transport_send(p->trp, &p->fda, TRANS_GENERAL, msg);
-	return cnt <= 0 ? -1 : 0;
+	if (cnt <= 0) {
+		return -1;
+	}
+	port_stats_inc_tx(p, msg);
+	return 0;
 }
 
 int port_forward_to(struct port *p, struct ptp_message *msg)
 {
 	int cnt;
 	cnt = transport_sendto(p->trp, &p->fda, TRANS_GENERAL, msg);
-	return cnt <= 0 ? -1 : 0;
+	if (cnt <= 0) {
+		return -1;
+	}
+	port_stats_inc_tx(p, msg);
+	return 0;
 }
 
 int port_prepare_and_send(struct port *p, struct ptp_message *msg,
@@ -2717,6 +2737,7 @@ int port_prepare_and_send(struct port *p, struct ptp_message *msg,
 	if (cnt <= 0) {
 		return -1;
 	}
+	port_stats_inc_tx(p, msg);
 	if (msg_sots_valid(msg)) {
 		ts_add(&msg->hwts.ts, p->tx_timestamp_offset);
 	}
diff --git a/port_private.h b/port_private.h
index 9a5022d..5789fbb 100644
--- a/port_private.h
+++ b/port_private.h
@@ -139,6 +139,7 @@ struct port {
 	struct fault_interval flt_interval_pertype[FT_CNT];
 	enum fault_type     last_fault_type;
 	unsigned int        versionNumber; /*UInteger4*/
+	struct PortStats    stats;
 	/* foreignMasterDS */
 	LIST_HEAD(fm, foreign_clock) foreign_masters;
 	/* TC book keeping */
-- 
2.17.1


From 2b5bec8d2740c5f466aa423ae3710d812d5b16f8 Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Tue, 10 Sep 2019 12:24:13 +0000
Subject: [PATCH 063/173] pmc: Add a new TLV to obtain per-port statistics

Add an ability of pmc to query per-port stats added in the previous patch.

Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 pmc.c        | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 pmc_common.c |  1 +
 port.c       |  7 +++++++
 tlv.c        | 15 +++++++++++++++
 tlv.h        |  6 ++++++
 5 files changed, 76 insertions(+)

diff --git a/pmc.c b/pmc.c
index 440c905..868fc2a 100644
--- a/pmc.c
+++ b/pmc.c
@@ -69,6 +69,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 	struct tlv_extra *extra;
 	struct portDS *p;
 	struct port_ds_np *pnp;
+	struct port_stats_np *pcp;
 
 	if (msg_type(msg) != MANAGEMENT) {
 		return;
@@ -322,6 +323,52 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			pnp->neighborPropDelayThresh,
 			pnp->asCapable ? 1 : 0);
 		break;
+	case TLV_PORT_STATS_NP:
+		pcp = (struct port_stats_np *) mgt->data;
+		fprintf(fp, "PORT_STATS_NP "
+			IFMT "portIdentity              %s"
+			IFMT "rx_Sync                   %" PRIu64
+			IFMT "rx_Delay_Req              %" PRIu64
+			IFMT "rx_Pdelay_Req             %" PRIu64
+			IFMT "rx_Pdelay_Resp            %" PRIu64
+			IFMT "rx_Follow_Up              %" PRIu64
+			IFMT "rx_Delay_Resp             %" PRIu64
+			IFMT "rx_Pdelay_Resp_Follow_Up  %" PRIu64
+			IFMT "rx_Announce               %" PRIu64
+			IFMT "rx_Signaling              %" PRIu64
+			IFMT "rx_Management             %" PRIu64
+			IFMT "tx_Sync                   %" PRIu64
+			IFMT "tx_Delay_Req              %" PRIu64
+			IFMT "tx_Pdelay_Req             %" PRIu64
+			IFMT "tx_Pdelay_Resp            %" PRIu64
+			IFMT "tx_Follow_Up              %" PRIu64
+			IFMT "tx_Delay_Resp             %" PRIu64
+			IFMT "tx_Pdelay_Resp_Follow_Up  %" PRIu64
+			IFMT "tx_Announce               %" PRIu64
+			IFMT "tx_Signaling              %" PRIu64
+			IFMT "tx_Management             %" PRIu64,
+			pid2str(&pcp->portIdentity),
+			pcp->stats.rxMsgType[SYNC],
+			pcp->stats.rxMsgType[DELAY_REQ],
+			pcp->stats.rxMsgType[PDELAY_REQ],
+			pcp->stats.rxMsgType[PDELAY_RESP],
+			pcp->stats.rxMsgType[FOLLOW_UP],
+			pcp->stats.rxMsgType[DELAY_RESP],
+			pcp->stats.rxMsgType[PDELAY_RESP_FOLLOW_UP],
+			pcp->stats.rxMsgType[ANNOUNCE],
+			pcp->stats.rxMsgType[SIGNALING],
+			pcp->stats.rxMsgType[MANAGEMENT],
+			pcp->stats.txMsgType[SYNC],
+			pcp->stats.txMsgType[DELAY_REQ],
+			pcp->stats.txMsgType[PDELAY_REQ],
+			pcp->stats.txMsgType[PDELAY_RESP],
+			pcp->stats.txMsgType[FOLLOW_UP],
+			pcp->stats.txMsgType[DELAY_RESP],
+			pcp->stats.txMsgType[PDELAY_RESP_FOLLOW_UP],
+			pcp->stats.txMsgType[ANNOUNCE],
+			pcp->stats.txMsgType[SIGNALING],
+			pcp->stats.txMsgType[MANAGEMENT]);
+		break;
 	case TLV_LOG_ANNOUNCE_INTERVAL:
 		mtd = (struct management_tlv_datum *) mgt->data;
 		fprintf(fp, "LOG_ANNOUNCE_INTERVAL "
diff --git a/pmc_common.c b/pmc_common.c
index 4d48e3a..592cc93 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -120,6 +120,7 @@ struct management_id idtab[] = {
 	{ "DELAY_MECHANISM", TLV_DELAY_MECHANISM, do_get_action },
 	{ "LOG_MIN_PDELAY_REQ_INTERVAL", TLV_LOG_MIN_PDELAY_REQ_INTERVAL, do_get_action },
 	{ "PORT_DATA_SET_NP", TLV_PORT_DATA_SET_NP, do_set_action },
+	{ "PORT_STATS_NP", TLV_PORT_STATS_NP, do_get_action },
 };
 
 static void do_get_action(struct pmc *pmc, int action, int index, char *str)
diff --git a/port.c b/port.c
index 471e6f4..07ad3f0 100644
--- a/port.c
+++ b/port.c
@@ -788,6 +788,7 @@ static int port_management_fill_response(struct port *target,
 	struct management_tlv_datum *mtd;
 	struct clock_description *desc;
 	struct port_properties_np *ppn;
+	struct port_stats_np *psn;
 	struct management_tlv *tlv;
 	struct port_ds_np *pdsnp;
 	struct tlv_extra *extra;
@@ -943,6 +944,12 @@ static int port_management_fill_response(struct port *target,
 		ptp_text_set(&ppn->interface, target->iface->ts_label);
 		datalen = sizeof(*ppn) + ppn->interface.length;
 		break;
+	case TLV_PORT_STATS_NP:
+		psn = (struct port_stats_np *)tlv->data;
+		psn->portIdentity = target->portIdentity;
+		psn->stats = target->stats;
+		datalen = sizeof(*psn);
+		break;
 	default:
 		/* The caller should *not* respond to this message. */
 		tlv_extra_recycle(extra);
diff --git a/tlv.c b/tlv.c
index 6a5387e..2440482 100644
--- a/tlv.c
+++ b/tlv.c
@@ -92,6 +92,7 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 	struct grandmaster_settings_np *gsn;
 	struct subscribe_events_np *sen;
 	struct port_properties_np *ppn;
+	struct port_stats_np *psn;
 	struct mgmt_clock_description *cd;
 	int extra_len = 0, len;
 	uint8_t *buf;
@@ -286,6 +287,14 @@ static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 		extra_len = sizeof(struct port_properties_np);
 		extra_len += ppn->interface.length;
 		break;
+	case TLV_PORT_STATS_NP:
+		if (data_len < sizeof(struct port_stats_np))
+			goto bad_length;
+		psn = (struct port_stats_np *)m->data;
+		psn->portIdentity.portNumber =
+			ntohs(psn->portIdentity.portNumber);
+		extra_len = sizeof(struct port_stats_np);
+		break;
 	case TLV_SAVE_IN_NON_VOLATILE_STORAGE:
 	case TLV_RESET_NON_VOLATILE_STORAGE:
 	case TLV_INITIALIZE:
@@ -319,6 +328,7 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 	struct grandmaster_settings_np *gsn;
 	struct subscribe_events_np *sen;
 	struct port_properties_np *ppn;
+	struct port_stats_np *psn;
 	struct mgmt_clock_description *cd;
 	switch (m->id) {
 	case TLV_CLOCK_DESCRIPTION:
@@ -391,6 +401,11 @@ static void mgt_pre_send(struct management_tlv *m, struct tlv_extra *extra)
 		ppn = (struct port_properties_np *)m->data;
 		ppn->portIdentity.portNumber = htons(ppn->portIdentity.portNumber);
 		break;
+	case TLV_PORT_STATS_NP:
+		psn = (struct port_stats_np *)m->data;
+		psn->portIdentity.portNumber =
+			htons(psn->portIdentity.portNumber);
+		break;
 	}
 }
 
diff --git a/tlv.h b/tlv.h
index bcbfdd9..faf5742 100644
--- a/tlv.h
+++ b/tlv.h
@@ -105,6 +105,7 @@ enum management_action {
 #define TLV_LOG_MIN_PDELAY_REQ_INTERVAL			0x6001
 #define TLV_PORT_DATA_SET_NP				0xC002
 #define TLV_PORT_PROPERTIES_NP				0xC004
+#define TLV_PORT_STATS_NP				0xC005
 
 /* Management error ID values */
 #define TLV_RESPONSE_TOO_BIG				0x0001
@@ -280,6 +281,11 @@ struct port_properties_np {
 	struct PTPText interface;
 } PACKED;
 
+struct port_stats_np {
+	struct PortIdentity portIdentity;
+	struct PortStats stats;
+} PACKED;
+
 #define PROFILE_ID_LEN 6
 
 struct mgmt_clock_description {
-- 
2.17.1


From a48666bee3dd239a2d48833c20ec65849a949342 Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Tue, 10 Sep 2019 12:51:35 +0000
Subject: [PATCH 064/173] udp6: Make mc6_addr transport-local

mc6_addr holds the parsed multicast address to which messages should be sent.
But since each port can have a different scope, and the primary MC address
depends on the scope, it really can't be stored in a global variable. Move both
to struct udp6.

Additionally, document the fact that the primary multicast address is changed at
runtime.

Reported-by: Alex Veber <alexve@mellanox.com>
Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 udp6.c | 28 +++++++++++++++++-----------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/udp6.c b/udp6.c
index 908f307..74ebc7f 100644
--- a/udp6.c
+++ b/udp6.c
@@ -39,14 +39,19 @@
 
 #define EVENT_PORT        319
 #define GENERAL_PORT      320
+
+/* The 0x0e in second byte is substituted with udp6_scope at runtime. */
 #define PTP_PRIMARY_MCAST_IP6ADDR "FF0E:0:0:0:0:0:0:181"
 #define PTP_PDELAY_MCAST_IP6ADDR  "FF02:0:0:0:0:0:0:6B"
 
+enum { MC_PRIMARY, MC_PDELAY };
+
 struct udp6 {
 	struct transport t;
 	int index;
 	struct address ip;
 	struct address mac;
+	struct in6_addr mc6_addr[2];
 };
 
 static int is_link_local(struct in6_addr *addr)
@@ -155,10 +160,6 @@ no_socket:
 	return -1;
 }
 
-enum { MC_PRIMARY, MC_PDELAY };
-
-static struct in6_addr mc6_addr[2];
-
 static int udp6_open(struct transport *t, struct interface *iface,
 		     struct fdarray *fda, enum timestamp_type ts_type)
 {
@@ -174,19 +175,24 @@ static int udp6_open(struct transport *t, struct interface *iface,
 	udp6->ip.len = 0;
 	sk_interface_addr(name, AF_INET6, &udp6->ip);
 
-	if (1 != inet_pton(AF_INET6, PTP_PRIMARY_MCAST_IP6ADDR, &mc6_addr[MC_PRIMARY]))
+	if (1 != inet_pton(AF_INET6, PTP_PRIMARY_MCAST_IP6ADDR,
+			   &udp6->mc6_addr[MC_PRIMARY]))
 		return -1;
 
-	mc6_addr[MC_PRIMARY].s6_addr[1] = config_get_int(t->cfg, name, "udp6_scope");
+	udp6->mc6_addr[MC_PRIMARY].s6_addr[1] = config_get_int(t->cfg, name,
+							       "udp6_scope");
 
-	if (1 != inet_pton(AF_INET6, PTP_PDELAY_MCAST_IP6ADDR, &mc6_addr[MC_PDELAY]))
+	if (1 != inet_pton(AF_INET6, PTP_PDELAY_MCAST_IP6ADDR,
+			   &udp6->mc6_addr[MC_PDELAY]))
 		return -1;
 
-	efd = open_socket_ipv6(name, mc6_addr, EVENT_PORT, &udp6->index, hop_limit);
+	efd = open_socket_ipv6(name, udp6->mc6_addr, EVENT_PORT, &udp6->index,
+			       hop_limit);
 	if (efd < 0)
 		goto no_event;
 
-	gfd = open_socket_ipv6(name, mc6_addr, GENERAL_PORT, &udp6->index, hop_limit);
+	gfd = open_socket_ipv6(name, udp6->mc6_addr, GENERAL_PORT, &udp6->index,
+			       hop_limit);
 	if (gfd < 0)
 		goto no_general;
 
@@ -249,8 +255,8 @@ static int udp6_send(struct transport *t, struct fdarray *fda,
 	if (!addr) {
 		memset(&addr_buf, 0, sizeof(addr_buf));
 		addr_buf.sin6.sin6_family = AF_INET6;
-		addr_buf.sin6.sin6_addr =  peer ? mc6_addr[MC_PDELAY] :
-						  mc6_addr[MC_PRIMARY];
+		addr_buf.sin6.sin6_addr =  peer ? udp6->mc6_addr[MC_PDELAY] :
+						  udp6->mc6_addr[MC_PRIMARY];
 		if (is_link_local(&addr_buf.sin6.sin6_addr))
 			addr_buf.sin6.sin6_scope_id = udp6->index;
 
-- 
2.17.1


From 48e605ef015c59787b0a8da9abd208471830cd56 Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Wed, 11 Sep 2019 09:50:17 +0000
Subject: [PATCH 065/173] pmc.8: Mention PORT_STATS_NP

In commit 2b5bec8d2740 ("pmc: Add a new TLV to obtain per-port
statistics"), pmc gained a new TLV to obtain port stats from ptp4l. Mention
the TLV in the pmc man page.

Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 pmc.8 | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/pmc.8 b/pmc.8
index ff85cd6..acf2d90 100644
--- a/pmc.8
+++ b/pmc.8
@@ -193,6 +193,8 @@ The MAC address to which PTP management messages should be sent. Relevant only w
 .TP
 .B PORT_DATA_SET_NP
 .TP
+.B PORT_STATS_NP
+.TP
 .B PRIORITY1
 .TP
 .B PRIORITY2
-- 
2.17.1


From f9f00d8fe8f04e896ee4c95d463be51497e1c788 Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Thu, 12 Sep 2019 11:06:29 +0000
Subject: [PATCH 066/173] util: Add a function to render timestamp type

TLV_PORT_PROPERTIES_NP carries, among other attributes, a timestamp type
used for that port. In order to make it possible to format the value for
user consumption, introduce a new function ts_str().

Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 util.c | 18 ++++++++++++++++++
 util.h |  7 +++++++
 2 files changed, 25 insertions(+)

diff --git a/util.c b/util.c
index 833f1a5..e64a93d 100644
--- a/util.c
+++ b/util.c
@@ -70,6 +70,24 @@ const char *ev_str[] = {
 	"RS_PASSIVE",
 };
 
+const char *ts_str(enum timestamp_type ts)
+{
+	switch (ts) {
+	case TS_SOFTWARE:
+		return "SOFTWARE";
+	case TS_HARDWARE:
+		return "HARDWARE";
+	case TS_LEGACY_HW:
+		return "LEGACY_HW";
+	case TS_ONESTEP:
+		return "ONESTEP";
+	case TS_P2P1STEP:
+		return "P2P1STEP";
+	}
+
+	return "???";
+}
+
 int addreq(enum transport_type type, struct address *a, struct address *b)
 {
 	void *bufa, *bufb;
diff --git a/util.h b/util.h
index 9d3f227..60d28ac 100644
--- a/util.h
+++ b/util.h
@@ -41,6 +41,13 @@ extern const char *ps_str[];
  */
 extern const char *ev_str[];
 
+/**
+ * Gets a human-readable string for a given timestamp type.
+ * @param ts    Timestamp type.
+ * @return      Human-readable rendering if TS is valid, otherwise "???".
+ */
+const char *ts_str(enum timestamp_type ts);
+
 /**
  * Compares two binary addresses for equality.
  * @param type  One of the enumerated transport types.
-- 
2.17.1


From 79856341797eb020c01c6da0fa86fc65da1a407e Mon Sep 17 00:00:00 2001
From: Petr Machata <petrm@mellanox.com>
Date: Thu, 12 Sep 2019 11:06:30 +0000
Subject: [PATCH 067/173] pmc: Support querying TLV_PORT_PROPERTIES_NP

TLV_PORT_PROPERTIES_NP messages serve for querying of port properties, such
as timestamp type and, prominently, netdevice name associated with the
port. pmc however does not support this query, which makes it difficult to
access this information e.g. from scripts. Add this support to pmc.

Signed-off-by: Mykola Zhuravel <mykola@mellanox.com>
Signed-off-by: Petr Machata <petrm@mellanox.com>
---
 pmc.8        |  2 ++
 pmc.c        | 16 ++++++++++++++++
 pmc_common.c |  1 +
 3 files changed, 19 insertions(+)

diff --git a/pmc.8 b/pmc.8
index acf2d90..e0ab5ac 100644
--- a/pmc.8
+++ b/pmc.8
@@ -193,6 +193,8 @@ The MAC address to which PTP management messages should be sent. Relevant only w
 .TP
 .B PORT_DATA_SET_NP
 .TP
+.B PORT_PROPERTIES_NP
+.TP
 .B PORT_STATS_NP
 .TP
 .B PRIORITY1
diff --git a/pmc.c b/pmc.c
index 868fc2a..4e6043b 100644
--- a/pmc.c
+++ b/pmc.c
@@ -69,6 +69,7 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 	struct tlv_extra *extra;
 	struct portDS *p;
 	struct port_ds_np *pnp;
+	struct port_properties_np *ppn;
 	struct port_stats_np *pcp;
 
 	if (msg_type(msg) != MANAGEMENT) {
@@ -323,6 +324,21 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			pnp->neighborPropDelayThresh,
 			pnp->asCapable ? 1 : 0);
 		break;
+	case TLV_PORT_PROPERTIES_NP:
+		ppn = (struct port_properties_np *) mgt->data;
+		if (ppn->port_state > PS_SLAVE) {
+			ppn->port_state = 0;
+		}
+		fprintf(fp, "PORT_PROPERTIES_NP "
+			IFMT "portIdentity            %s"
+			IFMT "portState               %s"
+			IFMT "timestamping            %s"
+			IFMT "interface               %s",
+			pid2str(&ppn->portIdentity),
+			ps_str[ppn->port_state],
+			ts_str(ppn->timestamping),
+			text2str(&ppn->interface));
+		break;
 	case TLV_PORT_STATS_NP:
 		pcp = (struct port_stats_np *) mgt->data;
 		fprintf(fp, "PORT_STATS_NP "
diff --git a/pmc_common.c b/pmc_common.c
index 592cc93..46aac30 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -121,6 +121,7 @@ struct management_id idtab[] = {
 	{ "LOG_MIN_PDELAY_REQ_INTERVAL", TLV_LOG_MIN_PDELAY_REQ_INTERVAL, do_get_action },
 	{ "PORT_DATA_SET_NP", TLV_PORT_DATA_SET_NP, do_set_action },
 	{ "PORT_STATS_NP", TLV_PORT_STATS_NP, do_get_action },
+	{ "PORT_PROPERTIES_NP", TLV_PORT_PROPERTIES_NP, do_get_action },
 };
 
 static void do_get_action(struct pmc *pmc, int action, int index, char *str)
-- 
2.17.1


From f9e84e69bfafaa6ccf13de2bdbc698e540e464a9 Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Thu, 26 Sep 2019 15:54:30 +0200
Subject: [PATCH 068/173] port: Don't leak transport when unicast
 initialization fails.

[RC: Fix two more bad goto labels. ]

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/port.c b/port.c
index 07ad3f0..ed09baf 100644
--- a/port.c
+++ b/port.c
@@ -3036,24 +3036,24 @@ struct port *port_open(int phc_index,
 	p->versionNumber = PTP_VERSION;
 
 	if (number && unicast_client_claim_table(p)) {
-		goto err_port;
+		goto err_transport;
 	}
 	if (unicast_client_enabled(p) &&
 	    config_set_section_int(cfg, p->name, "hybrid_e2e", 1)) {
-		goto err_port;
+		goto err_transport;
 	}
 	if (number && unicast_service_initialize(p)) {
-		goto err_port;
+		goto err_transport;
 	}
 	p->hybrid_e2e = config_get_int(cfg, p->name, "hybrid_e2e");
 
 	if (number && type == CLOCK_TYPE_P2P && p->delayMechanism != DM_P2P) {
 		pr_err("port %d: P2P TC needs P2P ports", number);
-		goto err_port;
+		goto err_transport;
 	}
 	if (number && type == CLOCK_TYPE_E2E && p->delayMechanism != DM_E2E) {
 		pr_err("port %d: E2E TC needs E2E ports", number);
-		goto err_port;
+		goto err_transport;
 	}
 	if (p->hybrid_e2e && p->delayMechanism != DM_E2E) {
 		pr_warning("port %d: hybrid_e2e only works with E2E", number);
-- 
2.17.1


From e20d8228f95180e37805f9c7d7c573466a9d4b2a Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Thu, 26 Sep 2019 15:54:31 +0200
Subject: [PATCH 069/173] port: Avoid calling freed servo after switching PHC.

In port_synchronize(), when the clock returned SERVO_UNLOCKED and
port_dispatch() triggered a switch of the PHC, the variable "s" would
point to a servo which was already freed and the following call of
servo_offset_threshold() would read invalid memory.

Don't save the servo before dispatching the port.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
Fixes: 3f5f5653d796 ("port: Add interval update mechanism.")
---
 port.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/port.c b/port.c
index ed09baf..58fbe66 100644
--- a/port.c
+++ b/port.c
@@ -1137,7 +1137,6 @@ static void port_synchronize(struct port *p,
 {
 	enum servo_state state, last_state;
 	tmv_t t1, t1c, t2, c1, c2;
-	struct servo *s;
 
 	port_set_sync_rx_tmo(p);
 
@@ -1147,13 +1146,12 @@ static void port_synchronize(struct port *p,
 	c2 = correction_to_tmv(correction2);
 	t1c = tmv_add(t1, tmv_add(c1, c2));
 
-	s = clock_servo(p->clock);
 	last_state = clock_servo_state(p->clock);
 	state = clock_synchronize(p->clock, t2, t1c);
 	switch (state) {
 	case SERVO_UNLOCKED:
 		port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
-		if (servo_offset_threshold(s) != 0 &&
+		if (servo_offset_threshold(clock_servo(p->clock)) != 0 &&
 		    sync_interval != p->initialLogSyncInterval) {
 			p->logPdelayReqInterval = p->logMinPdelayReqInterval;
 			p->logSyncInterval = p->initialLogSyncInterval;
@@ -1186,7 +1184,7 @@ static void port_synchronize(struct port *p,
 			 * The most likely reason for this to happen is the
 			 * master daemon re-initialized due to some fault.
 			 */
-			servo_reset(s);
+			servo_reset(clock_servo(p->clock));
 			port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
 		}
 		break;
-- 
2.17.1


From a920c134137a7dc1f703b7431add823065ef7ceb Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 22 Dec 2019 08:26:48 -0800
Subject: [PATCH 070/173] Correct the signature of the legacy system offset
 measurement method.

The sysoff_measure() function gained an additional parameter some time
ago, but the legacy method for older kernels without PTP_SYS_OFFSET was
overlooked.  This patch brings the legacy method up to date again.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 sysoff.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sysoff.c b/sysoff.c
index b993ee9..05d2ed6 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -168,7 +168,7 @@ int sysoff_probe(int fd, int n_samples)
 
 #else /* !PTP_SYS_OFFSET */
 
-int sysoff_measure(int fd, int n_samples,
+int sysoff_measure(int fd, int method, int n_samples,
 		   int64_t *result, uint64_t *ts, int64_t *delay)
 {
 	return SYSOFF_COMPILE_TIME_MISSING;
-- 
2.17.1


From e0580929f451e685d92cd10d80b76f39e9b09a97 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 24 Dec 2019 11:09:34 -0800
Subject: [PATCH 071/173] phc2sys: Fix frequency estimation when synchronizing
 a PHC to the system clock.

When synchronizing a PHC to the Linux system clock (CLOCK_REALTIME),
the phc2sys uses the sysoff method, reversing the master and slave
roles.

The offset between a master clock and a slave clock is given by

    offset = slave_ts - master_ts,

and the call to sysoff_measure() provides the 'offset' and 'slave_ts'
values.  The needed local time stamp on the 'master' is given by

    master_ts = slave_ts - offset,

but the code calcuates

    master_ts = slave_ts + offset.

When passed to the servo, the local time stamp is used to estimate the
frequency offset between the two clocks before starting the main
synchronization loop.  The effect of the bug may be seen with a simple
test.  Here is a sample output with the existing code.

    $ sudo testptp -d /dev/ptp1 -f 62400000
    frequency adjustment okay
    $ sudo ./phc2sys -m -q -c eth6 -s CLOCK_REALTIME -O0
    phc2sys[90221.239]: eth6 sys offset 191001318 s0 freq -62400000 delay   5547
    phc2sys[90222.239]: eth6 sys offset 253380897 s1 freq  +8265884 delay   5507
    phc2sys[90223.239]: eth6 sys offset  -8301685 s2 freq    -35801 delay   5487
    phc2sys[90224.239]: eth6 sys offset  -8297136 s2 freq  -2521757 delay   5531
    phc2sys[90225.239]: eth6 sys offset  -5806117 s2 freq  -2519879 delay   5542
    phc2sys[90226.239]: eth6 sys offset  -3317009 s2 freq  -1772606 delay   5495
    phc2sys[90227.240]: eth6 sys offset  -1575231 s2 freq  -1025931 delay   5505
    phc2sys[90228.240]: eth6 sys offset   -580249 s2 freq   -503518 delay   5524
    phc2sys[90229.240]: eth6 sys offset   -107770 s2 freq   -205114 delay   5519
    phc2sys[90230.240]: eth6 sys offset     66298 s2 freq    -63377 delay   5490
    phc2sys[90230.881]: eth6 sys offset     86942 s2 freq    -22844 delay   5495

And this is the output with the bug fix in place.

    $ sudo testptp -d /dev/ptp1 -f 62400000
    frequency adjustment okay
    $ sudo ./phc2sys -m -q -c eth6 -s CLOCK_REALTIME -O0
    phc2sys[90365.624]: eth6 sys offset 311912675 s0 freq -62400000 delay   5490
    phc2sys[90366.624]: eth6 sys offset 374292766 s1 freq  -31098 delay   5642
    phc2sys[90367.624]: eth6 sys offset     -3825 s2 freq  -34923 delay   5617
    phc2sys[90368.625]: eth6 sys offset         6 s2 freq  -32240 delay   5564
    phc2sys[90369.625]: eth6 sys offset      1241 s2 freq  -31003 delay   5605
    phc2sys[90370.625]: eth6 sys offset      1131 s2 freq  -30741 delay   5600
    phc2sys[90371.625]: eth6 sys offset       801 s2 freq  -30732 delay   5621
    phc2sys[90372.625]: eth6 sys offset       458 s2 freq  -30834 delay   5640
    phc2sys[90373.626]: eth6 sys offset       186 s2 freq  -30969 delay   5598
    phc2sys[90374.626]: eth6 sys offset       134 s2 freq  -30965 delay   5599
    phc2sys[90375.626]: eth6 sys offset        43 s2 freq  -31016 delay   5595
    phc2sys[90375.681]: eth6 sys offset       -32 s2 freq  -31078 delay   5541

This patch fixes the issue by correcting the calculation of the local
time stamp value.

Fixes: 8142da41b61f ("phc2sys: Use reversed sysoff when synchronizing to system clock.")
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reported-by: Cliff Spradlin <cspradlin@google.com>
Tested-by: Vladimir Oltean <olteanv@gmail.com>
---
 phc2sys.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/phc2sys.c b/phc2sys.c
index 28c657a..c0b7b3d 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -770,8 +770,8 @@ static int do_loop(struct node *node, int subscriptions)
 						   node->phc_readings,
 						   &offset, &ts, &delay) < 0)
 					return -1;
-				ts += offset;
 				offset = -offset;
+				ts += offset;
 			} else {
 				/* use phc */
 				if (!read_phc(node->master->clkid, clock->clkid,
-- 
2.17.1


From 581a6bd59b095ec06affc9847c940f9c3435d4fe Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Fri, 31 May 2019 07:25:45 -0700
Subject: [PATCH 072/173] Accept external PHC devices from the command line.

A single, external PTP Hardware Clock device may be wired to one or more
MAC devices, providing the MACs with an input clock.  This patch adds
support for such a hardware architecture by letting the command line PHC
override the one discovered via the ethtool ioctl.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 11 ++++++-----
 port.c  |  8 +++++++-
 port.h  |  4 +++-
 3 files changed, 16 insertions(+), 7 deletions(-)

diff --git a/clock.c b/clock.c
index 146576a..b210649 100644
--- a/clock.c
+++ b/clock.c
@@ -771,8 +771,8 @@ struct currentDS *clock_current_dataset(struct clock *c)
 	return &c->cur;
 }
 
-static int clock_add_port(struct clock *c, int phc_index,
-			  enum timestamp_type timestamping,
+static int clock_add_port(struct clock *c, const char *phc_device,
+			  int phc_index, enum timestamp_type timestamping,
 			  struct interface *iface)
 {
 	struct port *p, *piter, *lastp = NULL;
@@ -780,7 +780,8 @@ static int clock_add_port(struct clock *c, int phc_index,
 	if (clock_resize_pollfd(c, c->nports + 1)) {
 		return -1;
 	}
-	p = port_open(phc_index, timestamping, ++c->last_port_number, iface, c);
+	p = port_open(phc_device, phc_index, timestamping,
+		      ++c->last_port_number, iface, c);
 	if (!p) {
 		/* No need to shrink pollfd */
 		return -1;
@@ -1136,7 +1137,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	}
 
 	/* Create the UDS interface. */
-	c->uds_port = port_open(phc_index, timestamping, 0, udsif, c);
+	c->uds_port = port_open(phc_device, phc_index, timestamping, 0, udsif, c);
 	if (!c->uds_port) {
 		pr_err("failed to open the UDS port");
 		return NULL;
@@ -1145,7 +1146,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 
 	/* Create the ports. */
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
-		if (clock_add_port(c, phc_index, timestamping, iface)) {
+		if (clock_add_port(c, phc_device, phc_index, timestamping, iface)) {
 			pr_err("failed to open port %s", iface->name);
 			return NULL;
 		}
diff --git a/port.c b/port.c
index 58fbe66..f26f1db 100644
--- a/port.c
+++ b/port.c
@@ -2934,7 +2934,8 @@ err:
 	msg_put(msg);
 }
 
-struct port *port_open(int phc_index,
+struct port *port_open(const char *phc_device,
+		       int phc_index,
 		       enum timestamp_type timestamping,
 		       int number,
 		       struct interface *interface,
@@ -2998,6 +2999,11 @@ struct port *port_open(int phc_index,
 		if (p->jbod) {
 			pr_warning("port %d: just a bunch of devices", number);
 			p->phc_index = interface->ts_info.phc_index;
+		} else if (phc_device) {
+			pr_warning("port %d: taking %s from the command line, "
+				   "not the attached ptp%d", number, phc_device,
+				   interface->ts_info.phc_index);
+			p->phc_index = phc_index;
 		} else {
 			pr_err("port %d: PHC device mismatch", number);
 			pr_err("port %d: /dev/ptp%d requested, ptp%d attached",
diff --git a/port.h b/port.h
index aa3b1ec..a45a7a4 100644
--- a/port.h
+++ b/port.h
@@ -192,6 +192,7 @@ void port_notify_event(struct port *p, enum notification event);
 
 /**
  * Open a network port.
+ * @param phc_device    The name of PHC device as found on the command line.
  * @param phc_index     The PHC device index for the network device.
  * @param timestamping  The timestamping mode for this port.
  * @param number	An arbitrary number assigned to this port.
@@ -199,7 +200,8 @@ void port_notify_event(struct port *p, enum notification event);
  * @param clock         A pointer to the system PTP clock.
  * @return A pointer to an open port on success, or NULL otherwise.
  */
-struct port *port_open(int phc_index,
+struct port *port_open(const char *phc_device,
+		       int phc_index,
 		       enum timestamp_type timestamping,
 		       int number,
 		       struct interface *interface,
-- 
2.17.1


From ee6930a884e5b1c2b521b69bbb766e659560c80c Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Thu, 26 Sep 2019 15:54:32 +0200
Subject: [PATCH 073/173] unicast: Enable sharing master tables between ports.

Don't require each port to have its own master table specified in the
config. Instead of ports claming configured tables, clone the table in
each port, so different ports don't interfere with each other.

Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
---
 port.c           | 17 +++++++++------
 ptp4l.8          |  4 +---
 unicast_client.c | 56 ++++++++++++++++++++++++++++++++++++++++++++----
 unicast_client.h |  8 ++++++-
 4 files changed, 71 insertions(+), 14 deletions(-)

diff --git a/port.c b/port.c
index f26f1db..27d9885 100644
--- a/port.c
+++ b/port.c
@@ -2311,6 +2311,7 @@ void port_close(struct port *p)
 		rtnl_close(p->fda.fd[FD_RTNL]);
 	}
 
+	unicast_client_cleanup(p);
 	unicast_service_cleanup(p);
 	transport_destroy(p->trp);
 	tsproc_destroy(p->tsproc);
@@ -3039,25 +3040,25 @@ struct port *port_open(const char *phc_device,
 	p->delayMechanism = config_get_int(cfg, p->name, "delay_mechanism");
 	p->versionNumber = PTP_VERSION;
 
-	if (number && unicast_client_claim_table(p)) {
+	if (number && unicast_client_initialize(p)) {
 		goto err_transport;
 	}
 	if (unicast_client_enabled(p) &&
 	    config_set_section_int(cfg, p->name, "hybrid_e2e", 1)) {
-		goto err_transport;
+		goto err_uc_client;
 	}
 	if (number && unicast_service_initialize(p)) {
-		goto err_transport;
+		goto err_uc_client;
 	}
 	p->hybrid_e2e = config_get_int(cfg, p->name, "hybrid_e2e");
 
 	if (number && type == CLOCK_TYPE_P2P && p->delayMechanism != DM_P2P) {
 		pr_err("port %d: P2P TC needs P2P ports", number);
-		goto err_transport;
+		goto err_uc_service;
 	}
 	if (number && type == CLOCK_TYPE_E2E && p->delayMechanism != DM_E2E) {
 		pr_err("port %d: E2E TC needs E2E ports", number);
-		goto err_transport;
+		goto err_uc_service;
 	}
 	if (p->hybrid_e2e && p->delayMechanism != DM_E2E) {
 		pr_warning("port %d: hybrid_e2e only works with E2E", number);
@@ -3083,7 +3084,7 @@ struct port *port_open(const char *phc_device,
 				  config_get_int(cfg, p->name, "delay_filter_length"));
 	if (!p->tsproc) {
 		pr_err("Failed to create time stamp processor");
-		goto err_transport;
+		goto err_uc_service;
 	}
 	p->nrate.ratio = 1.0;
 
@@ -3100,6 +3101,10 @@ struct port *port_open(const char *phc_device,
 
 err_tsproc:
 	tsproc_destroy(p->tsproc);
+err_uc_service:
+	unicast_service_cleanup(p);
+err_uc_client:
+	unicast_client_cleanup(p);
 err_transport:
 	transport_destroy(p->trp);
 err_port:
diff --git a/ptp4l.8 b/ptp4l.8
index ab156d9..c4e1464 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -275,9 +275,7 @@ The default is 0 (disabled).
 When set to a positive integer, this option specifies the table id to
 be used for unicast discovery.  Each table lives in its own section
 and has a unique, positive numerical ID.  Entries in the table are a
-pair of transport type and protocol address.  Tables may not be shared
-between ports, but nothing prevents table entries from appearing in
-more than table.
+pair of transport type and protocol address.
 The default is 0 (unicast discovery disabled).
 .TP
 .B unicast_req_duration
diff --git a/unicast_client.c b/unicast_client.c
index 6495d6f..67e50ce 100644
--- a/unicast_client.c
+++ b/unicast_client.c
@@ -17,6 +17,8 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA.
  */
+#include <stdlib.h>
+
 #include "port.h"
 #include "port_private.h"
 #include "print.h"
@@ -250,6 +252,45 @@ out:
 	return err;
 }
 
+static void free_master_table(struct unicast_master_table *table)
+{
+	struct unicast_master_address *address;
+
+	while ((address = STAILQ_FIRST(&table->addrs))) {
+		STAILQ_REMOVE_HEAD(&table->addrs, list);
+		free(address);
+	}
+	free(table->peer_name);
+	free(table);
+}
+
+static struct unicast_master_table *
+clone_master_table(struct unicast_master_table *table)
+{
+	struct unicast_master_address *address, *cloned_address;
+	struct unicast_master_table *cloned_table;
+
+	cloned_table = malloc(sizeof(*cloned_table));
+	if (!cloned_table)
+		return NULL;
+	*cloned_table = *table;
+	STAILQ_INIT(&cloned_table->addrs);
+	memset(&cloned_table->list, 0, sizeof(cloned_table->list));
+	if (table->peer_name)
+		cloned_table->peer_name = strdup(table->peer_name);
+
+	STAILQ_FOREACH(address, &table->addrs, list) {
+		cloned_address = malloc(sizeof(*cloned_address));
+		if (!cloned_address) {
+			free_master_table(cloned_table);
+			return NULL;
+		}
+		*cloned_address = *address;
+		STAILQ_INSERT_TAIL(&cloned_table->addrs, cloned_address, list);
+	}
+	return cloned_table;
+}
+
 /* public methods */
 
 int unicast_client_cancel(struct port *p, struct ptp_message *m,
@@ -302,7 +343,7 @@ out:
 	return err;
 }
 
-int unicast_client_claim_table(struct port *p)
+int unicast_client_initialize(struct port *p)
 {
 	struct unicast_master_address *master, *peer;
 	struct config *cfg = clock_config(p->clock);
@@ -322,9 +363,9 @@ int unicast_client_claim_table(struct port *p)
 		pr_err("port %d: no table with id %d", portnum(p), table_id);
 		return -1;
 	}
-	if (table->port) {
-		pr_err("port %d: table %d already claimed by port %d",
-		       portnum(p), table_id, table->port);
+	table = clone_master_table(table);
+	if (!table) {
+		pr_err("low memory");
 		return -1;
 	}
 	peer = &table->peer_addr;
@@ -332,6 +373,7 @@ int unicast_client_claim_table(struct port *p)
 					 table->peer_name, &peer->address)) {
 		pr_err("port %d: bad peer address: %s",
 		       portnum(p), table->peer_name);
+		free_master_table(table);
 		return -1;
 	}
 	STAILQ_FOREACH(master, &table->addrs, list) {
@@ -352,6 +394,12 @@ int unicast_client_claim_table(struct port *p)
 	return 0;
 }
 
+void unicast_client_cleanup(struct port *p)
+{
+	if (p->unicast_master_table)
+		free_master_table(p->unicast_master_table);
+}
+
 int unicast_client_enabled(struct port *p)
 {
 	return p->unicast_master_table ? 1 : 0;
diff --git a/unicast_client.h b/unicast_client.h
index fc8dc6f..16e291f 100644
--- a/unicast_client.h
+++ b/unicast_client.h
@@ -37,7 +37,13 @@ int unicast_client_cancel(struct port *p, struct ptp_message *m,
  * @param port   The port in question.
  * @return       Zero on success, non-zero otherwise.
  */
-int unicast_client_claim_table(struct port *port);
+int unicast_client_initialize(struct port *port);
+
+/**
+ * Frees all of the resources associated with a port's unicast client.
+ * @param p      The port in question.
+ */
+void unicast_client_cleanup(struct port *p);
 
 /**
  * Tests whether a unicast master table is associated with a given port.
-- 
2.17.1


From a380afc482e70bc4f7c2ac150598abc8d6c941dd Mon Sep 17 00:00:00 2001
From: Erik Hons <erik.hons@ni.com>
Date: Tue, 4 Feb 2020 22:34:24 +0000
Subject: [PATCH 074/173] clock: reset master/local rr when best clock id
 changes

This fixes an issue with free running clocks. When the master clock id
changes the measured master/local ratio should be reset. If it isn't,
and the local clock becomes master, then the last measured ratio to
the old master continues to be used in peer delay calculations. If a
bad master/local ration calculation triggers this state change the
port can get "stuck" in not "asCapable" mode.

Signed-off-by: Erik Hons <erik.hons@ni.com>
---
 clock.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/clock.c b/clock.c
index b210649..9f4207d 100644
--- a/clock.c
+++ b/clock.c
@@ -1775,6 +1775,7 @@ static void handle_state_decision_event(struct clock *c)
 			tsproc_set_delay(c->tsproc, c->initial_delay);
 		c->ingress_ts = tmv_zero();
 		c->path_delay = c->initial_delay;
+		c->master_local_rr = 1.0;
 		c->nrr = 1.0;
 		fresh_best = 1;
 	}
-- 
2.17.1


From b8480ef908b915f5e6a68abc5d636381345cf324 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 25 Aug 2019 17:11:32 -0700
Subject: [PATCH 075/173] Group related objects together within the makefile.

Any program that links to the servo interface must also link with the
implementations of that interface.  Similarly, the filter and network
transport interfaces each require their implementations.  This patch
re-factors the makefile to reflect this fact in order to simplify
adding new programs making use of these interfaces.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 makefile | 32 +++++++++++++++++---------------
 1 file changed, 17 insertions(+), 15 deletions(-)

diff --git a/makefile b/makefile
index 3397d3e..d58d13a 100644
--- a/makefile
+++ b/makefile
@@ -23,12 +23,14 @@ VER     = -DVER=$(version)
 CFLAGS	= -Wall $(VER) $(incdefs) $(DEBUG) $(EXTRA_CFLAGS)
 LDLIBS	= -lm -lrt $(EXTRA_LDFLAGS)
 PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster
-OBJ     = bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
-e2e_tc.o fault.o filter.o fsm.o hash.o linreg.o mave.o mmedian.o msg.o ntpshm.o \
-nullf.o phc.o pi.o port.o port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o \
-raw.o rtnl.o servo.o sk.o stats.o tc.o telecom.o tlv.o transport.o tsproc.o \
-udp.o udp6.o uds.o unicast_client.o unicast_fsm.o unicast_service.o util.o \
-version.o
+FILTERS	= filter.o mave.o mmedian.o
+SERVOS	= linreg.o ntpshm.o nullf.o pi.o servo.o
+TRANSP	= raw.o transport.o udp.o udp6.o uds.o
+OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
+ e2e_tc.o fault.o $(FILTERS) fsm.o hash.o msg.o phc.o port.o port_signaling.o \
+ pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o stats.o tc.o \
+ $(TRANSP) telecom.o tlv.o tsproc.o unicast_client.o unicast_fsm.o \
+ unicast_service.o util.o version.o
 
 OBJECTS	= $(OBJ) hwstamp_ctl.o nsm.o phc2sys.o phc_ctl.o pmc.o pmc_common.o \
  sysoff.o timemaster.o
@@ -55,22 +57,22 @@ all: $(PRG)
 
 ptp4l: $(OBJ)
 
-nsm: config.o filter.o hash.o mave.o mmedian.o msg.o nsm.o phc.o print.o raw.o \
- rtnl.o sk.o transport.o tlv.o tsproc.o udp.o udp6.o uds.o util.o version.o
+nsm: config.o $(FILTERS) hash.o msg.o nsm.o phc.o print.o \
+ rtnl.o sk.o $(TRANSP) tlv.o tsproc.o util.o version.o
 
-pmc: config.o hash.o msg.o phc.o pmc.o pmc_common.o print.o raw.o sk.o tlv.o \
- transport.o udp.o udp6.o uds.o util.o version.o
+pmc: config.o hash.o msg.o phc.o pmc.o pmc_common.o print.o sk.o tlv.o \
+ $(TRANSP) util.o version.o
 
-phc2sys: clockadj.o clockcheck.o config.o hash.o linreg.o msg.o ntpshm.o \
- nullf.o phc.o phc2sys.o pi.o pmc_common.o print.o raw.o servo.o sk.o stats.o \
- sysoff.o tlv.o transport.o udp.o udp6.o uds.o util.o version.o
+phc2sys: clockadj.o clockcheck.o config.o hash.o msg.o \
+ phc.o phc2sys.o pmc_common.o print.o $(SERVOS) sk.o stats.o \
+ sysoff.o tlv.o $(TRANSP) util.o version.o
 
 hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
-snmp4lptp: config.o hash.o msg.o phc.o pmc_common.o print.o raw.o sk.o \
- snmp4lptp.o tlv.o transport.o udp.o udp6.o uds.o util.o
+snmp4lptp: config.o hash.o msg.o phc.o pmc_common.o print.o sk.o \
+ snmp4lptp.o tlv.o $(TRANSP) util.o
 	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
 
 snmp4lptp.o: snmp4lptp.c
-- 
2.17.1


From 831f7e073b7ff8dd01e87495c6dc15e31fe8a387 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 07:17:08 -0800
Subject: [PATCH 076/173] config: Constify the public interface.

The two methods, config_create_interface and config_read, never modify the
strings passed in.  This patch adds the const keyword to ensure these
functions stay that way.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 config.c | 4 ++--
 config.h | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/config.c b/config.c
index 12eb1f9..65afa70 100644
--- a/config.c
+++ b/config.c
@@ -710,7 +710,7 @@ static struct option *config_alloc_longopts(void)
 	return opts;
 }
 
-int config_read(char *name, struct config *cfg)
+int config_read(const char *name, struct config *cfg)
 {
 	enum config_section current_section = UNKNOWN_SECTION;
 	enum parser_result parser_res;
@@ -817,7 +817,7 @@ parse_error:
 	return -2;
 }
 
-struct interface *config_create_interface(char *name, struct config *cfg)
+struct interface *config_create_interface(const char *name, struct config *cfg)
 {
 	struct interface *iface;
 
diff --git a/config.h b/config.h
index f237fb2..e27d3e2 100644
--- a/config.h
+++ b/config.h
@@ -60,8 +60,8 @@ struct config {
 	STAILQ_HEAD(ucmtab_head, unicast_master_table) unicast_master_tables;
 };
 
-int config_read(char *name, struct config *cfg);
-struct interface *config_create_interface(char *name, struct config *cfg);
+int config_read(const char *name, struct config *cfg);
+struct interface *config_create_interface(const char *name, struct config *cfg);
 void config_destroy(struct config *cfg);
 
 /* New, hash table based methods: */
-- 
2.17.1


From e4d1988f544e4853fee61852c6eae22a2131d5e4 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 07:19:27 -0800
Subject: [PATCH 077/173] rtnl: Constify the public interface.

Three of the rtnl methods never modify the strings passed in.  This
patch adds the const keyword to ensure these functions stay that way.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 rtnl.c | 6 +++---
 rtnl.h | 6 +++---
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/rtnl.c b/rtnl.c
index 59ed0ec..d9c76d7 100644
--- a/rtnl.c
+++ b/rtnl.c
@@ -87,7 +87,7 @@ static void rtnl_get_ts_device_callback(void *ctx, int linkup, int ts_index)
 	*dst = ts_index;
 }
 
-int rtnl_get_ts_device(char *device, char *ts_device)
+int rtnl_get_ts_device(const char *device, char *ts_device)
 {
 	int err, fd;
 	int ts_index = -1;
@@ -112,7 +112,7 @@ no_info:
 	return err;
 }
 
-int rtnl_link_query(int fd, char *device)
+int rtnl_link_query(int fd, const char *device)
 {
 	struct sockaddr_nl sa;
 	struct msghdr msg;
@@ -227,7 +227,7 @@ static int rtnl_linkinfo_parse(int master_index, struct rtattr *rta)
 	return index;
 }
 
-int rtnl_link_status(int fd, char *device, rtnl_callback cb, void *ctx)
+int rtnl_link_status(int fd, const char *device, rtnl_callback cb, void *ctx)
 {
 	struct rtattr *tb[IFLA_MAX+1];
 	struct ifinfomsg *info = NULL;
diff --git a/rtnl.h b/rtnl.h
index f877cd2..c5ea979 100644
--- a/rtnl.h
+++ b/rtnl.h
@@ -37,7 +37,7 @@ int rtnl_close(int fd);
  *                  at least IF_NAMESIZE bytes long.
  * @return          Zero on success, or -1 on error.
  */
-int rtnl_get_ts_device(char *device, char *ts_device);
+int rtnl_get_ts_device(const char *device, char *ts_device);
 
 /**
  * Request the link status from the kernel.
@@ -45,7 +45,7 @@ int rtnl_get_ts_device(char *device, char *ts_device);
  * @param device Interface name. Request all iface's status if set NULL.
  * @return       Zero on success, non-zero otherwise.
  */
-int rtnl_link_query(int fd, char *device);
+int rtnl_link_query(int fd, const char *device);
 
 /**
  * Read kernel messages looking for a link up/down events.
@@ -55,7 +55,7 @@ int rtnl_link_query(int fd, char *device);
  * @param ctx    Private context passed to the callback.
  * @return       Zero on success, non-zero otherwise.
  */
-int rtnl_link_status(int fd, char *device, rtnl_callback cb, void *ctx);
+int rtnl_link_status(int fd, const char *device, rtnl_callback cb, void *ctx);
 
 /**
  * Open a RT netlink socket for monitoring link state.
-- 
2.17.1


From 9dcd6c31e7840d6916a4ff4d948faf3a87ddff0a Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 11:15:43 -0800
Subject: [PATCH 078/173] utils: Constify the posix clock interface.

The function to open a posix clock never modifies the passed in
string.  This patch adds the const keyword to ensure this function
stays that way.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 util.c | 2 +-
 util.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/util.c b/util.c
index e64a93d..43d6224 100644
--- a/util.c
+++ b/util.c
@@ -190,7 +190,7 @@ char *portaddr2str(struct PortAddress *addr)
 	return buf;
 }
 
-clockid_t posix_clock_open(char *device, int *phc_index)
+clockid_t posix_clock_open(const char *device, int *phc_index)
 {
 	struct sk_ts_info ts_info;
 	char phc_device[19];
diff --git a/util.h b/util.h
index 60d28ac..11e0935 100644
--- a/util.h
+++ b/util.h
@@ -116,7 +116,7 @@ char *portaddr2str(struct PortAddress *addr);
  * @param phc_index  Returns the PHC index, if any.
  * @return           A valid clock ID on success or CLOCK_INVALID otherwise.
  */
-clockid_t posix_clock_open(char *device, int *phc_index);
+clockid_t posix_clock_open(const char *device, int *phc_index);
 
 /**
  * Compare two port identities for equality.
-- 
2.17.1


From c5b9ab990a7210961810d8e3ab7eb5268b1a00ea Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 06:52:49 -0800
Subject: [PATCH 079/173] Move the network interface into its own header file.

Up until now, the users of the interface data structure simply access
its fields without restriction.  This patch takes the first step
towards abstracting this data structure by giving it a file of its
very own.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 config.h    | 15 +--------------
 interface.h | 28 ++++++++++++++++++++++++++++
 2 files changed, 29 insertions(+), 14 deletions(-)
 create mode 100644 interface.h

diff --git a/config.h b/config.h
index e27d3e2..14d2f64 100644
--- a/config.h
+++ b/config.h
@@ -26,25 +26,12 @@
 #include "ds.h"
 #include "dm.h"
 #include "filter.h"
+#include "interface.h"
 #include "mtab.h"
 #include "transport.h"
 #include "servo.h"
 #include "sk.h"
 
-#define MAX_IFNAME_SIZE 108 /* = UNIX_PATH_MAX */
-
-#if (IF_NAMESIZE > MAX_IFNAME_SIZE)
-#error if_namesize larger than expected.
-#endif
-
-/** Defines a network interface, with PTP options. */
-struct interface {
-	STAILQ_ENTRY(interface) list;
-	char name[MAX_IFNAME_SIZE + 1];
-	char ts_label[MAX_IFNAME_SIZE + 1];
-	struct sk_ts_info ts_info;
-};
-
 struct config {
 	/* configured interfaces */
 	STAILQ_HEAD(interfaces_head, interface) interfaces;
diff --git a/interface.h b/interface.h
new file mode 100644
index 0000000..61d53a2
--- /dev/null
+++ b/interface.h
@@ -0,0 +1,28 @@
+/**
+ * @file interface.h
+ * @brief Implements network interface data structures.
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_INTERFACE_H
+#define HAVE_INTERFACE_H
+
+#include <sys/queue.h>
+#include "sk.h"
+
+#define MAX_IFNAME_SIZE 108 /* = UNIX_PATH_MAX */
+
+#if (IF_NAMESIZE > MAX_IFNAME_SIZE)
+#error if_namesize larger than expected.
+#endif
+
+/** Defines a network interface, with PTP options. */
+struct interface {
+	STAILQ_ENTRY(interface) list;
+	char name[MAX_IFNAME_SIZE + 1];
+	char ts_label[MAX_IFNAME_SIZE + 1];
+	struct sk_ts_info ts_info;
+};
+
+#endif
+
-- 
2.17.1


From 380ee349f6f2885ef4527e64deaa7983e0051000 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 07:22:52 -0800
Subject: [PATCH 080/173] interface: Introduce an access method for the name
 field.

Many of the users only require a read only reference to the interface name.
This patch adds an appropriate method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 interface.c | 12 ++++++++++++
 interface.h |  7 +++++++
 makefile    |  8 ++++----
 3 files changed, 23 insertions(+), 4 deletions(-)
 create mode 100644 interface.c

diff --git a/interface.c b/interface.c
new file mode 100644
index 0000000..1231db9
--- /dev/null
+++ b/interface.c
@@ -0,0 +1,12 @@
+/**
+ * @file interface.c
+ * @brief Implements network interface data structures.
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include "interface.h"
+
+const char *interface_name(struct interface *iface)
+{
+	return iface->name;
+}
diff --git a/interface.h b/interface.h
index 61d53a2..94d5b8f 100644
--- a/interface.h
+++ b/interface.h
@@ -24,5 +24,12 @@ struct interface {
 	struct sk_ts_info ts_info;
 };
 
+/**
+ * Obtains the name of a network interface.
+ * @param iface  The interface of interest.
+ * @return       The device name of the network interface.
+ */
+const char *interface_name(struct interface *iface);
+
 #endif
 
diff --git a/makefile b/makefile
index d58d13a..e1e0e99 100644
--- a/makefile
+++ b/makefile
@@ -27,10 +27,10 @@ FILTERS	= filter.o mave.o mmedian.o
 SERVOS	= linreg.o ntpshm.o nullf.o pi.o servo.o
 TRANSP	= raw.o transport.o udp.o udp6.o uds.o
 OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
- e2e_tc.o fault.o $(FILTERS) fsm.o hash.o msg.o phc.o port.o port_signaling.o \
- pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o stats.o tc.o \
- $(TRANSP) telecom.o tlv.o tsproc.o unicast_client.o unicast_fsm.o \
- unicast_service.o util.o version.o
+ e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o msg.o phc.o port.o \
+ port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o \
+ stats.o tc.o $(TRANSP) telecom.o tlv.o tsproc.o unicast_client.o \
+ unicast_fsm.o unicast_service.o util.o version.o
 
 OBJECTS	= $(OBJ) hwstamp_ctl.o nsm.o phc2sys.o phc_ctl.o pmc.o pmc_common.o \
  sysoff.o timemaster.o
-- 
2.17.1


From 34945679fef64de38bb89ba0bff90837b606f007 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 07:24:19 -0800
Subject: [PATCH 081/173] Convert call sites to the proper method for getting
 interface names.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c        | 21 +++++++++++----------
 config.c       | 12 +++++++-----
 makefile       | 10 +++++-----
 nsm.c          |  9 +++++----
 pmc_common.c   |  2 +-
 port.c         | 19 +++++++++++--------
 port_private.h |  2 +-
 udp.c          |  2 +-
 udp6.c         |  2 +-
 uds.c          |  8 ++++----
 10 files changed, 47 insertions(+), 40 deletions(-)

diff --git a/clock.c b/clock.c
index 9f4207d..7d13b3b 100644
--- a/clock.c
+++ b/clock.c
@@ -849,7 +849,7 @@ int clock_required_modes(struct clock *c)
 static void ensure_ts_label(struct interface *iface)
 {
 	if (iface->ts_label[0] == '\0')
-		strncpy(iface->ts_label, iface->name, MAX_IFNAME_SIZE);
+		strncpy(iface->ts_label, interface_name(iface), MAX_IFNAME_SIZE);
 }
 
 struct clock *clock_create(enum clock_type type, struct config *config,
@@ -960,13 +960,13 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	c->timestamping = timestamping;
 	required_modes = clock_required_modes(c);
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
-		rtnl_get_ts_device(iface->name, iface->ts_label);
+		rtnl_get_ts_device(interface_name(iface), iface->ts_label);
 		ensure_ts_label(iface);
 		sk_get_ts_info(iface->ts_label, &iface->ts_info);
 		if (iface->ts_info.valid &&
 		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
-			pr_err("interface '%s' does not support "
-			       "requested timestamping mode", iface->name);
+			pr_err("interface '%s' does not support requested timestamping mode",
+			       interface_name(iface));
 			return NULL;
 		}
 	}
@@ -996,7 +996,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	if (strcmp(config_get_string(config, NULL, "clockIdentity"),
 		   "000000.0000.000000") == 0) {
 		if (generate_clock_identity(&c->dds.clockIdentity,
-					    iface->name)) {
+					    interface_name(iface))) {
 			pr_err("failed to generate a clock identity");
 			return NULL;
 		}
@@ -1011,19 +1011,20 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	/* Configure the UDS. */
 	snprintf(udsif->name, sizeof(udsif->name), "%s",
 		 config_get_string(config, NULL, "uds_address"));
-	if (config_set_section_int(config, udsif->name,
+	if (config_set_section_int(config, interface_name(udsif),
 				   "announceReceiptTimeout", 0)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, udsif->name,
+	if (config_set_section_int(config, interface_name(udsif),
 				    "delay_mechanism", DM_AUTO)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, udsif->name,
+	if (config_set_section_int(config, interface_name(udsif),
 				    "network_transport", TRANS_UDS)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, udsif->name, "delay_filter_length", 1)) {
+	if (config_set_section_int(config, interface_name(udsif),
+				   "delay_filter_length", 1)) {
 		return NULL;
 	}
 
@@ -1147,7 +1148,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	/* Create the ports. */
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
 		if (clock_add_port(c, phc_device, phc_index, timestamping, iface)) {
-			pr_err("failed to open port %s", iface->name);
+			pr_err("failed to open port %s", interface_name(iface));
 			return NULL;
 		}
 	}
diff --git a/config.c b/config.c
index 65afa70..c30f6bc 100644
--- a/config.c
+++ b/config.c
@@ -775,15 +775,15 @@ int config_read(const char *name, struct config *cfg)
 		if (parse_setting_line(line, &option, &value)) {
 			fprintf(stderr, "could not parse line %d in %s section\n",
 				line_num, current_section == GLOBAL_SECTION ?
-				"global" : current_port->name);
+				"global" : interface_name(current_port));
 			goto parse_error;
 		}
 
 		check_deprecated_options(&option);
 
 		parser_res = parse_item(cfg, 0, current_section == GLOBAL_SECTION ?
-					NULL : current_port->name, option, value);
-
+					NULL : interface_name(current_port),
+					option, value);
 		switch (parser_res) {
 		case PARSED_OK:
 			break;
@@ -791,7 +791,7 @@ int config_read(const char *name, struct config *cfg)
 			fprintf(stderr, "unknown option %s at line %d in %s section\n",
 				option, line_num,
 				current_section == GLOBAL_SECTION ? "global" :
-				current_port->name);
+				interface_name(current_port));
 			goto parse_error;
 		case BAD_VALUE:
 			fprintf(stderr, "%s is a bad value for option %s at line %d\n",
@@ -820,10 +820,12 @@ parse_error:
 struct interface *config_create_interface(const char *name, struct config *cfg)
 {
 	struct interface *iface;
+	const char *ifname;
 
 	/* only create each interface once (by name) */
 	STAILQ_FOREACH(iface, &cfg->interfaces, list) {
-		if (0 == strncmp(name, iface->name, MAX_IFNAME_SIZE))
+		ifname = interface_name(iface);
+		if (0 == strncmp(name, ifname, MAX_IFNAME_SIZE))
 			return iface;
 	}
 
diff --git a/makefile b/makefile
index e1e0e99..e1dd3fa 100644
--- a/makefile
+++ b/makefile
@@ -57,13 +57,13 @@ all: $(PRG)
 
 ptp4l: $(OBJ)
 
-nsm: config.o $(FILTERS) hash.o msg.o nsm.o phc.o print.o \
+nsm: config.o $(FILTERS) hash.o interface.o msg.o nsm.o phc.o print.o \
  rtnl.o sk.o $(TRANSP) tlv.o tsproc.o util.o version.o
 
-pmc: config.o hash.o msg.o phc.o pmc.o pmc_common.o print.o sk.o tlv.o \
- $(TRANSP) util.o version.o
+pmc: config.o hash.o interface.o msg.o phc.o pmc.o pmc_common.o print.o sk.o \
+ tlv.o $(TRANSP) util.o version.o
 
-phc2sys: clockadj.o clockcheck.o config.o hash.o msg.o \
+phc2sys: clockadj.o clockcheck.o config.o hash.o interface.o msg.o \
  phc.o phc2sys.o pmc_common.o print.o $(SERVOS) sk.o stats.o \
  sysoff.o tlv.o $(TRANSP) util.o version.o
 
@@ -71,7 +71,7 @@ hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
-snmp4lptp: config.o hash.o msg.o phc.o pmc_common.o print.o sk.o \
+snmp4lptp: config.o hash.o interface.o msg.o phc.o pmc_common.o print.o sk.o \
  snmp4lptp.o tlv.o $(TRANSP) util.o
 	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
 
diff --git a/nsm.c b/nsm.c
index 43daf59..269c3c8 100644
--- a/nsm.c
+++ b/nsm.c
@@ -262,14 +262,15 @@ static void nsm_help(FILE *fp)
 static int nsm_open(struct nsm *nsm, struct config *cfg)
 {
 	enum transport_type transport;
+	const char *ifname, *name;
 	struct interface *iface;
-	const char *name;
 	int count = 0;
 
 	STAILQ_FOREACH(iface, &cfg->interfaces, list) {
-		rtnl_get_ts_device(iface->name, iface->ts_label);
+		ifname = interface_name(iface);
+		rtnl_get_ts_device(ifname, iface->ts_label);
 		if (iface->ts_label[0] == '\0') {
-			strncpy(iface->ts_label, iface->name, MAX_IFNAME_SIZE);
+			strncpy(iface->ts_label, ifname, MAX_IFNAME_SIZE);
 		}
 		count++;
 	}
@@ -278,7 +279,7 @@ static int nsm_open(struct nsm *nsm, struct config *cfg)
 		return -1;
 	}
 	iface = STAILQ_FIRST(&cfg->interfaces);
-	nsm->name = name = iface->name;
+	nsm->name = name = interface_name(iface);
 	nsm->cfg = cfg;
 
 	transport = config_get_int(cfg, name, "network_transport");
diff --git a/pmc_common.c b/pmc_common.c
index 46aac30..d5c8b61 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -352,7 +352,7 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 
 	strncpy(iface.name, iface_name, MAX_IFNAME_SIZE);
 	if (iface.ts_label[0] == '\0') {
-		strncpy(iface.ts_label, iface.name, MAX_IFNAME_SIZE);
+		strncpy(iface.ts_label, interface_name(&iface), MAX_IFNAME_SIZE);
 	}
 
 	if (transport_open(pmc->transport, &iface,
diff --git a/port.c b/port.c
index 27d9885..6423568 100644
--- a/port.c
+++ b/port.c
@@ -1717,10 +1717,13 @@ int port_initialize(struct port *p)
 		if (p->bmca == BMCA_NOOP) {
 			port_set_delay_tmo(p);
 		}
-		if (p->fda.fd[FD_RTNL] == -1)
+		if (p->fda.fd[FD_RTNL] == -1) {
 			p->fda.fd[FD_RTNL] = rtnl_open();
-		if (p->fda.fd[FD_RTNL] >= 0)
-			rtnl_link_query(p->fda.fd[FD_RTNL], p->iface->name);
+		}
+		if (p->fda.fd[FD_RTNL] >= 0) {
+			const char *ifname = interface_name(p->iface);
+			rtnl_link_query(p->fda.fd[FD_RTNL], ifname);
+		}
 	}
 
 	port_nrate_initialize(p);
@@ -2974,10 +2977,10 @@ struct port *port_open(const char *phc_device,
 	}
 
 	p->phc_index = phc_index;
-	p->jbod = config_get_int(cfg, interface->name, "boundary_clock_jbod");
-	transport = config_get_int(cfg, interface->name, "network_transport");
-	p->master_only = config_get_int(cfg, interface->name, "masterOnly");
-	p->bmca = config_get_int(cfg, interface->name, "BMCA");
+	p->jbod = config_get_int(cfg, interface_name(interface), "boundary_clock_jbod");
+	transport = config_get_int(cfg, interface_name(interface), "network_transport");
+	p->master_only = config_get_int(cfg, interface_name(interface), "masterOnly");
+	p->bmca = config_get_int(cfg, interface_name(interface), "BMCA");
 
 	if (p->bmca == BMCA_NOOP && transport != TRANS_UDS) {
 		if (p->master_only) {
@@ -3013,7 +3016,7 @@ struct port *port_open(const char *phc_device,
 		}
 	}
 
-	p->name = interface->name;
+	p->name = interface_name(interface);
 	p->iface = interface;
 	p->asymmetry = config_get_int(cfg, p->name, "delayAsymmetry");
 	p->asymmetry <<= 16;
diff --git a/port_private.h b/port_private.h
index 5789fbb..bc16d95 100644
--- a/port_private.h
+++ b/port_private.h
@@ -60,7 +60,7 @@ struct tc_txd {
 
 struct port {
 	LIST_ENTRY(port) list;
-	char *name;
+	const char *name;
 	struct interface *iface;
 	struct clock *clock;
 	struct transport *trp;
diff --git a/udp.c b/udp.c
index 48af482..143f714 100644
--- a/udp.c
+++ b/udp.c
@@ -154,9 +154,9 @@ static int udp_open(struct transport *t, struct interface *iface,
 		    struct fdarray *fda, enum timestamp_type ts_type)
 {
 	struct udp *udp = container_of(t, struct udp, t);
+	const char *name = interface_name(iface);
 	uint8_t event_dscp, general_dscp;
 	int efd, gfd, ttl;
-	char *name = iface->name;
 
 	ttl = config_get_int(t->cfg, name, "udp_ttl");
 	udp->mac.len = 0;
diff --git a/udp6.c b/udp6.c
index 74ebc7f..6e5f86f 100644
--- a/udp6.c
+++ b/udp6.c
@@ -164,9 +164,9 @@ static int udp6_open(struct transport *t, struct interface *iface,
 		     struct fdarray *fda, enum timestamp_type ts_type)
 {
 	struct udp6 *udp6 = container_of(t, struct udp6, t);
+	const char *name = interface_name(iface);
 	uint8_t event_dscp, general_dscp;
 	int efd, gfd, hop_limit;
-	char *name = iface->name;
 
 	hop_limit = config_get_int(t->cfg, name, "udp_ttl");
 	udp6->mac.len = 0;
diff --git a/uds.c b/uds.c
index 44d135f..a4c856b 100644
--- a/uds.c
+++ b/uds.c
@@ -55,11 +55,11 @@ static int uds_close(struct transport *t, struct fdarray *fda)
 static int uds_open(struct transport *t, struct interface *iface, struct fdarray *fda,
 		    enum timestamp_type tt)
 {
-	int fd, err;
-	struct sockaddr_un sa;
-	struct uds *uds = container_of(t, struct uds, t);
 	char *uds_path = config_get_string(t->cfg, NULL, "uds_address");
-	char *name = iface->name;
+	struct uds *uds = container_of(t, struct uds, t);
+	const char *name = interface_name(iface);
+	struct sockaddr_un sa;
+	int fd, err;
 
 	fd = socket(AF_LOCAL, SOCK_DGRAM, 0);
 	if (fd < 0) {
-- 
2.17.1


From a3c0a88b82c6611abee42a406b17b1446bdeb4b8 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 10:56:54 -0800
Subject: [PATCH 082/173] interface: Introduce an access method for the time
 stamping label.

Many of the users only require a read only reference to the time
stamping label of the interface.  This patch adds an appropriate
method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 9 +++++++++
 2 files changed, 14 insertions(+)

diff --git a/interface.c b/interface.c
index 1231db9..7909a5e 100644
--- a/interface.c
+++ b/interface.c
@@ -6,6 +6,11 @@
  */
 #include "interface.h"
 
+const char *interface_label(struct interface *iface)
+{
+	return iface->ts_label;
+}
+
 const char *interface_name(struct interface *iface)
 {
 	return iface->name;
diff --git a/interface.h b/interface.h
index 94d5b8f..89f3e94 100644
--- a/interface.h
+++ b/interface.h
@@ -24,6 +24,15 @@ struct interface {
 	struct sk_ts_info ts_info;
 };
 
+/**
+ * Obtain the time stamping label of a network interface.  This can be
+ * different from the name of the interface when bonding is in effect.
+ *
+ * @param iface  The interface of interest.
+ * @return       The time stamping device name of the network interface.
+ */
+const char *interface_label(struct interface *iface);
+
 /**
  * Obtains the name of a network interface.
  * @param iface  The interface of interest.
-- 
2.17.1


From e752cac7b1198ec9b441d03c850d9001449b1445 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 13:47:18 -0800
Subject: [PATCH 083/173] Convert call sites to the proper method for getting
 interface labels.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c |  2 +-
 port.c  | 17 ++++++++++-------
 raw.c   |  5 +++--
 udp.c   |  2 +-
 udp6.c  |  2 +-
 5 files changed, 16 insertions(+), 12 deletions(-)

diff --git a/clock.c b/clock.c
index 7d13b3b..66c6bc1 100644
--- a/clock.c
+++ b/clock.c
@@ -962,7 +962,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
 		rtnl_get_ts_device(interface_name(iface), iface->ts_label);
 		ensure_ts_label(iface);
-		sk_get_ts_info(iface->ts_label, &iface->ts_info);
+		sk_get_ts_info(interface_label(iface), &iface->ts_info);
 		if (iface->ts_info.valid &&
 		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
 			pr_err("interface '%s' does not support requested timestamping mode",
diff --git a/port.c b/port.c
index 6423568..52aef86 100644
--- a/port.c
+++ b/port.c
@@ -792,6 +792,7 @@ static int port_management_fill_response(struct port *target,
 	struct management_tlv *tlv;
 	struct port_ds_np *pdsnp;
 	struct tlv_extra *extra;
+	const char *ts_label;
 	struct portDS *pds;
 	uint16_t u16;
 	uint8_t *buf;
@@ -941,7 +942,8 @@ static int port_management_fill_response(struct port *target,
 		else
 			ppn->port_state = target->state;
 		ppn->timestamping = target->timestamping;
-		ptp_text_set(&ppn->interface, target->iface->ts_label);
+		ts_label = interface_label(target->iface);
+		ptp_text_set(&ppn->interface, ts_label);
 		datalen = sizeof(*ppn) + ppn->interface.length;
 		break;
 	case TLV_PORT_STATS_NP:
@@ -2482,10 +2484,10 @@ static void bc_dispatch(struct port *p, enum fsm_event event, int mdiff)
 
 void port_link_status(void *ctx, int linkup, int ts_index)
 {
-	struct port *p = ctx;
-	int link_state;
 	char ts_label[MAX_IFNAME_SIZE + 1] = {0};
-	int required_modes;
+	int link_state, required_modes;
+	const char *old_ts_label;
+	struct port *p = ctx;
 
 	link_state = linkup ? LINK_UP : LINK_DOWN;
 	if (p->link_status & link_state) {
@@ -2496,7 +2498,8 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 	}
 
 	/* ts_label changed */
-	if (if_indextoname(ts_index, ts_label) && strcmp(p->iface->ts_label, ts_label)) {
+	old_ts_label = interface_label(p->iface);
+	if (if_indextoname(ts_index, ts_label) && strcmp(old_ts_label, ts_label)) {
 		strncpy(p->iface->ts_label, ts_label, MAX_IFNAME_SIZE);
 		p->link_status |= TS_LABEL_CHANGED;
 		pr_notice("port %hu: ts label changed to %s", portnum(p), ts_label);
@@ -2505,7 +2508,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 	/* Both link down/up and change ts_label may change phc index. */
 	if (p->link_status & LINK_UP &&
 	    (p->link_status & LINK_STATE_CHANGED || p->link_status & TS_LABEL_CHANGED)) {
-		sk_get_ts_info(p->iface->ts_label, &p->iface->ts_info);
+		sk_get_ts_info(interface_label(p->iface), &p->iface->ts_info);
 
 		/* Only switch phc with HW time stamping mode */
 		if (p->iface->ts_info.valid && p->iface->ts_info.phc_index >= 0) {
@@ -2513,7 +2516,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 			if ((p->iface->ts_info.so_timestamping & required_modes) != required_modes) {
 				pr_err("interface '%s' does not support requested "
 				       "timestamping mode, set link status down by force.",
-				       p->iface->ts_label);
+				       interface_label(p->iface));
 				p->link_status = LINK_DOWN | LINK_STATE_CHANGED;
 			} else if (p->phc_index != p->iface->ts_info.phc_index) {
 				p->phc_index = p->iface->ts_info.phc_index;
diff --git a/raw.c b/raw.c
index f1c92b9..81ec431 100644
--- a/raw.c
+++ b/raw.c
@@ -213,9 +213,10 @@ static int raw_open(struct transport *t, struct interface *iface,
 	unsigned char ptp_dst_mac[MAC_LEN];
 	unsigned char p2p_dst_mac[MAC_LEN];
 	int efd, gfd, socket_priority;
-	char *str, *name;
+	const char *name;
+	char *str;
 
-	name = iface->ts_label;
+	name = interface_label(iface);
 	str = config_get_string(t->cfg, name, "ptp_dst_mac");
 	if (str2mac(str, ptp_dst_mac)) {
 		pr_err("invalid ptp_dst_mac %s", str);
diff --git a/udp.c b/udp.c
index 143f714..eb7be78 100644
--- a/udp.c
+++ b/udp.c
@@ -179,7 +179,7 @@ static int udp_open(struct transport *t, struct interface *iface,
 	if (gfd < 0)
 		goto no_general;
 
-	if (sk_timestamping_init(efd, iface->ts_label, ts_type, TRANS_UDP_IPV4))
+	if (sk_timestamping_init(efd, interface_label(iface), ts_type, TRANS_UDP_IPV4))
 		goto no_timestamping;
 
 	if (sk_general_init(gfd))
diff --git a/udp6.c b/udp6.c
index 6e5f86f..6cb571b 100644
--- a/udp6.c
+++ b/udp6.c
@@ -196,7 +196,7 @@ static int udp6_open(struct transport *t, struct interface *iface,
 	if (gfd < 0)
 		goto no_general;
 
-	if (sk_timestamping_init(efd, iface->ts_label, ts_type, TRANS_UDP_IPV6))
+	if (sk_timestamping_init(efd, interface_label(iface), ts_type, TRANS_UDP_IPV6))
 		goto no_timestamping;
 
 	if (sk_general_init(gfd))
-- 
2.17.1


From cca19dab99992659f79b000b3afc3264d53e5ff2 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 11:14:42 -0800
Subject: [PATCH 084/173] interface: Introduce a method to get the time
 stamping information.

In order to prevent users from open coding this logic, this patch
provides a method that populates the time stamping information from
the interface label.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 7 +++++++
 2 files changed, 12 insertions(+)

diff --git a/interface.c b/interface.c
index 7909a5e..460ceb8 100644
--- a/interface.c
+++ b/interface.c
@@ -6,6 +6,11 @@
  */
 #include "interface.h"
 
+int interface_get_tsinfo(struct interface *iface)
+{
+	return sk_get_ts_info(iface->ts_label, &iface->ts_info);
+}
+
 const char *interface_label(struct interface *iface)
 {
 	return iface->ts_label;
diff --git a/interface.h b/interface.h
index 89f3e94..05cfb10 100644
--- a/interface.h
+++ b/interface.h
@@ -24,6 +24,13 @@ struct interface {
 	struct sk_ts_info ts_info;
 };
 
+/**
+ * Populate the time stamping information of a given interface.
+ * @param iface  The interface of interest.
+ * @return       zero on success, negative on failure.
+ */
+int interface_get_tsinfo(struct interface *iface);
+
 /**
  * Obtain the time stamping label of a network interface.  This can be
  * different from the name of the interface when bonding is in effect.
-- 
2.17.1


From 6d73e755c37d131a9204183cfcb2631bb4c0f34c Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 13:48:42 -0800
Subject: [PATCH 085/173] Convert call sites to the proper method for getting
 time stamp information.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c | 2 +-
 port.c  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/clock.c b/clock.c
index 66c6bc1..f987965 100644
--- a/clock.c
+++ b/clock.c
@@ -962,7 +962,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
 		rtnl_get_ts_device(interface_name(iface), iface->ts_label);
 		ensure_ts_label(iface);
-		sk_get_ts_info(interface_label(iface), &iface->ts_info);
+		interface_get_tsinfo(iface);
 		if (iface->ts_info.valid &&
 		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
 			pr_err("interface '%s' does not support requested timestamping mode",
diff --git a/port.c b/port.c
index 52aef86..05eb1d6 100644
--- a/port.c
+++ b/port.c
@@ -2508,7 +2508,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 	/* Both link down/up and change ts_label may change phc index. */
 	if (p->link_status & LINK_UP &&
 	    (p->link_status & LINK_STATE_CHANGED || p->link_status & TS_LABEL_CHANGED)) {
-		sk_get_ts_info(interface_label(p->iface), &p->iface->ts_info);
+		interface_get_tsinfo(p->iface);
 
 		/* Only switch phc with HW time stamping mode */
 		if (p->iface->ts_info.valid && p->iface->ts_info.phc_index >= 0) {
-- 
2.17.1


From b802e3b7840b0065560cb284e3d5df7f549b41d6 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 11:40:24 -0800
Subject: [PATCH 086/173] interface: Introduce a method to initialize the time
 stamping label.

In many cases, the time stamping label will be the same as the name of
the interface.  In order to prevent users from open coding the logic that
initializes the label from the interface name, this patch add an
appropriate method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 7 +++++++
 interface.h | 6 ++++++
 2 files changed, 13 insertions(+)

diff --git a/interface.c b/interface.c
index 460ceb8..662552d 100644
--- a/interface.c
+++ b/interface.c
@@ -6,6 +6,13 @@
  */
 #include "interface.h"
 
+void interface_ensure_tslabel(struct interface *iface)
+{
+	if (!iface->ts_label[0]) {
+		strncpy(iface->ts_label, iface->name, MAX_IFNAME_SIZE);
+	}
+}
+
 int interface_get_tsinfo(struct interface *iface)
 {
 	return sk_get_ts_info(iface->ts_label, &iface->ts_info);
diff --git a/interface.h b/interface.h
index 05cfb10..371185d 100644
--- a/interface.h
+++ b/interface.h
@@ -24,6 +24,12 @@ struct interface {
 	struct sk_ts_info ts_info;
 };
 
+/**
+ * Ensures that an interface has a proper time stamping label.
+ * @param iface  The interface of interest.
+ */
+void interface_ensure_tslabel(struct interface *iface);
+
 /**
  * Populate the time stamping information of a given interface.
  * @param iface  The interface of interest.
-- 
2.17.1


From a8df585e044012de9f931372b750692e77fefb0f Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 13:50:53 -0800
Subject: [PATCH 087/173] Convert call sites to the proper method for
 initializing the time stamping label.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c      | 12 +-----------
 nsm.c        |  4 +---
 pmc_common.c |  4 +---
 3 files changed, 3 insertions(+), 17 deletions(-)

diff --git a/clock.c b/clock.c
index f987965..3895d09 100644
--- a/clock.c
+++ b/clock.c
@@ -842,16 +842,6 @@ int clock_required_modes(struct clock *c)
 	return required_modes;
 }
 
-/*
- * If we do not have a slave or the rtnl query failed, then use our
- * own interface name as the time stamping interface name.
- */
-static void ensure_ts_label(struct interface *iface)
-{
-	if (iface->ts_label[0] == '\0')
-		strncpy(iface->ts_label, interface_name(iface), MAX_IFNAME_SIZE);
-}
-
 struct clock *clock_create(enum clock_type type, struct config *config,
 			   const char *phc_device)
 {
@@ -961,7 +951,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	required_modes = clock_required_modes(c);
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
 		rtnl_get_ts_device(interface_name(iface), iface->ts_label);
-		ensure_ts_label(iface);
+		interface_ensure_tslabel(iface);
 		interface_get_tsinfo(iface);
 		if (iface->ts_info.valid &&
 		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
diff --git a/nsm.c b/nsm.c
index 269c3c8..e82fc37 100644
--- a/nsm.c
+++ b/nsm.c
@@ -269,9 +269,7 @@ static int nsm_open(struct nsm *nsm, struct config *cfg)
 	STAILQ_FOREACH(iface, &cfg->interfaces, list) {
 		ifname = interface_name(iface);
 		rtnl_get_ts_device(ifname, iface->ts_label);
-		if (iface->ts_label[0] == '\0') {
-			strncpy(iface->ts_label, ifname, MAX_IFNAME_SIZE);
-		}
+		interface_ensure_tslabel(iface);
 		count++;
 	}
 	if (count != 1) {
diff --git a/pmc_common.c b/pmc_common.c
index d5c8b61..6bdaa94 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -351,9 +351,7 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 	}
 
 	strncpy(iface.name, iface_name, MAX_IFNAME_SIZE);
-	if (iface.ts_label[0] == '\0') {
-		strncpy(iface.ts_label, interface_name(&iface), MAX_IFNAME_SIZE);
-	}
+	interface_ensure_tslabel(&iface);
 
 	if (transport_open(pmc->transport, &iface,
 			   &pmc->fdarray, TS_SOFTWARE)) {
-- 
2.17.1


From 47982fb8c8c2c0861583ffc6b62ad0af6ee967d6 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 13:26:24 -0800
Subject: [PATCH 088/173] interface: Introduce a method to set the name.

The name field of the interface is set in different ways by different
callers.  In order to prevent users from open coding the logic that sets
the name, this patch adds an appropriate method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 8 +++++++-
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/interface.c b/interface.c
index 662552d..3811679 100644
--- a/interface.c
+++ b/interface.c
@@ -27,3 +27,8 @@ const char *interface_name(struct interface *iface)
 {
 	return iface->name;
 }
+
+void interface_set_name(struct interface *iface, const char *name)
+{
+	strncpy(iface->name, name, MAX_IFNAME_SIZE);
+}
diff --git a/interface.h b/interface.h
index 371185d..5f449ae 100644
--- a/interface.h
+++ b/interface.h
@@ -53,5 +53,11 @@ const char *interface_label(struct interface *iface);
  */
 const char *interface_name(struct interface *iface);
 
-#endif
+/**
+ * Set the name of a given interface.
+ * @param iface  The interface of interest.
+ * @param name   The desired name for the interface.
+ */
+void interface_set_name(struct interface *iface, const char *name);
 
+#endif
-- 
2.17.1


From d471a57aa864e620e5b8033f9029da559161c49e Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 13:58:39 -0800
Subject: [PATCH 089/173] Convert call sites to the proper method for setting
 the name.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c      | 5 +++--
 config.c     | 2 +-
 pmc_common.c | 2 +-
 3 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/clock.c b/clock.c
index 3895d09..159fcb2 100644
--- a/clock.c
+++ b/clock.c
@@ -850,6 +850,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	int fadj = 0, max_adj = 0, sw_ts;
 	int phc_index, required_modes = 0;
 	struct clock *c = &the_clock;
+	const char *uds_ifname;
 	struct port *p;
 	unsigned char oui[OUI_LEN];
 	char phc[32], *tmp;
@@ -999,8 +1000,8 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	}
 
 	/* Configure the UDS. */
-	snprintf(udsif->name, sizeof(udsif->name), "%s",
-		 config_get_string(config, NULL, "uds_address"));
+	uds_ifname = config_get_string(config, NULL, "uds_address");
+	interface_set_name(udsif, uds_ifname);
 	if (config_set_section_int(config, interface_name(udsif),
 				   "announceReceiptTimeout", 0)) {
 		return NULL;
diff --git a/config.c b/config.c
index c30f6bc..717ee65 100644
--- a/config.c
+++ b/config.c
@@ -835,7 +835,7 @@ struct interface *config_create_interface(const char *name, struct config *cfg)
 		return NULL;
 	}
 
-	strncpy(iface->name, name, MAX_IFNAME_SIZE);
+	interface_set_name(iface, name);
 	STAILQ_INSERT_TAIL(&cfg->interfaces, iface, list);
 	cfg->n_interfaces++;
 
diff --git a/pmc_common.c b/pmc_common.c
index 6bdaa94..41181fb 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -350,7 +350,7 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 		goto failed;
 	}
 
-	strncpy(iface.name, iface_name, MAX_IFNAME_SIZE);
+	interface_set_name(&iface, iface_name);
 	interface_ensure_tslabel(&iface);
 
 	if (transport_open(pmc->transport, &iface,
-- 
2.17.1


From 5f9d36c76a0118fa757d21d047fd1dbcacbad335 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 14:55:34 -0800
Subject: [PATCH 090/173] interface: Introduce a method to set the time
 stamping label.

The ts_label field of the interface is set in different ways by different
callers.  In order to prevent users from open coding the logic that sets
the label, this patch adds an appropriate method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 7 +++++++
 2 files changed, 12 insertions(+)

diff --git a/interface.c b/interface.c
index 3811679..d7eeb41 100644
--- a/interface.c
+++ b/interface.c
@@ -28,6 +28,11 @@ const char *interface_name(struct interface *iface)
 	return iface->name;
 }
 
+void interface_set_label(struct interface *iface, const char *label)
+{
+	strncpy(iface->ts_label, label, MAX_IFNAME_SIZE);
+}
+
 void interface_set_name(struct interface *iface, const char *name)
 {
 	strncpy(iface->name, name, MAX_IFNAME_SIZE);
diff --git a/interface.h b/interface.h
index 5f449ae..f416b24 100644
--- a/interface.h
+++ b/interface.h
@@ -53,6 +53,13 @@ const char *interface_label(struct interface *iface);
  */
 const char *interface_name(struct interface *iface);
 
+/**
+ * Set the time stamping label of a given interface.
+ * @param iface  The interface of interest.
+ * @param name   The desired label for the interface.
+ */
+void interface_set_label(struct interface *iface, const char *label);
+
 /**
  * Set the name of a given interface.
  * @param iface  The interface of interest.
-- 
2.17.1


From e43a76cbe6c7dc47c80e57bcabee44fe258aecb1 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 15:01:27 -0800
Subject: [PATCH 091/173] Convert call sites to the proper method for setting
 the time stamping label.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 6 ++++--
 nsm.c   | 5 ++++-
 port.c  | 2 +-
 rtnl.c  | 2 +-
 rtnl.h  | 4 +++-
 5 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/clock.c b/clock.c
index 159fcb2..5001e66 100644
--- a/clock.c
+++ b/clock.c
@@ -846,6 +846,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 			   const char *phc_device)
 {
 	enum servo_type servo = config_get_int(config, NULL, "clock_servo");
+	char ts_label[IF_NAMESIZE], phc[32], *tmp;
 	enum timestamp_type timestamping;
 	int fadj = 0, max_adj = 0, sw_ts;
 	int phc_index, required_modes = 0;
@@ -853,7 +854,6 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	const char *uds_ifname;
 	struct port *p;
 	unsigned char oui[OUI_LEN];
-	char phc[32], *tmp;
 	struct interface *iface, *udsif = &c->uds_interface;
 	struct timespec ts;
 	int sfl;
@@ -951,7 +951,9 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	c->timestamping = timestamping;
 	required_modes = clock_required_modes(c);
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
-		rtnl_get_ts_device(interface_name(iface), iface->ts_label);
+		memset(ts_label, 0, sizeof(ts_label));
+		rtnl_get_ts_device(interface_name(iface), ts_label);
+		interface_set_label(iface, ts_label);
 		interface_ensure_tslabel(iface);
 		interface_get_tsinfo(iface);
 		if (iface->ts_info.valid &&
diff --git a/nsm.c b/nsm.c
index e82fc37..1292c6b 100644
--- a/nsm.c
+++ b/nsm.c
@@ -262,13 +262,16 @@ static void nsm_help(FILE *fp)
 static int nsm_open(struct nsm *nsm, struct config *cfg)
 {
 	enum transport_type transport;
+	char ts_label[IF_NAMESIZE];
 	const char *ifname, *name;
 	struct interface *iface;
 	int count = 0;
 
 	STAILQ_FOREACH(iface, &cfg->interfaces, list) {
 		ifname = interface_name(iface);
-		rtnl_get_ts_device(ifname, iface->ts_label);
+		memset(ts_label, 0, sizeof(ts_label));
+		rtnl_get_ts_device(ifname, ts_label);
+		interface_set_label(iface, ts_label);
 		interface_ensure_tslabel(iface);
 		count++;
 	}
diff --git a/port.c b/port.c
index 05eb1d6..c20c3fc 100644
--- a/port.c
+++ b/port.c
@@ -2500,7 +2500,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 	/* ts_label changed */
 	old_ts_label = interface_label(p->iface);
 	if (if_indextoname(ts_index, ts_label) && strcmp(old_ts_label, ts_label)) {
-		strncpy(p->iface->ts_label, ts_label, MAX_IFNAME_SIZE);
+		interface_set_label(p->iface, ts_label);
 		p->link_status |= TS_LABEL_CHANGED;
 		pr_notice("port %hu: ts label changed to %s", portnum(p), ts_label);
 	}
diff --git a/rtnl.c b/rtnl.c
index d9c76d7..b7a2667 100644
--- a/rtnl.c
+++ b/rtnl.c
@@ -87,7 +87,7 @@ static void rtnl_get_ts_device_callback(void *ctx, int linkup, int ts_index)
 	*dst = ts_index;
 }
 
-int rtnl_get_ts_device(const char *device, char *ts_device)
+int rtnl_get_ts_device(const char *device, char ts_device[IF_NAMESIZE])
 {
 	int err, fd;
 	int ts_index = -1;
diff --git a/rtnl.h b/rtnl.h
index c5ea979..8fef4a9 100644
--- a/rtnl.h
+++ b/rtnl.h
@@ -20,6 +20,8 @@
 #ifndef HAVE_RTNL_H
 #define HAVE_RTNL_H
 
+#include <net/if.h>
+
 typedef void (*rtnl_callback)(void *ctx, int linkup, int ts_index);
 
 /**
@@ -37,7 +39,7 @@ int rtnl_close(int fd);
  *                  at least IF_NAMESIZE bytes long.
  * @return          Zero on success, or -1 on error.
  */
-int rtnl_get_ts_device(const char *device, char *ts_device);
+int rtnl_get_ts_device(const char *device, char ts_device[IF_NAMESIZE]);
 
 /**
  * Request the link status from the kernel.
-- 
2.17.1


From a228de7dff56ccd52f1994421e5d79c5c7c49e11 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 15:34:22 -0800
Subject: [PATCH 092/173] interface: Introduce a method to get the PHC index.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 7 +++++++
 2 files changed, 12 insertions(+)

diff --git a/interface.c b/interface.c
index d7eeb41..02f63a0 100644
--- a/interface.c
+++ b/interface.c
@@ -28,6 +28,11 @@ const char *interface_name(struct interface *iface)
 	return iface->name;
 }
 
+int interface_phc_index(struct interface *iface)
+{
+	return iface->ts_info.phc_index;
+}
+
 void interface_set_label(struct interface *iface, const char *label)
 {
 	strncpy(iface->ts_label, label, MAX_IFNAME_SIZE);
diff --git a/interface.h b/interface.h
index f416b24..4f408d5 100644
--- a/interface.h
+++ b/interface.h
@@ -53,6 +53,13 @@ const char *interface_label(struct interface *iface);
  */
 const char *interface_name(struct interface *iface);
 
+/**
+ * Obtains the index of a PTP Hardware Clock device from a network interface.
+ * @param iface  The interface of interest.
+ * @return       The PHC index of the interface.
+ */
+int interface_phc_index(struct interface *iface);
+
 /**
  * Set the time stamping label of a given interface.
  * @param iface  The interface of interest.
-- 
2.17.1


From 02bbf36c2a66c804bc4c91afef87e9f847986bf3 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 15:36:12 -0800
Subject: [PATCH 093/173] Convert call sites to the proper method for getting
 the PHC index.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c |  2 +-
 port.c  | 17 ++++++++++-------
 2 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/clock.c b/clock.c
index 5001e66..71b3899 100644
--- a/clock.c
+++ b/clock.c
@@ -976,7 +976,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 			phc_index = -1;
 		}
 	} else if (iface->ts_info.valid) {
-		phc_index = iface->ts_info.phc_index;
+		phc_index = interface_phc_index(iface);
 	} else {
 		pr_err("PTP device not specified and automatic determination"
 		       " is not supported. Please specify PTP device.");
diff --git a/port.c b/port.c
index c20c3fc..f4834ba 100644
--- a/port.c
+++ b/port.c
@@ -2511,15 +2511,16 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 		interface_get_tsinfo(p->iface);
 
 		/* Only switch phc with HW time stamping mode */
-		if (p->iface->ts_info.valid && p->iface->ts_info.phc_index >= 0) {
+		if (p->iface->ts_info.valid &&
+		    interface_phc_index(p->iface) >= 0) {
 			required_modes = clock_required_modes(p->clock);
 			if ((p->iface->ts_info.so_timestamping & required_modes) != required_modes) {
 				pr_err("interface '%s' does not support requested "
 				       "timestamping mode, set link status down by force.",
 				       interface_label(p->iface));
 				p->link_status = LINK_DOWN | LINK_STATE_CHANGED;
-			} else if (p->phc_index != p->iface->ts_info.phc_index) {
-				p->phc_index = p->iface->ts_info.phc_index;
+			} else if (p->phc_index != interface_phc_index(p->iface)) {
+				p->phc_index = interface_phc_index(p->iface);
 
 				if (clock_switch_phc(p->clock, p->phc_index)) {
 					p->last_fault_type = FT_SWITCH_PHC;
@@ -3002,19 +3003,21 @@ struct port *port_open(const char *phc_device,
 		; /* UDS cannot have a PHC. */
 	} else if (!interface->ts_info.valid) {
 		pr_warning("port %d: get_ts_info not supported", number);
-	} else if (phc_index >= 0 && phc_index != interface->ts_info.phc_index) {
+	} else if (phc_index >= 0 &&
+		   phc_index != interface_phc_index(interface)) {
 		if (p->jbod) {
 			pr_warning("port %d: just a bunch of devices", number);
-			p->phc_index = interface->ts_info.phc_index;
+			p->phc_index = interface_phc_index(interface);
 		} else if (phc_device) {
 			pr_warning("port %d: taking %s from the command line, "
 				   "not the attached ptp%d", number, phc_device,
-				   interface->ts_info.phc_index);
+				   interface_phc_index(interface));
 			p->phc_index = phc_index;
 		} else {
 			pr_err("port %d: PHC device mismatch", number);
 			pr_err("port %d: /dev/ptp%d requested, ptp%d attached",
-			       number, phc_index, interface->ts_info.phc_index);
+			       number, phc_index,
+			       interface_phc_index(interface));
 			goto err_port;
 		}
 	}
-- 
2.17.1


From 3d388e19923ab12902457b37f5862d89670bad60 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 15:48:51 -0800
Subject: [PATCH 094/173] interface: Introduce a method to test the time
 stamping information validity.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 5 +++++
 interface.h | 8 ++++++++
 2 files changed, 13 insertions(+)

diff --git a/interface.c b/interface.c
index 02f63a0..7a3eddc 100644
--- a/interface.c
+++ b/interface.c
@@ -42,3 +42,8 @@ void interface_set_name(struct interface *iface, const char *name)
 {
 	strncpy(iface->name, name, MAX_IFNAME_SIZE);
 }
+
+bool interface_tsinfo_valid(struct interface *iface)
+{
+	return iface->ts_info.valid ? true : false;
+}
diff --git a/interface.h b/interface.h
index 4f408d5..3526a48 100644
--- a/interface.h
+++ b/interface.h
@@ -7,6 +7,7 @@
 #ifndef HAVE_INTERFACE_H
 #define HAVE_INTERFACE_H
 
+#include <stdbool.h>
 #include <sys/queue.h>
 #include "sk.h"
 
@@ -74,4 +75,11 @@ void interface_set_label(struct interface *iface, const char *label);
  */
 void interface_set_name(struct interface *iface, const char *name);
 
+/**
+ * Tests whether an interface's time stamping information is valid or not.
+ * @param iface  The interface of interest.
+ * @return       True if the time stamping information is valid, false otherwise.
+ */
+bool interface_tsinfo_valid(struct interface *iface);
+
 #endif
-- 
2.17.1


From 605abc45dd63dc0dbf37fd6096267d1e8bdc144c Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 15:50:03 -0800
Subject: [PATCH 095/173] Convert call sites to the proper method for testing
 time stamp info validity.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c | 4 ++--
 port.c  | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/clock.c b/clock.c
index 71b3899..845e27a 100644
--- a/clock.c
+++ b/clock.c
@@ -956,7 +956,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		interface_set_label(iface, ts_label);
 		interface_ensure_tslabel(iface);
 		interface_get_tsinfo(iface);
-		if (iface->ts_info.valid &&
+		if (interface_tsinfo_valid(iface) &&
 		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
 			pr_err("interface '%s' does not support requested timestamping mode",
 			       interface_name(iface));
@@ -975,7 +975,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		if (1 != sscanf(phc_device, "/dev/ptp%d", &phc_index)) {
 			phc_index = -1;
 		}
-	} else if (iface->ts_info.valid) {
+	} else if (interface_tsinfo_valid(iface)) {
 		phc_index = interface_phc_index(iface);
 	} else {
 		pr_err("PTP device not specified and automatic determination"
diff --git a/port.c b/port.c
index f4834ba..b590024 100644
--- a/port.c
+++ b/port.c
@@ -2511,7 +2511,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 		interface_get_tsinfo(p->iface);
 
 		/* Only switch phc with HW time stamping mode */
-		if (p->iface->ts_info.valid &&
+		if (interface_tsinfo_valid(p->iface) &&
 		    interface_phc_index(p->iface) >= 0) {
 			required_modes = clock_required_modes(p->clock);
 			if ((p->iface->ts_info.so_timestamping & required_modes) != required_modes) {
@@ -3001,7 +3001,7 @@ struct port *port_open(const char *phc_device,
 
 	if (transport == TRANS_UDS) {
 		; /* UDS cannot have a PHC. */
-	} else if (!interface->ts_info.valid) {
+	} else if (!interface_tsinfo_valid(interface)) {
 		pr_warning("port %d: get_ts_info not supported", number);
 	} else if (phc_index >= 0 &&
 		   phc_index != interface_phc_index(interface)) {
-- 
2.17.1


From 720c9fa08dce20bd9ea59e9d32f42e6443d8755a Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 16:06:21 -0800
Subject: [PATCH 096/173] interface: Introduce a method to test supported time
 stamping modes.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 interface.c | 8 ++++++++
 interface.h | 8 ++++++++
 2 files changed, 16 insertions(+)

diff --git a/interface.c b/interface.c
index 7a3eddc..74a2512 100644
--- a/interface.c
+++ b/interface.c
@@ -47,3 +47,11 @@ bool interface_tsinfo_valid(struct interface *iface)
 {
 	return iface->ts_info.valid ? true : false;
 }
+
+bool interface_tsmodes_supported(struct interface *iface, int modes)
+{
+	if ((iface->ts_info.so_timestamping & modes) == modes) {
+		return true;
+	}
+	return false;
+}
diff --git a/interface.h b/interface.h
index 3526a48..32eec7b 100644
--- a/interface.h
+++ b/interface.h
@@ -82,4 +82,12 @@ void interface_set_name(struct interface *iface, const char *name);
  */
 bool interface_tsinfo_valid(struct interface *iface);
 
+/**
+ * Tests whether an interface supports a set of given time stamping modes.
+ * @param iface  The interface of interest.
+ * @param modes  Bit mask of SOF_TIMESTAMPING_ flags.
+ * @return       True if the time stamping modes are supported, false otherwise.
+ */
+bool interface_tsmodes_supported(struct interface *iface, int modes);
+
 #endif
-- 
2.17.1


From 21141a44e6687507b2f370c2b8647811055be75c Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 9 Feb 2020 16:07:20 -0800
Subject: [PATCH 097/173] Convert call sites to the proper method for testing
 time stamping modes.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c | 2 +-
 port.c  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/clock.c b/clock.c
index 845e27a..71b5795 100644
--- a/clock.c
+++ b/clock.c
@@ -957,7 +957,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		interface_ensure_tslabel(iface);
 		interface_get_tsinfo(iface);
 		if (interface_tsinfo_valid(iface) &&
-		    ((iface->ts_info.so_timestamping & required_modes) != required_modes)) {
+		    !interface_tsmodes_supported(iface, required_modes)) {
 			pr_err("interface '%s' does not support requested timestamping mode",
 			       interface_name(iface));
 			return NULL;
diff --git a/port.c b/port.c
index b590024..6b87bc9 100644
--- a/port.c
+++ b/port.c
@@ -2514,7 +2514,7 @@ void port_link_status(void *ctx, int linkup, int ts_index)
 		if (interface_tsinfo_valid(p->iface) &&
 		    interface_phc_index(p->iface) >= 0) {
 			required_modes = clock_required_modes(p->clock);
-			if ((p->iface->ts_info.so_timestamping & required_modes) != required_modes) {
+			if (!interface_tsmodes_supported(p->iface, required_modes)) {
 				pr_err("interface '%s' does not support requested "
 				       "timestamping mode, set link status down by force.",
 				       interface_label(p->iface));
-- 
2.17.1


From 5316a36422302cacb79e81830843127db4f7e443 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 20:55:38 -0800
Subject: [PATCH 098/173] interface: Introduce methods to create and destroy
 instances.

In order to eventually hide the implementation details of the interface,
users will need to be able to create and destroy instances thereof.  This
patch adds the needed methods.

Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 interface.c | 19 +++++++++++++++++++
 interface.h | 13 +++++++++++++
 2 files changed, 32 insertions(+)

diff --git a/interface.c b/interface.c
index 74a2512..63ed7e4 100644
--- a/interface.c
+++ b/interface.c
@@ -4,8 +4,27 @@
  * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
  * @note SPDX-License-Identifier: GPL-2.0+
  */
+#include <stdlib.h>
 #include "interface.h"
 
+struct interface *interface_create(const char *name)
+{
+	struct interface *iface;
+
+	iface = calloc(1, sizeof(struct interface));
+	if (!iface) {
+		return NULL;
+	}
+	interface_set_name(iface, name);
+
+	return iface;
+}
+
+void interface_destroy(struct interface *iface)
+{
+	free(iface);
+}
+
 void interface_ensure_tslabel(struct interface *iface)
 {
 	if (!iface->ts_label[0]) {
diff --git a/interface.h b/interface.h
index 32eec7b..b61f4d6 100644
--- a/interface.h
+++ b/interface.h
@@ -25,6 +25,19 @@ struct interface {
 	struct sk_ts_info ts_info;
 };
 
+/**
+ * Creates an instance of an interface.
+ * @param name  The device which indentifies this interface.
+ * @return      A pointer to an interface instance on success, NULL otherwise.
+ */
+struct interface *interface_create(const char *name);
+
+/**
+ * Destroys an instance of an interface.
+ * @param iface  A pointer obtained via interface_create().
+ */
+void interface_destroy(struct interface *iface);
+
 /**
  * Ensures that an interface has a proper time stamping label.
  * @param iface  The interface of interest.
-- 
2.17.1


From 52482e09694cca8c7f599a75aa6012c28fb66342 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 20:57:09 -0800
Subject: [PATCH 099/173] clock: Use the proper create/destroy API for network
 interfaces.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c | 17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

diff --git a/clock.c b/clock.c
index 71b5795..e5f104e 100644
--- a/clock.c
+++ b/clock.c
@@ -122,7 +122,7 @@ struct clock {
 	struct clock_stats stats;
 	int stats_interval;
 	struct clockcheck *sanity_check;
-	struct interface uds_interface;
+	struct interface *udsif;
 	LIST_HEAD(clock_subscribers_head, clock_subscriber) subscribers;
 };
 
@@ -259,6 +259,7 @@ void clock_destroy(struct clock *c)
 {
 	struct port *p, *tmp;
 
+	interface_destroy(c->udsif);
 	clock_flush_subscriptions(c);
 	LIST_FOREACH_SAFE(p, &c->ports, list, tmp) {
 		clock_remove_port(c, p);
@@ -854,7 +855,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	const char *uds_ifname;
 	struct port *p;
 	unsigned char oui[OUI_LEN];
-	struct interface *iface, *udsif = &c->uds_interface;
+	struct interface *iface;
 	struct timespec ts;
 	int sfl;
 
@@ -1003,20 +1004,20 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 
 	/* Configure the UDS. */
 	uds_ifname = config_get_string(config, NULL, "uds_address");
-	interface_set_name(udsif, uds_ifname);
-	if (config_set_section_int(config, interface_name(udsif),
+	c->udsif = interface_create(uds_ifname);
+	if (config_set_section_int(config, interface_name(c->udsif),
 				   "announceReceiptTimeout", 0)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, interface_name(udsif),
+	if (config_set_section_int(config, interface_name(c->udsif),
 				    "delay_mechanism", DM_AUTO)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, interface_name(udsif),
+	if (config_set_section_int(config, interface_name(c->udsif),
 				    "network_transport", TRANS_UDS)) {
 		return NULL;
 	}
-	if (config_set_section_int(config, interface_name(udsif),
+	if (config_set_section_int(config, interface_name(c->udsif),
 				   "delay_filter_length", 1)) {
 		return NULL;
 	}
@@ -1131,7 +1132,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	}
 
 	/* Create the UDS interface. */
-	c->uds_port = port_open(phc_device, phc_index, timestamping, 0, udsif, c);
+	c->uds_port = port_open(phc_device, phc_index, timestamping, 0, c->udsif, c);
 	if (!c->uds_port) {
 		pr_err("failed to open the UDS port");
 		return NULL;
-- 
2.17.1


From 812e0df4b822e057de466bd4b4322c422e6e485d Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 20:57:41 -0800
Subject: [PATCH 100/173] config: Use the proper create/destroy API for network
 interfaces.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 config.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/config.c b/config.c
index 717ee65..e033842 100644
--- a/config.c
+++ b/config.c
@@ -829,13 +829,11 @@ struct interface *config_create_interface(const char *name, struct config *cfg)
 			return iface;
 	}
 
-	iface = calloc(1, sizeof(struct interface));
+	iface = interface_create(name);
 	if (!iface) {
 		fprintf(stderr, "cannot allocate memory for a port\n");
 		return NULL;
 	}
-
-	interface_set_name(iface, name);
 	STAILQ_INSERT_TAIL(&cfg->interfaces, iface, list);
 	cfg->n_interfaces++;
 
@@ -906,7 +904,7 @@ void config_destroy(struct config *cfg)
 
 	while ((iface = STAILQ_FIRST(&cfg->interfaces))) {
 		STAILQ_REMOVE_HEAD(&cfg->interfaces, list);
-		free(iface);
+		interface_destroy(iface);
 	}
 	while ((table = STAILQ_FIRST(&cfg->unicast_master_tables))) {
 		while ((address = STAILQ_FIRST(&table->addrs))) {
-- 
2.17.1


From 66dc3167e3ad9dfba244f201110737603d502a06 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 20:59:21 -0800
Subject: [PATCH 101/173] pmc: Use the proper create/destroy API for network
 interfaces.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 pmc_common.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/pmc_common.c b/pmc_common.c
index 41181fb..3aab4b9 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -313,6 +313,7 @@ struct pmc {
 	struct PortIdentity target;
 
 	struct transport *transport;
+	struct interface *iface;
 	struct fdarray fdarray;
 	int zero_length_gets;
 };
@@ -322,11 +323,8 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 		       UInteger8 domain_number, UInteger8 transport_specific,
 		       int zero_datalen)
 {
-	struct interface iface;
 	struct pmc *pmc;
 
-	memset(&iface, 0, sizeof(iface));
-
 	pmc = calloc(1, sizeof *pmc);
 	if (!pmc)
 		return NULL;
@@ -350,18 +348,24 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 		goto failed;
 	}
 
-	interface_set_name(&iface, iface_name);
-	interface_ensure_tslabel(&iface);
+	pmc->iface = interface_create(iface_name);
+	if (!pmc->iface) {
+		pr_err("failed to create interface");
+		goto failed;
+	}
+	interface_ensure_tslabel(pmc->iface);
 
-	if (transport_open(pmc->transport, &iface,
+	if (transport_open(pmc->transport, pmc->iface,
 			   &pmc->fdarray, TS_SOFTWARE)) {
 		pr_err("failed to open transport");
-		goto failed;
+		goto no_trans_open;
 	}
 	pmc->zero_length_gets = zero_datalen ? 1 : 0;
 
 	return pmc;
 
+no_trans_open:
+	interface_destroy(pmc->iface);
 failed:
 	if (pmc->transport)
 		transport_destroy(pmc->transport);
@@ -372,6 +376,7 @@ failed:
 void pmc_destroy(struct pmc *pmc)
 {
 	transport_close(pmc->transport, &pmc->fdarray);
+	interface_destroy(pmc->iface);
 	transport_destroy(pmc->transport);
 	free(pmc);
 }
-- 
2.17.1


From a8f742528efe011790841e70f833f72619e4a352 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 21:05:42 -0800
Subject: [PATCH 102/173] interface: Hide the implementation details.

Now that a complete functional API is in place, there is no need to expose
the inner workings of the network interface data type.  This patch converts
it into an opaque type while leaving the list marker visible to users
through a simple form of "friendly exposition".

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c     | 4 ++++
 config.c    | 4 ++++
 interface.c | 7 +++++++
 interface.h | 9 ++-------
 nsm.c       | 4 ++++
 5 files changed, 21 insertions(+), 7 deletions(-)

diff --git a/clock.c b/clock.c
index e5f104e..1668383 100644
--- a/clock.c
+++ b/clock.c
@@ -47,6 +47,10 @@
 #define N_CLOCK_PFD (N_POLLFD + 1) /* one extra per port, for the fault timer */
 #define POW2_41 ((double)(1ULL << 41))
 
+struct interface {
+	STAILQ_ENTRY(interface) list;
+};
+
 struct port {
 	LIST_ENTRY(port) list;
 };
diff --git a/config.c b/config.c
index e033842..f20c5f7 100644
--- a/config.c
+++ b/config.c
@@ -32,6 +32,10 @@
 #include "print.h"
 #include "util.h"
 
+struct interface {
+	STAILQ_ENTRY(interface) list;
+};
+
 enum config_section {
 	GLOBAL_SECTION,
 	UC_MTAB_SECTION,
diff --git a/interface.c b/interface.c
index 63ed7e4..7cd5b41 100644
--- a/interface.c
+++ b/interface.c
@@ -7,6 +7,13 @@
 #include <stdlib.h>
 #include "interface.h"
 
+struct interface {
+	STAILQ_ENTRY(interface) list;
+	char name[MAX_IFNAME_SIZE + 1];
+	char ts_label[MAX_IFNAME_SIZE + 1];
+	struct sk_ts_info ts_info;
+};
+
 struct interface *interface_create(const char *name)
 {
 	struct interface *iface;
diff --git a/interface.h b/interface.h
index b61f4d6..6cc50ac 100644
--- a/interface.h
+++ b/interface.h
@@ -17,13 +17,8 @@
 #error if_namesize larger than expected.
 #endif
 
-/** Defines a network interface, with PTP options. */
-struct interface {
-	STAILQ_ENTRY(interface) list;
-	char name[MAX_IFNAME_SIZE + 1];
-	char ts_label[MAX_IFNAME_SIZE + 1];
-	struct sk_ts_info ts_info;
-};
+/** Opaque type */
+struct interface;
 
 /**
  * Creates an instance of an interface.
diff --git a/nsm.c b/nsm.c
index 1292c6b..5aa925b 100644
--- a/nsm.c
+++ b/nsm.c
@@ -35,6 +35,10 @@
 #define IFMT		"\n\t\t"
 #define NSM_NFD		3
 
+struct interface {
+	STAILQ_ENTRY(interface) list;
+};
+
 struct nsm {
 	struct config		*cfg;
 	struct fdarray		fda;
-- 
2.17.1


From b878dd99fab24112bfbfb1383d6e7abbb116e529 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 21:06:48 -0800
Subject: [PATCH 103/173] interface: Silence warning from gcc version 8.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

When compiling with gcc8 and -O2, the clever compiler complains:

   interface.c: In function ‘interface_ensure_tslabel’:
   interface.c:38:3: error: ‘strncpy’ output may be truncated copying 108 bytes from a string of length 108 [-Werror=stringop-truncation]

Even though this is a false positive, this patch silences the warning
by using memcpy instead of strncpy.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 interface.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/interface.c b/interface.c
index 7cd5b41..2cf3b1e 100644
--- a/interface.c
+++ b/interface.c
@@ -35,7 +35,7 @@ void interface_destroy(struct interface *iface)
 void interface_ensure_tslabel(struct interface *iface)
 {
 	if (!iface->ts_label[0]) {
-		strncpy(iface->ts_label, iface->name, MAX_IFNAME_SIZE);
+		memcpy(iface->ts_label, iface->name, MAX_IFNAME_SIZE);
 	}
 }
 
-- 
2.17.1


From 0a4d85c2ed9baa948673bdf6aeb32fda934ebe44 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 10 Feb 2020 21:15:42 -0800
Subject: [PATCH 104/173] interface: Remove obsolete method.

Now that all call sites have been converted to interface_create(), there
is no longer any needed for a way to set the interface's name.  This patch
removes the useless method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 interface.c | 7 +------
 interface.h | 7 -------
 2 files changed, 1 insertion(+), 13 deletions(-)

diff --git a/interface.c b/interface.c
index 2cf3b1e..65bdff0 100644
--- a/interface.c
+++ b/interface.c
@@ -22,7 +22,7 @@ struct interface *interface_create(const char *name)
 	if (!iface) {
 		return NULL;
 	}
-	interface_set_name(iface, name);
+	strncpy(iface->name, name, MAX_IFNAME_SIZE);
 
 	return iface;
 }
@@ -64,11 +64,6 @@ void interface_set_label(struct interface *iface, const char *label)
 	strncpy(iface->ts_label, label, MAX_IFNAME_SIZE);
 }
 
-void interface_set_name(struct interface *iface, const char *name)
-{
-	strncpy(iface->name, name, MAX_IFNAME_SIZE);
-}
-
 bool interface_tsinfo_valid(struct interface *iface)
 {
 	return iface->ts_info.valid ? true : false;
diff --git a/interface.h b/interface.h
index 6cc50ac..8bf2727 100644
--- a/interface.h
+++ b/interface.h
@@ -76,13 +76,6 @@ int interface_phc_index(struct interface *iface);
  */
 void interface_set_label(struct interface *iface, const char *label);
 
-/**
- * Set the name of a given interface.
- * @param iface  The interface of interest.
- * @param name   The desired name for the interface.
- */
-void interface_set_name(struct interface *iface, const char *name);
-
 /**
  * Tests whether an interface's time stamping information is valid or not.
  * @param iface  The interface of interest.
-- 
2.17.1


From 944f5f7ac6eb1b638d5bc6c61b09cd39d8dbd669 Mon Sep 17 00:00:00 2001
From: Ville Heikkinen <ville.heikkinen@nokia.com>
Date: Fri, 14 Feb 2020 13:23:44 +0200
Subject: [PATCH 105/173] phc2sys: Notify kernel if clock is not in sync

In case there is no connection to the server, notify the kernel
that the clock is currently unsynchronized.

Signed-off-by: Ville Heikkinen <ville.heikkinen@nokia.com>
---
 clockadj.c | 11 +++++++++++
 clockadj.h |  5 +++++
 phc2sys.c  |  4 +++-
 3 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/clockadj.c b/clockadj.c
index 0485d8c..7b8feef 100644
--- a/clockadj.c
+++ b/clockadj.c
@@ -182,3 +182,14 @@ void sysclk_set_sync(void)
 	if (clock_adjtime(clkid, &tx) < 0)
 		pr_err("failed to set clock status and maximum error: %m");
 }
+
+void sysclk_set_unsync(void)
+{
+	clockid_t clkid = CLOCK_REALTIME;
+	struct timex tx;
+	memset(&tx, 0, sizeof(tx));
+	tx.modes = ADJ_STATUS;
+	tx.status = STA_UNSYNC;
+	if (clock_adjtime(clkid, &tx) < 0)
+		pr_err("failed to set clock status: %m");
+}
diff --git a/clockadj.h b/clockadj.h
index 4ea98c1..8a98627 100644
--- a/clockadj.h
+++ b/clockadj.h
@@ -80,4 +80,9 @@ int sysclk_max_freq(void);
  * the real-time clock (RTC) to it.
  */
 void sysclk_set_sync(void);
+
+/**
+ * Mark the system clock as unsynchronized.
+ */
+void sysclk_set_unsync(void);
 #endif
diff --git a/phc2sys.c b/phc2sys.c
index c0b7b3d..80d0b8e 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -735,8 +735,10 @@ static int do_loop(struct node *node, int subscriptions)
 				reconfigure(node);
 			}
 		}
-		if (!node->master)
+		if (!node->master) {
+			sysclk_set_unsync();
 			continue;
+		}
 
 		LIST_FOREACH(clock, &node->dst_clocks, dst_list) {
 			if (!update_needed(clock))
-- 
2.17.1


From 25d4e4fbddd4d6a83bd50b212acd5db5a6f64e5b Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Fri, 6 Mar 2020 10:13:50 -0800
Subject: [PATCH 106/173] Revert "phc2sys: Notify kernel if clock is not in
 sync"

This novel use of the STA_UNSYNC flag breaks with the established,
traditional meaning of that flag, which is:

   The clock has is believed to have an error larger than 16 seconds.

This reverts commit 944f5f7ac6eb1b638d5bc6c61b09cd39d8dbd669.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clockadj.c | 11 -----------
 clockadj.h |  5 -----
 phc2sys.c  |  4 +---
 3 files changed, 1 insertion(+), 19 deletions(-)

diff --git a/clockadj.c b/clockadj.c
index 7b8feef..0485d8c 100644
--- a/clockadj.c
+++ b/clockadj.c
@@ -182,14 +182,3 @@ void sysclk_set_sync(void)
 	if (clock_adjtime(clkid, &tx) < 0)
 		pr_err("failed to set clock status and maximum error: %m");
 }
-
-void sysclk_set_unsync(void)
-{
-	clockid_t clkid = CLOCK_REALTIME;
-	struct timex tx;
-	memset(&tx, 0, sizeof(tx));
-	tx.modes = ADJ_STATUS;
-	tx.status = STA_UNSYNC;
-	if (clock_adjtime(clkid, &tx) < 0)
-		pr_err("failed to set clock status: %m");
-}
diff --git a/clockadj.h b/clockadj.h
index 8a98627..4ea98c1 100644
--- a/clockadj.h
+++ b/clockadj.h
@@ -80,9 +80,4 @@ int sysclk_max_freq(void);
  * the real-time clock (RTC) to it.
  */
 void sysclk_set_sync(void);
-
-/**
- * Mark the system clock as unsynchronized.
- */
-void sysclk_set_unsync(void);
 #endif
diff --git a/phc2sys.c b/phc2sys.c
index 80d0b8e..c0b7b3d 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -735,10 +735,8 @@ static int do_loop(struct node *node, int subscriptions)
 				reconfigure(node);
 			}
 		}
-		if (!node->master) {
-			sysclk_set_unsync();
+		if (!node->master)
 			continue;
-		}
 
 		LIST_FOREACH(clock, &node->dst_clocks, dst_list) {
 			if (!update_needed(clock))
-- 
2.17.1


From 45aa981e4a72f9ce9b1d1af8ede6f4c69ab184a8 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Fri, 6 Mar 2020 11:01:31 -0800
Subject: [PATCH 107/173] clock: Safely remove event subscribers from list.

When updating and potentially removing event subscribers, the code uses
the simple list traversal macro.  As a result, the list will become
corrupted whenever a subscriber is removed.  This patch fixes the issue
by using the appropriate macro.

Fixes: 5104e3e56b59 ("Event subscribing")
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reported-by: Michael Walle <michael@walle.cc>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 clock.c | 9 ++++-----
 1 file changed, 4 insertions(+), 5 deletions(-)

diff --git a/clock.c b/clock.c
index 1668383..6f9cc21 100644
--- a/clock.c
+++ b/clock.c
@@ -145,9 +145,9 @@ static void remove_subscriber(struct clock_subscriber *s)
 static void clock_update_subscription(struct clock *c, struct ptp_message *req,
 				      uint8_t *bitmask, uint16_t duration)
 {
-	struct clock_subscriber *s;
-	int i, remove = 1;
+	struct clock_subscriber *s, *tmp;
 	struct timespec now;
+	int i, remove = 1;
 
 	for (i = 0; i < EVENT_BITMASK_CNT; i++) {
 		if (bitmask[i]) {
@@ -156,12 +156,11 @@ static void clock_update_subscription(struct clock *c, struct ptp_message *req,
 		}
 	}
 
-	LIST_FOREACH(s, &c->subscribers, list) {
+	LIST_FOREACH_SAFE(s, &c->subscribers, list, tmp) {
 		if (pid_eq(&s->targetPortIdentity,
 			   &req->header.sourcePortIdentity)) {
-			/* Found, update the transport address and event
-			 * mask. */
 			if (!remove) {
+				/* Update transport address and event mask. */
 				s->addr = req->address;
 				memcpy(s->events, bitmask, EVENT_BITMASK_CNT);
 				clock_gettime(CLOCK_MONOTONIC, &now);
-- 
2.17.1


From 01db4c884998246e6599d78004cd7cf06161c30e Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 29 Dec 2019 11:20:10 -0800
Subject: [PATCH 108/173] Remove the unfinished SNMP code.

Unfortunately the SNMP code still has issues like not passing the
valgrind test, and no one is able to finish this up right now.  This
patch removes the SNMP program so that the upcoming release does not
contain unfinished work, potentially misleading end users about the
scope and completeness of the features.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 makefile        |  14 ----
 snmp4lptp.8     | 119 ------------------------------
 snmp4lptp.c     | 192 ------------------------------------------------
 snmp4lptp_mib.h |  30 --------
 snmpflg.sh      |  42 -----------
 5 files changed, 397 deletions(-)
 delete mode 100644 snmp4lptp.8
 delete mode 100644 snmp4lptp.c
 delete mode 100644 snmp4lptp_mib.h
 delete mode 100755 snmpflg.sh

diff --git a/makefile b/makefile
index e1dd3fa..a23945a 100644
--- a/makefile
+++ b/makefile
@@ -38,16 +38,9 @@ SRC	= $(OBJECTS:.o=.c)
 DEPEND	= $(OBJECTS:.o=.d)
 srcdir	:= $(dir $(lastword $(MAKEFILE_LIST)))
 incdefs := $(shell $(srcdir)/incdefs.sh)
-snmpflg	:= $(shell $(srcdir)/snmpflg.sh)
 version := $(shell $(srcdir)/version.sh $(srcdir))
 VPATH	= $(srcdir)
 
-ifneq (,$(findstring -DHAVE_NET_SNMP,$(snmpflg)))
-PRG	+= snmp4lptp
-OBJECTS	+= snmp4lptp.o
-snmplib	:= $(shell net-snmp-config --netsnmp-agent-libs)
-endif
-
 prefix	= /usr/local
 sbindir	= $(prefix)/sbin
 mandir	= $(prefix)/man
@@ -71,13 +64,6 @@ hwstamp_ctl: hwstamp_ctl.o version.o
 
 phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
-snmp4lptp: config.o hash.o interface.o msg.o phc.o pmc_common.o print.o sk.o \
- snmp4lptp.o tlv.o $(TRANSP) util.o
-	$(CC) $^ $(LDFLAGS) $(LOADLIBES) $(LDLIBS) $(snmplib) -o $@
-
-snmp4lptp.o: snmp4lptp.c
-	$(CC) $(CPPFLAGS) $(CFLAGS) $(snmpflg) -c $<
-
 timemaster: phc.o print.o rtnl.o sk.o timemaster.o util.o version.o
 
 version.o: .version version.sh $(filter-out version.d,$(DEPEND))
diff --git a/snmp4lptp.8 b/snmp4lptp.8
deleted file mode 100644
index 7dda4d0..0000000
--- a/snmp4lptp.8
+++ /dev/null
@@ -1,119 +0,0 @@
-.TH SNMP4LPTP 8 "September 2018" "linuxptp"
-.SH NAME
-snmp4lptp - SNMP sub agent
-
-.SH SYNOPSIS
-.B snmp4lptp
-[
-.BI \-f " config-file"
-] [
-.B \-m
-] [
-.B \-q
-] [
-.I long-options
-]
-
-.SH DESCRIPTION
-.B snmp4lptp
-is an implementation of a sub agent for handling SNMP requests on
-the device running ptp4l. Via the UDS port, the sub agent retrieves
-management information from ptp4l and translates the information to
-or from an SNMP-specific form. 
-
-.SH OPTIONS
-.TP
-.BI \-f " file"
-Specify the path to the \fBsnmp4lptp\fR configuration file.
-.TP
-.B \-h
-Display a help message.
-.TP
-.B \-m
-Print messages to the standard output.
-.TP
-.B \-q
-Don't send messages to the system logger.
-
-.SH LONG OPTIONS
-
-Each and every configuration file option (see below in sections
-.BR PROGRAM\ OPTIONS
-and
-.BR PORT\ OPTIONS )
-may also appear
-as a "long" style command line argument. For example, the transportSpecific
-option may be set using either of these two forms:
-
-.RS
-\f(CW\-\-transportSpecific 1   \-\-transportSpecific=1\fP
-.RE
-
-Option values given on the command line override values in the global
-section of the configuration file (which, in turn, overrides default
-values).
-
-.SH CONFIGURATION FILE
-
-The configuration file is divided into sections. Each section starts with a
-line containing its name enclosed in brackets and it follows with settings.
-Each setting is placed on a separate line, it contains the name of the
-option and the value separated by whitespace characters. Empty lines and lines
-starting with # are ignored.
-
-The global section (indicated as
-.BR [global] )
-sets the global program options as well as the default port specific options.
-Other sections are port specific sections and they override the default port
-options. The name of the section is the name of the configured port (e.g.
-.BR [eth0]
-). Currently no port specific options other than default are considered.
-
-.SH PROGRAM OPTIONS
-.TP
-.B domainNumber
-The domain attribute of the local clock.
-The default is 0.
-.TP
-.B logging_level
-The maximum logging level of messages which should be printed.
-The default is 6 (LOG_INFO).
-.TP
-.B message_tag
-The tag which is added to all messages printed to the standard output or system
-log.
-The default is an empty string (which cannot be set in the configuration file
-as the option requires an argument).
-.TP
-.B use_syslog
-Print messages to the system log if enabled.
-The default is 1 (enabled).
-.TP
-.B verbose
-Print messages to the standard output if enabled.
-The default is 0 (disabled).
-.TP
-.B uds_address
-Specifies the address of the server's UNIX domain socket.
-The default is /var/run/ptp4l.
-
-.SH PORT OPTIONS
-.TP
-.B transportSpecific
-The transport specific field. Must be in the range 0 to 255.
-The default is 0.
-
-.SH WARNING
-
-Be cautious when the same configuration file is used for both ptp4l
-and snmp4lptp. Keep in mind that values specified in the configuration
-file take precedence over their default values. If a certain option which
-is common to ptp4l and snmp4lptp is specified to a non-default value in
-the configuration file (e.g. for ptp4l), then this non-default value
-applies also for snmp4lptp. This might be not what is expected.
-
-To avoid securely these unexpected behaviour, different configuration files
-for ptp4l and snmp4lptp are recommended.
-
-.SH SEE ALSO
-.BR ptp4l (8)
diff --git a/snmp4lptp.c b/snmp4lptp.c
deleted file mode 100644
index e06f212..0000000
--- a/snmp4lptp.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/**
- * @file snmp4lptp.c
- * @brief Implements SNMP sub agent program for linuxptp
- * @note Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-#include <errno.h>
-#include <poll.h>
-
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-#include <net-snmp/agent/net-snmp-agent-includes.h>
-
-#include "config.h"
-#include "pmc_common.h"
-#include "print.h"
-#include "snmp4lptp_mib.h"
-#include "util.h"
-
-#define SNMP_NFD 1
-static struct pmc *pmc;
-
-struct ptp_message* snmp4lptp_run_pmc(char *cmd)
-{
-	struct pollfd pollfd[SNMP_NFD];
-	int cnt, tmo = 100;
-
-	pollfd[0].fd = pmc_get_transport_fd(pmc);
-	pollfd[0].events = POLLIN | POLLPRI;
-
-	if (cmd && pmc_do_command(pmc, cmd)) {
-		pr_err("bad command: %s", cmd);
-	}
-
-	while (is_running()) {
-		cnt = poll(pollfd, SNMP_NFD, tmo);
-		if (cnt < 0) {
-			if (EINTR == errno) {
-				continue;
-			} else {
-				pr_emerg("poll failed");
-				break;
-			}
-		} else if (!cnt) {
-			break;
-		}
-
-		if (pollfd[0].revents & (POLLIN|POLLPRI)) {
-			return pmc_recv(pmc);
-		}
-	}
-	return NULL;
-}
-
-static int open_pmc(struct config *cfg)
-{
-	char uds_local[MAX_IFNAME_SIZE + 1];
-	snprintf(uds_local, sizeof(uds_local), "/var/run/snmp4lptp.%d", getpid());
-
-	pmc = pmc_create(cfg, TRANS_UDS, uds_local, 0,
-			 config_get_int(cfg, NULL, "domainNumber"),
-			 config_get_int(cfg, NULL, "transportSpecific") << 4,
-			 1);
-
-	return pmc ? 0 : -1;
-}
-
-static int open_snmp()
-{
-	snmp_enable_calllog();
-	netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID,
-			       NETSNMP_DS_AGENT_ROLE, 1);
-	init_agent("linuxptpAgent");
-
-	init_snmp("linuxptpAgent");
-
-	return 0;
-}
-
-static void usage(char *progname)
-{
-	fprintf(stderr,
-		"\nusage: %s [options]\n\n"
-		" -f [file] read configuration from 'file'\n"
-		" -h        prints this message and exits\n"
-		" -m        print messages to stdout\n"
-		" -q        do not print messages to the syslog\n"
-		"\n",
-		progname);
-}
-
-int main(int argc, char *argv[])
-{
-	char *config = NULL, *progname;
-	int c, err = 0, index;
-	struct option *opts;
-	struct config *cfg;
-
-	if (handle_term_signals()) {
-		return -1;
-	}
-
-	cfg = config_create();
-	if (!cfg) {
-		return -1;
-	}
-
-	opts = config_long_options(cfg);
-	print_set_verbose(1);
-	print_set_syslog(0);
-
-	/* Process the command line arguments. */
-	progname = strrchr(argv[0], '/');
-	progname = progname ? 1+progname : argv[0];
-	while (EOF != (c = getopt_long(argc, argv, "f:hmq", opts, &index))) {
-		switch (c) {
-		case 0:
-			if (config_parse_option(cfg, opts[index].name, optarg)) {
-				config_destroy(cfg);
-				return -1;
-			}
-			break;
-		case 'f':
-			config = optarg;
-			break;
-		case 'h':
-			usage(progname);
-			err = -1;
-			goto out;
-		case 'm':
-			config_set_int(cfg, "verbose", 1);
-			break;
-		case 'q':
-			config_set_int(cfg, "use_syslog", 0);
-			break;
-		case '?':
-		default:
-			usage(progname);
-			err = -1;
-			goto out;
-		}
-	}
-
-	if (config && (err = config_read(config, cfg))) {
-		err = -1;
-		goto out;
-	}
-
-	print_set_progname(progname);
-	print_set_tag(config_get_string(cfg, NULL, "message_tag"));
-	print_set_verbose(config_get_int(cfg, NULL, "verbose"));
-	print_set_syslog(config_get_int(cfg, NULL, "use_syslog"));
-	print_set_level(config_get_int(cfg, NULL, "logging_level"));
-
-
-	if (open_pmc(cfg)) {
-		err = -1;
-		goto pmc_out;
-	}
-
-	if (open_snmp()) {
-		err = -1;
-		goto snmp_out;
-	}
-
-	while (is_running()) {
-		agent_check_and_process(1);
-	}
-
-	snmp_shutdown("linuxptpAgent");
-
-snmp_out:
-	pmc_destroy(pmc);
-	msg_cleanup();
-pmc_out:
-out:
-	config_destroy(cfg);
-	return err;
-}
diff --git a/snmp4lptp_mib.h b/snmp4lptp_mib.h
deleted file mode 100644
index f135006..0000000
--- a/snmp4lptp_mib.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * @file snmp4lptp_mib.h
- * @brief Common header file for all supported mibs in linuxptp
- * @note Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- */
-#ifndef HAVE_SNMP4LPTP_MIB_H
-#define HAVE_SNMP4LPTP_MIB_H
-
-#include "msg.h"
-
-/*
- * function declarations
- */
-struct ptp_message* snmp4lptp_run_pmc(char *cmd);
-
-#endif /* HAVE_SNMP4LPTP_MIB_H */
diff --git a/snmpflg.sh b/snmpflg.sh
deleted file mode 100755
index 3c58bcb..0000000
--- a/snmpflg.sh
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# Discover the SNMP CFLAGS to use during compilation.
-#
-# Copyright (C) 2018 Anders Selhammer <anders.selhammer@est.tech>
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License along
-# with this program; if not, write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-#
-# Look for libsnmp presence.  When cross compiling, the user will
-# specify the include path in EXTRA_CFLAGS.
-#
-snmp_flags()
-{
-	# Get list of directories searched for header files.
-	dirs=$(echo "" | ${CROSS_COMPILE}cpp ${EXTRA_CFLAGS} -Wp,-v 2>&1 >/dev/null | grep ^" /")
-
-	# Look for libsnmp presence
-	for d in $dirs; do
-		files=$(find $d -type f -name net-snmp-agent-includes.h)
-		for f in $files; do
-			if grep -q NET_SNMP_AGENT_INCLUDES_H $f; then
-				printf " -DHAVE_NET_SNMP `net-snmp-config --cflags`"
-				break 2
-			fi
-		done
-	done
-}
-
-echo "$(snmp_flags)"
-- 
2.17.1


From dde0bf2e2836cda5d31bc03e11561e65ede4715a Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sat, 12 Oct 2019 19:37:59 -0700
Subject: [PATCH 109/173] Balance the posix clock open function with a close
 method.

The one user of the function, posix_clock_open(), simply open codes
the closing call to phc_close().  This patch provides a method to
balance closing and opening of a posix clock.  In addition, the
phc_ctl program never explicitly closed the opened clock, and so this
patch adds the missing call.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 phc2sys.c | 2 +-
 phc_ctl.c | 1 +
 util.c    | 8 ++++++++
 util.h    | 6 ++++++
 4 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/phc2sys.c b/phc2sys.c
index c0b7b3d..64bdf26 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -341,7 +341,7 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 			if (clkid == CLOCK_INVALID)
 				return;
 
-			phc_close(clock->clkid);
+			posix_clock_close(clock->clkid);
 			clock->clkid = clkid;
 			clock->phc_index = phc_index;
 
diff --git a/phc_ctl.c b/phc_ctl.c
index e55af59..149ee9e 100644
--- a/phc_ctl.c
+++ b/phc_ctl.c
@@ -531,6 +531,7 @@ int main(int argc, char *argv[])
 
 	/* pass the remaining arguments to the run_cmds loop */
 	result = run_cmds(clkid, cmdc, cmdv);
+	posix_clock_close(clkid);
 	if (result < -1) {
 		/* show usage when command fails */
 		usage(progname);
diff --git a/util.c b/util.c
index 43d6224..296dd59 100644
--- a/util.c
+++ b/util.c
@@ -190,6 +190,14 @@ char *portaddr2str(struct PortAddress *addr)
 	return buf;
 }
 
+void posix_clock_close(clockid_t clock)
+{
+	if (clock == CLOCK_REALTIME) {
+		return;
+	}
+	phc_close(clock);
+}
+
 clockid_t posix_clock_open(const char *device, int *phc_index)
 {
 	struct sk_ts_info ts_info;
diff --git a/util.h b/util.h
index 11e0935..6e104ea 100644
--- a/util.h
+++ b/util.h
@@ -110,6 +110,12 @@ char *pid2str(struct PortIdentity *id);
 
 char *portaddr2str(struct PortAddress *addr);
 
+/**
+ * Closes a dynamic posix clock.
+ * @param clock  A clock ID obtained via posix_clock_close().
+ */
+void posix_clock_close(clockid_t clock);
+
 /**
  * Opens a dynamic posix clock by name.
  * @param device     The PHC character device or network interface to open.
-- 
2.17.1


From 9850ce0e51c1600005dc7e2829cde7dfb75f6bcf Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 22 Dec 2019 08:31:34 -0800
Subject: [PATCH 110/173] Add definitions for PTP pin ioctls for backwards
 kernel compatibility.

Upcoming functionality will need to configure the input and output pins of
PHC devices.  However, this requires fairly recent kernel support.  This
patch adds the needed definitions for compiling with older kernel headers.

In addition, kernel v5.4 introduced a second set of ioctls for the
ancillary PTP Hardware Clock functionality.  The original ioctls
failed to enforce the various flags and reversed fields, but the
second version has fixed the issues.  Going forward, our user space
PTP stack ought to use the newer ioctls (if available) from day one.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 missing.h | 60 ++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 59 insertions(+), 1 deletion(-)

diff --git a/missing.h b/missing.h
index 8f92079..4726803 100644
--- a/missing.h
+++ b/missing.h
@@ -23,9 +23,10 @@
 #ifndef HAVE_MISSING_H
 #define HAVE_MISSING_H
 
-#include <time.h>
+#include <linux/ptp_clock.h>
 #include <sys/syscall.h>
 #include <sys/timex.h>
+#include <time.h>
 #include <unistd.h>
 
 #ifndef ADJ_TAI
@@ -60,6 +61,63 @@ enum {
 };
 #endif
 
+#ifdef PTP_EXTTS_REQUEST2
+#define PTP_EXTTS_REQUEST_FAILED "PTP_EXTTS_REQUEST2 failed: %m"
+#else
+#define PTP_EXTTS_REQUEST_FAILED "PTP_EXTTS_REQUEST failed: %m"
+#define PTP_EXTTS_REQUEST2 PTP_EXTTS_REQUEST
+#endif
+
+#ifdef PTP_PEROUT_REQUEST2
+#define PTP_PEROUT_REQUEST_FAILED "PTP_PEROUT_REQUEST2 failed: %m"
+#else
+#define PTP_PEROUT_REQUEST_FAILED "PTP_PEROUT_REQUEST failed: %m"
+#define PTP_PEROUT_REQUEST2 PTP_PEROUT_REQUEST
+#endif
+
+#ifndef PTP_PIN_SETFUNC
+
+/* from Linux kernel version 5.4 */
+struct compat_ptp_clock_caps {
+	int max_adj;   /* Maximum frequency adjustment in parts per billon. */
+	int n_alarm;   /* Number of programmable alarms. */
+	int n_ext_ts;  /* Number of external time stamp channels. */
+	int n_per_out; /* Number of programmable periodic signals. */
+	int pps;       /* Whether the clock supports a PPS callback. */
+	int n_pins;    /* Number of input/output pins. */
+	/* Whether the clock supports precise system-device cross timestamps */
+	int cross_timestamping;
+	int rsv[13];   /* Reserved for future use. */
+};
+
+#define ptp_clock_caps compat_ptp_clock_caps
+
+enum ptp_pin_function {
+	PTP_PF_NONE,
+	PTP_PF_EXTTS,
+	PTP_PF_PEROUT,
+	PTP_PF_PHYSYNC,
+};
+
+struct ptp_pin_desc {
+	char name[64];
+	unsigned int index;
+	unsigned int func;
+	unsigned int chan;
+	unsigned int rsv[5];
+};
+
+#define PTP_PIN_SETFUNC    _IOW(PTP_CLK_MAGIC, 7, struct ptp_pin_desc)
+
+#endif /*!PTP_PIN_SETFUNC*/
+
+#ifdef PTP_PIN_SETFUNC2
+#define PTP_PIN_SETFUNC_FAILED "PTP_PIN_SETFUNC2 failed: %m"
+#else
+#define PTP_PIN_SETFUNC_FAILED "PTP_PIN_SETFUNC failed: %m"
+#define PTP_PIN_SETFUNC2 PTP_PIN_SETFUNC
+#endif
+
 #ifndef LIST_FOREACH_SAFE
 #define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
 	for ((var) = LIST_FIRST((head));				\
-- 
2.17.1


From 43d49a21d0e44991bac8d0e4c2b56aa21252efdf Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 22 Dec 2019 10:45:56 -0800
Subject: [PATCH 111/173] Add PHC methods for querying and configuring the pin
 functionality.

In anticipation of support for external time stamping in PHC devices, this
patch adds wrapper functions around the pin functionality.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 phc.c | 23 +++++++++++++++++++++--
 phc.h | 21 +++++++++++++++++++++
 2 files changed, 42 insertions(+), 2 deletions(-)

diff --git a/phc.c b/phc.c
index a90d13e..14132db 100644
--- a/phc.c
+++ b/phc.c
@@ -16,7 +16,9 @@
  * with this program; if not, write to the Free Software Foundation, Inc.,
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
+#include <errno.h>
 #include <fcntl.h>
+#include <linux/ptp_clock.h>
 #include <stdio.h>
 #include <string.h>
 #include <sys/ioctl.h>
@@ -24,8 +26,6 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#include <linux/ptp_clock.h>
-
 #include "phc.h"
 
 /*
@@ -100,6 +100,25 @@ int phc_max_adj(clockid_t clkid)
 	return max;
 }
 
+int phc_number_pins(clockid_t clkid)
+{
+	struct ptp_clock_caps caps;
+
+	if (phc_get_caps(clkid, &caps)) {
+		return 0;
+	}
+	return caps.n_pins;
+}
+
+int phc_pin_setfunc(clockid_t clkid, struct ptp_pin_desc *desc)
+{
+	int err = ioctl(CLOCKID_TO_FD(clkid), PTP_PIN_SETFUNC2, desc);
+	if (err) {
+		fprintf(stderr, PTP_PIN_SETFUNC_FAILED "\n");
+	}
+	return err;
+}
+
 int phc_has_pps(clockid_t clkid)
 {
 	struct ptp_clock_caps caps;
diff --git a/phc.h b/phc.h
index c0c5996..4dbc374 100644
--- a/phc.h
+++ b/phc.h
@@ -46,6 +46,27 @@ void phc_close(clockid_t clkid);
  */
 int phc_max_adj(clockid_t clkid);
 
+/**
+ * Queries the number of programmable pins of a PTP hardware clock device.
+ *
+ * @param clkid A clock ID obtained using phc_open().
+ *
+ * @return The number of pins supported by the clock.
+ */
+int phc_number_pins(clockid_t clkid);
+
+/**
+ * Configures a pin of a PTP hardware clock device.
+ *
+ * @param clkid  A clock ID obtained using phc_open().
+ *
+ * @param desc   Pointer to a pin descriptor with the 'index', 'func',
+ *               and 'chan' fields set.
+ *
+ * @return Zero on success, non-zero otherwise.
+ */
+int phc_pin_setfunc(clockid_t clkid, struct ptp_pin_desc *desc);
+
 /**
  * Checks whether the given PTP hardware clock device supports PPS output.
  *
-- 
2.17.1


From b829580a33366231642c2ce7bed4c61612dbea50 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 16 Jan 2020 21:16:37 -0800
Subject: [PATCH 112/173] Provide a method to convert a tmv_t into a timespec.

Currently there is a method to convert a timespec into a tmv_t, but
not the other way round.  This patch adds the missing function in
anticipation of a new feature that will need this conversion.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 tmv.h | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/tmv.h b/tmv.h
index cca4da7..f4a1a22 100644
--- a/tmv.h
+++ b/tmv.h
@@ -143,6 +143,16 @@ static inline tmv_t timespec_to_tmv(struct timespec ts)
 	return t;
 }
 
+static inline struct timespec tmv_to_timespec(tmv_t t)
+{
+	struct timespec ts;
+
+	ts.tv_sec  = t.ns / NS_PER_SEC;
+	ts.tv_nsec = t.ns % NS_PER_SEC;
+
+	return ts;
+}
+
 static inline tmv_t timestamp_to_tmv(struct timestamp ts)
 {
 	tmv_t t;
-- 
2.17.1


From 467552d1cbc8c7e08c4684e2092f95e874b33218 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 31 Mar 2020 11:53:13 -0700
Subject: [PATCH 113/173] clock: Reply with correct payload length for
 SUBSCRIBE_EVENTS_NP queries.

The clock layer indeed replies to management GET actions for this item,
but it sends an empty management message by mistake.  This patch fixes the
issue by replying with a payload of the correct length.

While we are at it, correct overly zealous line breaking according to our
coding style.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/clock.c b/clock.c
index 6f9cc21..b928f56 100644
--- a/clock.c
+++ b/clock.c
@@ -442,6 +442,7 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 		}
 		sen = (struct subscribe_events_np *)tlv->data;
 		clock_get_subscription(c, req, sen->bitmask, &sen->duration);
+		datalen = sizeof(*sen);
 		break;
 	default:
 		/* The caller should *not* respond to this message. */
@@ -513,8 +514,7 @@ static int clock_management_set(struct clock *c, struct port *p,
 		break;
 	case TLV_SUBSCRIBE_EVENTS_NP:
 		sen = (struct subscribe_events_np *)tlv->data;
-		clock_update_subscription(c, req, sen->bitmask,
-					  sen->duration);
+		clock_update_subscription(c, req, sen->bitmask, sen->duration);
 		respond = 1;
 		break;
 	}
-- 
2.17.1


From aed79c38d45f57fd2d307dcb4a806508124937d0 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 31 Mar 2020 09:41:14 -0700
Subject: [PATCH 114/173] pmc: Move private macros back into their source
 files.

The header file, pmc_common.h, makes some private macros public.  The
intent was to use those macros in SNMP code, but that development never
materialized into production code.  This patch removes the private macros
from public view.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc.c        | 1 +
 pmc_common.c | 5 +++++
 pmc_common.h | 6 ------
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/pmc.c b/pmc.c
index 4e6043b..e3cd6f3 100644
--- a/pmc.c
+++ b/pmc.c
@@ -38,6 +38,7 @@
 static struct pmc *pmc;
 
 #define IFMT "\n\t\t"
+#define P41 ((double)(1ULL << 41))
 
 static char *text2str(struct PTPText *text)
 {
diff --git a/pmc_common.c b/pmc_common.c
index 3aab4b9..92daf20 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -27,6 +27,11 @@
 #include "util.h"
 #include "pmc_common.h"
 
+#define BAD_ACTION   -1
+#define BAD_ID       -1
+#define AMBIGUOUS_ID -2
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
 /*
    Field                  Len  Type
   --------------------------------------------------------
diff --git a/pmc_common.h b/pmc_common.h
index b1fdcd6..9fa72de 100644
--- a/pmc_common.h
+++ b/pmc_common.h
@@ -25,12 +25,6 @@
 #include "msg.h"
 #include "transport.h"
 
-#define BAD_ACTION   -1
-#define BAD_ID       -1
-#define AMBIGUOUS_ID -2
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-#define P41 ((double)(1ULL << 41))
-
 struct pmc;
 
 struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
-- 
2.17.1


From e6d52c54e968f46e35d7c2e53b03f913eedc0ba5 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 31 Mar 2020 10:25:06 -0700
Subject: [PATCH 115/173] pmc: Allow printing of the SUBSCRIBE_EVENTS_NP tlv.

While we are at it, reformat the pmc_show() function into reverse
Christmas tree order.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc.c | 32 +++++++++++++++++++++-----------
 1 file changed, 21 insertions(+), 11 deletions(-)

diff --git a/pmc.c b/pmc.c
index e3cd6f3..f074621 100644
--- a/pmc.c
+++ b/pmc.c
@@ -28,6 +28,7 @@
 
 #include "ds.h"
 #include "fsm.h"
+#include "notification.h"
 #include "pmc_common.h"
 #include "print.h"
 #include "tlv.h"
@@ -56,22 +57,23 @@ static char *bin2str(Octet *data, int len)
 
 static void pmc_show(struct ptp_message *msg, FILE *fp)
 {
-	int action;
-	struct TLV *tlv;
-	struct management_tlv *mgt;
+	struct grandmaster_settings_np *gsn;
+	struct mgmt_clock_description *cd;
+	struct subscribe_events_np *sen;
 	struct management_tlv_datum *mtd;
-	struct defaultDS *dds;
-	struct currentDS *cds;
-	struct parentDS *pds;
+	struct port_properties_np *ppn;
 	struct timePropertiesDS *tp;
+	struct management_tlv *mgt;
 	struct time_status_np *tsn;
-	struct grandmaster_settings_np *gsn;
-	struct mgmt_clock_description *cd;
+	struct port_stats_np *pcp;
 	struct tlv_extra *extra;
-	struct portDS *p;
 	struct port_ds_np *pnp;
-	struct port_properties_np *ppn;
-	struct port_stats_np *pcp;
+	struct defaultDS *dds;
+	struct currentDS *cds;
+	struct parentDS *pds;
+	struct portDS *p;
+	struct TLV *tlv;
+	int action;
 
 	if (msg_type(msg) != MANAGEMENT) {
 		return;
@@ -295,6 +297,14 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			gsn->time_flags & FREQ_TRACEABLE ? 1 : 0,
 			gsn->time_source);
 		break;
+	case TLV_SUBSCRIBE_EVENTS_NP:
+		sen = (struct subscribe_events_np *) mgt->data;
+		fprintf(fp, "SUBSCRIBE_EVENTS_NP "
+			IFMT "duration          %hu"
+			IFMT "NOTIFY_PORT_STATE %s",
+			sen->duration,
+			(sen->bitmask[0] & 1 << NOTIFY_PORT_STATE) ? "on" : "off");
+		break;
 	case TLV_PORT_DATA_SET:
 		p = (struct portDS *) mgt->data;
 		if (p->portState > PS_SLAVE) {
-- 
2.17.1


From 1044268e85642253713c035aeef026a847793cf6 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 31 Mar 2020 15:03:03 -0700
Subject: [PATCH 116/173] pmc: Subscribe to port state push notification events
 when requested.

Allow interactive input like

    set SUBSCRIBE_EVENTS_NP duration 60 NOTIFY_PORT_STATE on

to request push notifications from the ptp4l service.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc_common.c | 25 ++++++++++++++++++++++---
 1 file changed, 22 insertions(+), 3 deletions(-)

diff --git a/pmc_common.c b/pmc_common.c
index 92daf20..f89d87c 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -21,6 +21,7 @@
 #include <string.h>
 #include <stdlib.h>
 
+#include "notification.h"
 #include "print.h"
 #include "tlv.h"
 #include "transport.h"
@@ -106,6 +107,7 @@ struct management_id idtab[] = {
 	{ "PRIMARY_DOMAIN", TLV_PRIMARY_DOMAIN, not_supported },
 	{ "TIME_STATUS_NP", TLV_TIME_STATUS_NP, do_get_action },
 	{ "GRANDMASTER_SETTINGS_NP", TLV_GRANDMASTER_SETTINGS_NP, do_set_action },
+	{ "SUBSCRIBE_EVENTS_NP", TLV_SUBSCRIBE_EVENTS_NP, do_set_action },
 /* Port management ID values */
 	{ "NULL_MANAGEMENT", TLV_NULL_MANAGEMENT, null_management },
 	{ "CLOCK_DESCRIPTION", TLV_CLOCK_DESCRIPTION, do_get_action },
@@ -139,12 +141,13 @@ static void do_get_action(struct pmc *pmc, int action, int index, char *str)
 
 static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 {
+	int cnt, code = idtab[index].code, freq_traceable, leap_59, leap_61,
+		ptp_timescale, time_traceable, utc_off_valid;
 	struct grandmaster_settings_np gsn;
 	struct management_tlv_datum mtd;
+	struct subscribe_events_np sen;
 	struct port_ds_np pnp;
-	int cnt, code = idtab[index].code;
-	int leap_61, leap_59, utc_off_valid;
-	int ptp_timescale, time_traceable, freq_traceable;
+	char onoff[4] = {0};
 
 	switch (action) {
 	case GET:
@@ -215,6 +218,22 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 			gsn.time_flags |= FREQ_TRACEABLE;
 		pmc_send_set_action(pmc, code, &gsn, sizeof(gsn));
 		break;
+	case TLV_SUBSCRIBE_EVENTS_NP:
+		memset(&sen, 0, sizeof(sen));
+		cnt = sscanf(str, " %*s %*s "
+			     "duration %hu "
+			     "NOTIFY_PORT_STATE %3s ",
+			     &sen.duration, onoff);
+		if (cnt != 2) {
+			fprintf(stderr, "%s SET needs 2 values\n",
+				idtab[index].name);
+			break;
+		}
+		if (!strcasecmp(onoff, "on")) {
+			sen.bitmask[0] = 1 << NOTIFY_PORT_STATE;
+		}
+		pmc_send_set_action(pmc, code, &sen, sizeof(sen));
+		break;
 	case TLV_PORT_DATA_SET_NP:
 		cnt = sscanf(str, " %*s %*s "
 			     "neighborPropDelayThresh %u "
-- 
2.17.1


From 2f0bfb2837573c4dcbbe440e642aabda0e5d5131 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Fri, 3 Apr 2020 07:11:42 -0700
Subject: [PATCH 117/173] pmc: Allow multiple local subscribers.

If more than one local UDS client subscribes to push notifications,
only the last one receives data from the ptp4l service.  This happens
because ptp4l uses the PortIdentity as a unique key to track client
subscriptions.  As a result, it is not possible for both phc2sys and
pmc to receive push notifications at the same time, for example.

This patch sets the PortIdentity.portNumber attribute of UDS clients
to the local process ID, making each such client subscription unique.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc_common.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/pmc_common.c b/pmc_common.c
index f89d87c..822dd6d 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -18,8 +18,10 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 #include <errno.h>
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "notification.h"
 #include "print.h"
@@ -353,13 +355,16 @@ struct pmc *pmc_create(struct config *cfg, enum transport_type transport_type,
 	if (!pmc)
 		return NULL;
 
-	if (transport_type != TRANS_UDS &&
-	    generate_clock_identity(&pmc->port_identity.clockIdentity,
-				    iface_name)) {
-		pr_err("failed to generate a clock identity");
-		goto failed;
+	if (transport_type == TRANS_UDS) {
+		pmc->port_identity.portNumber = getpid();
+	} else {
+		if (generate_clock_identity(&pmc->port_identity.clockIdentity,
+					    iface_name)) {
+			pr_err("failed to generate a clock identity");
+			goto failed;
+		}
+		pmc->port_identity.portNumber = 1;
 	}
-	pmc->port_identity.portNumber = 1;
 	pmc_target_all(pmc);
 
 	pmc->boundary_hops = boundary_hops;
-- 
2.17.1


From 1bdc9143aa5bfa97372e36a7e0309a67e00365e4 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 7 Jul 2019 16:47:48 -0700
Subject: [PATCH 118/173] Introduce the ts2phc program.

Some PTP Hardware Clocks have input pins that can generate time stamps
on the edges of external signals.  This functionality can be used in
various ways.  For example, one can synchronize a PHC device to a
global time source by taking a Pulse Per Second signal from the source
into the PHC.  This patch adds support for synchronizing one or more
PHC slaves to a given master clock.

The implementation follows a modular design that allows adding
different kinds of master clocks in the future.  This patch starts off
with a single "generic" PPS master, meaning a PPS signal that lacks
and time or date information.  The generic master assumes that the
Linux system time is approximately correct (by NTP or RTC for example)
in order to calculate the time of the incoming PPS edges.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
Signed-off-by: Balint Ferencz <fernya@gmail.com>
---
 .gitignore                 |   1 +
 config.c                   |  14 ++
 configs/ts2phc-generic.cfg |  18 ++
 makefile                   |   8 +-
 ts2phc.c                   | 200 +++++++++++++++++
 ts2phc_generic_master.c    |  63 ++++++
 ts2phc_generic_master.h    |  14 ++
 ts2phc_master.c            |  34 +++
 ts2phc_master.h            |  52 +++++
 ts2phc_master_private.h    |  20 ++
 ts2phc_slave.c             | 426 +++++++++++++++++++++++++++++++++++++
 ts2phc_slave.h             |  20 ++
 12 files changed, 868 insertions(+), 2 deletions(-)
 create mode 100644 configs/ts2phc-generic.cfg
 create mode 100644 ts2phc.c
 create mode 100644 ts2phc_generic_master.c
 create mode 100644 ts2phc_generic_master.h
 create mode 100644 ts2phc_master.c
 create mode 100644 ts2phc_master.h
 create mode 100644 ts2phc_master_private.h
 create mode 100644 ts2phc_slave.c
 create mode 100644 ts2phc_slave.h

diff --git a/.gitignore b/.gitignore
index 3dbcbfa..1e7d1ca 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,4 @@
 /phc_ctl
 /snmp4lptp
 /timemaster
+/ts2phc
diff --git a/config.c b/config.c
index f20c5f7..b81149c 100644
--- a/config.c
+++ b/config.c
@@ -19,6 +19,7 @@
 #include <ctype.h>
 #include <float.h>
 #include <limits.h>
+#include <linux/ptp_clock.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -169,6 +170,13 @@ static struct config_enum delay_mech_enu[] = {
 	{ NULL, 0 },
 };
 
+static struct config_enum extts_polarity_enu[] = {
+	{ "rising",  PTP_RISING_EDGE  },
+	{ "falling", PTP_FALLING_EDGE },
+	{ "both",    PTP_RISING_EDGE | PTP_FALLING_EDGE },
+	{ NULL, 0 },
+};
+
 static struct config_enum hwts_filter_enu[] = {
 	{ "normal",  HWTS_FILTER_NORMAL  },
 	{ "check",   HWTS_FILTER_CHECK   },
@@ -297,6 +305,12 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("timeSource", INTERNAL_OSCILLATOR, 0x10, 0xfe),
 	GLOB_ITEM_ENU("time_stamping", TS_HARDWARE, timestamping_enu),
 	PORT_ITEM_INT("transportSpecific", 0, 0, 0x0F),
+	PORT_ITEM_INT("ts2phc.channel", 0, 0, INT_MAX),
+	PORT_ITEM_INT("ts2phc.extts_correction", 0, INT_MIN, INT_MAX),
+	PORT_ITEM_ENU("ts2phc.extts_polarity", PTP_RISING_EDGE, extts_polarity_enu),
+	PORT_ITEM_INT("ts2phc.master", 0, 0, 1),
+	PORT_ITEM_INT("ts2phc.pin_index", 0, 0, INT_MAX),
+	GLOB_ITEM_INT("ts2phc.pulsewidth", 500000000, 1000000, 999000000),
 	PORT_ITEM_ENU("tsproc_mode", TSPROC_FILTER, tsproc_enu),
 	GLOB_ITEM_INT("twoStepFlag", 1, 0, 1),
 	GLOB_ITEM_INT("tx_timestamp_timeout", 1, 1, INT_MAX),
diff --git a/configs/ts2phc-generic.cfg b/configs/ts2phc-generic.cfg
new file mode 100644
index 0000000..69df2a9
--- /dev/null
+++ b/configs/ts2phc-generic.cfg
@@ -0,0 +1,18 @@
+#
+# This example uses a PPS signal from a GPS receiver as an input to
+# the SDP0 pin of an Intel i210 card.  The pulse from the receiver has
+# a width of 100 milliseconds.
+#
+# Important!  The polarity is set to "both" because the i210 always
+# time stamps both the rising and the falling edges of the input
+# signal.
+#
+[global]
+use_syslog		0
+verbose			1
+logging_level		6
+ts2phc.pulsewidth	100000000
+[eth6]
+ts2phc.channel		0
+ts2phc.extts_polarity	both
+ts2phc.pin_index	0
diff --git a/makefile b/makefile
index a23945a..9d8817a 100644
--- a/makefile
+++ b/makefile
@@ -22,10 +22,11 @@ CC	= $(CROSS_COMPILE)gcc
 VER     = -DVER=$(version)
 CFLAGS	= -Wall $(VER) $(incdefs) $(DEBUG) $(EXTRA_CFLAGS)
 LDLIBS	= -lm -lrt $(EXTRA_LDFLAGS)
-PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster
+PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster ts2phc
 FILTERS	= filter.o mave.o mmedian.o
 SERVOS	= linreg.o ntpshm.o nullf.o pi.o servo.o
 TRANSP	= raw.o transport.o udp.o udp6.o uds.o
+TS2PHC	= ts2phc.o ts2phc_generic_master.o ts2phc_master.o ts2phc_slave.o
 OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
  e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o msg.o phc.o port.o \
  port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o \
@@ -33,7 +34,7 @@ OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
  unicast_fsm.o unicast_service.o util.o version.o
 
 OBJECTS	= $(OBJ) hwstamp_ctl.o nsm.o phc2sys.o phc_ctl.o pmc.o pmc_common.o \
- sysoff.o timemaster.o
+ sysoff.o timemaster.o $(TS2PHC)
 SRC	= $(OBJECTS:.o=.c)
 DEPEND	= $(OBJECTS:.o=.d)
 srcdir	:= $(dir $(lastword $(MAKEFILE_LIST)))
@@ -66,6 +67,9 @@ phc_ctl: phc_ctl.o phc.o sk.o util.o clockadj.o sysoff.o print.o version.o
 
 timemaster: phc.o print.o rtnl.o sk.o timemaster.o util.o version.o
 
+ts2phc: config.o clockadj.o hash.o interface.o phc.o print.o $(SERVOS) sk.o \
+ $(TS2PHC) util.o version.o
+
 version.o: .version version.sh $(filter-out version.d,$(DEPEND))
 
 .version: force
diff --git a/ts2phc.c b/ts2phc.c
new file mode 100644
index 0000000..abc54b6
--- /dev/null
+++ b/ts2phc.c
@@ -0,0 +1,200 @@
+/**
+ * @file ts2phc.c
+ * @brief Utility program to synchronize the PHC clock to external events
+ * @note Copyright (C) 2013 Balint Ferencz <fernya@sch.bme.hu>
+ * @note Based on the phc2sys utility
+ * @note Copyright (C) 2012 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <stdlib.h>
+
+#include "config.h"
+#include "interface.h"
+#include "print.h"
+#include "ts2phc_master.h"
+#include "ts2phc_slave.h"
+#include "version.h"
+
+struct interface {
+	STAILQ_ENTRY(interface) list;
+};
+
+static void ts2phc_cleanup(struct config *cfg, struct ts2phc_master *master)
+{
+	ts2phc_slave_cleanup();
+	if (master) {
+		ts2phc_master_destroy(master);
+	}
+	if (cfg) {
+		config_destroy(cfg);
+	}
+}
+
+static void usage(char *progname)
+{
+	fprintf(stderr,
+		"\n"
+		"usage: %s [options]\n\n"
+		" -c [dev|name]  phc slave clock (like /dev/ptp0 or eth0)\n"
+		"                (may be specified multiple times)\n"
+		" -f [file]      read configuration from 'file'\n"
+		" -h             prints this message and exits\n"
+		" -l [num]       set the logging level to 'num'\n"
+		" -m             print messages to stdout\n"
+		" -q             do not print messages to the syslog\n"
+		" -s [dev|name]  source of the PPS signal\n"
+		"                may take any of the following forms:\n"
+		"                    generic   - an external 1-PPS without ToD information\n"
+		" -v             prints the software version and exits\n"
+		"\n",
+		progname);
+}
+
+int main(int argc, char *argv[])
+{
+	int c, err = 0, have_slave = 0, index, print_level;
+	struct ts2phc_master *master = NULL;
+	enum ts2phc_master_type pps_type;
+	char *config = NULL, *progname;
+	const char *pps_source = NULL;
+	struct config *cfg = NULL;
+	struct interface *iface;
+	struct option *opts;
+
+	handle_term_signals();
+
+	cfg = config_create();
+	if (!cfg) {
+		ts2phc_cleanup(cfg, master);
+		return -1;
+	}
+
+	opts = config_long_options(cfg);
+
+	/* Process the command line arguments. */
+	progname = strrchr(argv[0], '/');
+	progname = progname ? 1 + progname : argv[0];
+	while (EOF != (c = getopt_long(argc, argv, "c:f:hi:l:mqs:v", opts, &index))) {
+		switch (c) {
+		case 0:
+			if (config_parse_option(cfg, opts[index].name, optarg)) {
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			break;
+		case 'c':
+			if (!config_create_interface(optarg, cfg)) {
+				fprintf(stderr, "failed to add slave\n");
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			have_slave = 1;
+			break;
+		case 'f':
+			config = optarg;
+			break;
+		case 'l':
+			if (get_arg_val_i(c, optarg, &print_level,
+					  PRINT_LEVEL_MIN, PRINT_LEVEL_MAX)) {
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			config_set_int(cfg, "logging_level", print_level);
+			print_set_level(print_level);
+			break;
+		case 'm':
+			config_set_int(cfg, "verbose", 1);
+			print_set_verbose(1);
+			break;
+		case 'q':
+			config_set_int(cfg, "use_syslog", 0);
+			print_set_syslog(0);
+			break;
+		case 's':
+			if (pps_source) {
+				fprintf(stderr, "too many PPS sources\n");
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			pps_source = optarg;
+			break;
+		case 'v':
+			ts2phc_cleanup(cfg, master);
+			version_show(stdout);
+			return 0;
+		case 'h':
+			ts2phc_cleanup(cfg, master);
+			usage(progname);
+			return -1;
+		case '?':
+		default:
+			ts2phc_cleanup(cfg, master);
+			usage(progname);
+			return -1;
+		}
+	}
+	if (config && (c = config_read(config, cfg))) {
+		fprintf(stderr, "failed to read config\n");
+		ts2phc_cleanup(cfg, master);
+		return -1;
+	}
+	print_set_progname(progname);
+	print_set_tag(config_get_string(cfg, NULL, "message_tag"));
+	print_set_verbose(config_get_int(cfg, NULL, "verbose"));
+	print_set_syslog(config_get_int(cfg, NULL, "use_syslog"));
+	print_set_level(config_get_int(cfg, NULL, "logging_level"));
+
+	STAILQ_FOREACH(iface, &cfg->interfaces, list) {
+		if (1 == config_get_int(cfg, interface_name(iface), "ts2phc.master")) {
+			if (pps_source) {
+				fprintf(stderr, "too many PPS sources\n");
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			pps_source = interface_name(iface);
+		} else {
+			if (ts2phc_slave_add(cfg, interface_name(iface))) {
+				fprintf(stderr, "failed to add slave\n");
+				ts2phc_cleanup(cfg, master);
+				return -1;
+			}
+			have_slave = 1;
+		}
+	}
+	if (!have_slave) {
+		fprintf(stderr, "no slave clocks specified\n");
+		ts2phc_cleanup(cfg, master);
+		usage(progname);
+		return -1;
+	}
+	if (!pps_source) {
+		fprintf(stderr, "no PPS source specified\n");
+		ts2phc_cleanup(cfg, master);
+		usage(progname);
+		return -1;
+	}
+	if (ts2phc_slave_arm()) {
+		fprintf(stderr, "failed to arm slaves\n");
+		ts2phc_cleanup(cfg, master);
+		return -1;
+	}
+
+	pps_type = TS2PHC_MASTER_GENERIC;
+	master = ts2phc_master_create(cfg, pps_source, pps_type);
+	if (!master) {
+		fprintf(stderr, "failed to create master\n");
+		ts2phc_cleanup(cfg, master);
+		return -1;
+	}
+
+	while (is_running()) {
+		err = ts2phc_slave_poll(master);
+		if (err) {
+			pr_err("poll failed");
+			break;
+		}
+	}
+
+	ts2phc_cleanup(cfg, master);
+	return err;
+}
diff --git a/ts2phc_generic_master.c b/ts2phc_generic_master.c
new file mode 100644
index 0000000..ad4f7f1
--- /dev/null
+++ b/ts2phc_generic_master.c
@@ -0,0 +1,63 @@
+/**
+ * @file ts2phc_generic_master.c
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <stdlib.h>
+#include <time.h>
+
+#include "missing.h"
+#include "print.h"
+#include "ts2phc_generic_master.h"
+#include "ts2phc_master_private.h"
+#include "util.h"
+
+struct ts2phc_generic_master {
+	struct ts2phc_master master;
+};
+
+static void ts2phc_generic_master_destroy(struct ts2phc_master *master)
+{
+	struct ts2phc_generic_master *s =
+		container_of(master, struct ts2phc_generic_master, master);
+	free(s);
+}
+
+/*
+ * Returns the time on the PPS source device at which the most recent
+ * PPS event was generated.  This implementation assumes that the
+ * system time is approximately correct.
+ */
+static int ts2phc_generic_master_getppstime(struct ts2phc_master *m,
+					    struct timespec *ts)
+{
+	struct timex ntx;
+	int code;
+
+	memset(&ntx, 0, sizeof(ntx));
+	ntx.modes = ADJ_NANO;
+	code = adjtimex(&ntx);
+	if (code == -1) {
+		pr_err("adjtimex failed: %m");
+		return -1;
+	}
+	ts->tv_sec  = ntx.time.tv_sec + ntx.tai;
+	ts->tv_nsec = ntx.time.tv_usec;
+
+	return 0;
+}
+
+struct ts2phc_master *ts2phc_generic_master_create(struct config *cfg,
+						   const char *dev)
+{
+	struct ts2phc_generic_master *master;
+
+	master = calloc(1, sizeof(*master));
+	if (!master) {
+		return NULL;
+	}
+	master->master.destroy = ts2phc_generic_master_destroy;
+	master->master.getppstime = ts2phc_generic_master_getppstime;
+
+	return &master->master;
+}
diff --git a/ts2phc_generic_master.h b/ts2phc_generic_master.h
new file mode 100644
index 0000000..ac0ce4f
--- /dev/null
+++ b/ts2phc_generic_master.h
@@ -0,0 +1,14 @@
+/**
+ * @file ts2phc_generic_master.h
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_GENERIC_MASTER_H
+#define HAVE_TS2PHC_GENERIC_MASTER_H
+
+#include "ts2phc_master.h"
+
+struct ts2phc_master *ts2phc_generic_master_create(struct config *cfg,
+						   const char *dev);
+
+#endif
diff --git a/ts2phc_master.c b/ts2phc_master.c
new file mode 100644
index 0000000..a1004f4
--- /dev/null
+++ b/ts2phc_master.c
@@ -0,0 +1,34 @@
+/**
+ * @file ts2phc_master.c
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include "ts2phc_generic_master.h"
+#include "ts2phc_master_private.h"
+
+struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
+					   enum ts2phc_master_type type)
+{
+	struct ts2phc_master *master = NULL;
+
+	switch (type) {
+	case TS2PHC_MASTER_GENERIC:
+		master = ts2phc_generic_master_create(cfg, dev);
+		break;
+	case TS2PHC_MASTER_NMEA:
+		break;
+	case TS2PHC_MASTER_PHC:
+		break;
+	}
+	return master;
+}
+
+void ts2phc_master_destroy(struct ts2phc_master *master)
+{
+	master->destroy(master);
+}
+
+int ts2phc_master_getppstime(struct ts2phc_master *master, struct timespec *ts)
+{
+	return master->getppstime(master, ts);
+}
diff --git a/ts2phc_master.h b/ts2phc_master.h
new file mode 100644
index 0000000..79765b6
--- /dev/null
+++ b/ts2phc_master.h
@@ -0,0 +1,52 @@
+/**
+ * @file ts2phc_master.h
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_MASTER_H
+#define HAVE_TS2PHC_MASTER_H
+
+#include <time.h>
+
+struct config;
+
+/**
+ * Opaque type
+ */
+struct ts2phc_master;
+
+/**
+ * Defines the available PPS master clocks.
+ */
+enum ts2phc_master_type {
+	TS2PHC_MASTER_GENERIC,
+	TS2PHC_MASTER_NMEA,
+	TS2PHC_MASTER_PHC,
+};
+
+/**
+ * Create a new instance of a PPS master clock.
+ * @param cfg	Pointer to a valid configuration.
+ * @param dev   Name of the master clock or NULL.
+ * @param type	The type of the clock to create.
+ * @return	A pointer to a new PPS master clock on success, NULL otherwise.
+ */
+struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
+					   enum ts2phc_master_type type);
+
+/**
+ * Destroy an instance of a PPS master clock.
+ * @param master Pointer to a master obtained via @ref ts2phc_master_create().
+ */
+void ts2phc_master_destroy(struct ts2phc_master *master);
+
+/**
+ * Returns the time on the PPS source device at which the most recent
+ * PPS event was generated.
+ * @param master Pointer to a master obtained via @ref ts2phc_master_create().
+ * @param ts     Buffer to hold the time of the last PPS event.
+ * @return       Zero if the reported time is valid, non-zero otherwise.
+ */
+int ts2phc_master_getppstime(struct ts2phc_master *master, struct timespec *ts);
+
+#endif
diff --git a/ts2phc_master_private.h b/ts2phc_master_private.h
new file mode 100644
index 0000000..463a1f0
--- /dev/null
+++ b/ts2phc_master_private.h
@@ -0,0 +1,20 @@
+/**
+ * @file ts2phc_master_private.h
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_MASTER_PRIVATE_H
+#define HAVE_TS2PHC_MASTER_PRIVATE_H
+
+#include <stdint.h>
+#include <time.h>
+
+#include "contain.h"
+#include "ts2phc_master.h"
+
+struct ts2phc_master {
+	void (*destroy)(struct ts2phc_master *ts2phc_master);
+	int (*getppstime)(struct ts2phc_master *master, struct timespec *ts);
+};
+
+#endif
diff --git a/ts2phc_slave.c b/ts2phc_slave.c
new file mode 100644
index 0000000..82848d0
--- /dev/null
+++ b/ts2phc_slave.c
@@ -0,0 +1,426 @@
+/**
+ * @file ts2phc_slave.c
+ * @brief Utility program to synchronize the PHC clock to external events
+ * @note Copyright (C) 2019 Balint Ferencz <fernya@sch.bme.hu>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <errno.h>
+#include <linux/ptp_clock.h>
+#include <poll.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/queue.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "clockadj.h"
+#include "missing.h"
+#include "phc.h"
+#include "print.h"
+#include "servo.h"
+#include "ts2phc_master.h"
+#include "ts2phc_slave.h"
+#include "util.h"
+
+#define NS_PER_SEC		1000000000LL
+#define SAMPLE_WEIGHT		1.0
+#define SERVO_SYNC_INTERVAL	1.0
+
+struct ts2phc_slave {
+	char *name;
+	STAILQ_ENTRY(ts2phc_slave) list;
+	struct ptp_pin_desc pin_desc;
+	enum servo_state state;
+	unsigned int polarity;
+	int32_t correction;
+	uint32_t ignore_lower;
+	uint32_t ignore_upper;
+	struct servo *servo;
+	clockid_t clk;
+	int no_adj;
+	int fd;
+};
+
+struct ts2phc_slave_array {
+	struct ts2phc_slave **slave;
+	struct pollfd *pfd;
+} polling_array;
+
+struct ts2phc_source_timestamp {
+	struct timespec ts;
+	int valid;
+};
+
+enum extts_result {
+	EXTTS_ERROR	= -1,
+	EXTTS_OK	= 0,
+	EXTTS_IGNORE	= 1,
+};
+
+static enum extts_result ts2phc_slave_offset(struct ts2phc_slave *slave,
+					     struct ts2phc_source_timestamp ts,
+					     int64_t *offset,
+					     uint64_t *local_ts);
+
+static STAILQ_HEAD(slave_ifaces_head, ts2phc_slave) ts2phc_slaves =
+	STAILQ_HEAD_INITIALIZER(ts2phc_slaves);
+
+static unsigned int ts2phc_n_slaves;
+
+static int ts2phc_slave_array_create(void)
+{
+	struct ts2phc_slave *slave;
+	unsigned int i;
+
+	if (polling_array.slave) {
+		return 0;
+	}
+	polling_array.slave = malloc(ts2phc_n_slaves * sizeof(*polling_array.slave));
+	if (!polling_array.slave) {
+		pr_err("low memory");
+		return -1;
+	}
+	polling_array.pfd = malloc(ts2phc_n_slaves * sizeof(*polling_array.pfd));
+	if (!polling_array.pfd) {
+		pr_err("low memory");
+		free(polling_array.slave);
+		polling_array.slave = NULL;
+		return -1;
+	}
+	i = 0;
+	STAILQ_FOREACH(slave, &ts2phc_slaves, list) {
+		polling_array.slave[i] = slave;
+		i++;
+	}
+	for (i = 0; i < ts2phc_n_slaves; i++) {
+		polling_array.pfd[i].events = POLLIN | POLLPRI;
+		polling_array.pfd[i].fd = polling_array.slave[i]->fd;
+	}
+	return 0;
+}
+
+static void ts2phc_slave_array_destroy(void)
+{
+	free(polling_array.slave);
+	free(polling_array.pfd);
+	polling_array.slave = NULL;
+	polling_array.pfd = NULL;
+}
+
+static int ts2phc_slave_clear_fifo(struct ts2phc_slave *slave)
+{
+	struct pollfd pfd = {
+		.events = POLLIN | POLLPRI,
+		.fd = slave->fd,
+	};
+	struct ptp_extts_event event;
+	int cnt, size;
+
+	while (1) {
+		cnt = poll(&pfd, 1, 0);
+		if (cnt < 0) {
+			if (EINTR == errno) {
+				continue;
+			} else {
+				pr_emerg("poll failed");
+				return -1;
+			}
+		} else if (!cnt) {
+			break;
+		}
+		size = read(pfd.fd, &event, sizeof(event));
+		if (size != sizeof(event)) {
+			pr_err("read failed");
+			return -1;
+		}
+		pr_debug("%s SKIP extts index %u at %lld.%09u",
+			 slave->name, event.index, event.t.sec, event.t.nsec);
+	}
+
+	return 0;
+}
+
+static struct ts2phc_slave *ts2phc_slave_create(struct config *cfg, const char *device)
+{
+	enum servo_type servo = config_get_int(cfg, NULL, "clock_servo");
+	int err, fadj, junk, max_adj, pulsewidth;
+	struct ptp_extts_request extts;
+	struct ts2phc_slave *slave;
+
+	slave = calloc(1, sizeof(*slave));
+	if (!slave) {
+		pr_err("low memory");
+		return NULL;
+	}
+	slave->name = strdup(device);
+	if (!slave->name) {
+		pr_err("low memory");
+		free(slave);
+		return NULL;
+	}
+	slave->pin_desc.index = config_get_int(cfg, device, "ts2phc.pin_index");
+	slave->pin_desc.func = PTP_PF_EXTTS;
+	slave->pin_desc.chan = config_get_int(cfg, device, "ts2phc.channel");
+	slave->polarity = config_get_int(cfg, device, "ts2phc.extts_polarity");
+	slave->correction = config_get_int(cfg, device, "ts2phc.extts_correction");
+
+	pulsewidth = config_get_int(cfg, device, "ts2phc.pulsewidth");
+	pulsewidth /= 2;
+	slave->ignore_upper = 1000000000 - pulsewidth;
+	slave->ignore_lower = pulsewidth;
+
+	slave->clk = posix_clock_open(device, &junk);
+	if (slave->clk == CLOCK_INVALID) {
+		pr_err("failed to open clock");
+		goto no_posix_clock;
+	}
+	slave->no_adj = config_get_int(cfg, NULL, "free_running");
+	slave->fd = CLOCKID_TO_FD(slave->clk);
+
+	pr_debug("PHC slave %s has ptp index %d", device, junk);
+
+	fadj = (int) clockadj_get_freq(slave->clk);
+	/* Due to a bug in older kernels, the reading may silently fail
+	   and return 0. Set the frequency back to make sure fadj is
+	   the actual frequency of the clock. */
+	clockadj_set_freq(slave->clk, fadj);
+
+	max_adj = phc_max_adj(slave->clk);
+
+	slave->servo = servo_create(cfg, servo, -fadj, max_adj, 0);
+	if (!slave->servo) {
+		pr_err("failed to create servo");
+		goto no_servo;
+	}
+	servo_sync_interval(slave->servo, SERVO_SYNC_INTERVAL);
+
+	if (phc_number_pins(slave->clk) > 0) {
+		err = phc_pin_setfunc(slave->clk, &slave->pin_desc);
+		if (err < 0) {
+			pr_err("PTP_PIN_SETFUNC request failed");
+			goto no_pin_func;
+		}
+	}
+
+	/*
+	 * Disable external time stamping, and then read out any stale
+	 * time stamps.
+	 */
+	memset(&extts, 0, sizeof(extts));
+	extts.index = slave->pin_desc.chan;
+	extts.flags = 0;
+	if (ioctl(slave->fd, PTP_EXTTS_REQUEST2, &extts)) {
+		pr_err(PTP_EXTTS_REQUEST_FAILED);
+	}
+	if (ts2phc_slave_clear_fifo(slave)) {
+		goto no_ext_ts;
+	}
+
+	return slave;
+no_ext_ts:
+no_pin_func:
+	servo_destroy(slave->servo);
+no_servo:
+	close(slave->fd);
+no_posix_clock:
+	free(slave->name);
+	free(slave);
+	return NULL;
+}
+
+static void ts2phc_slave_destroy(struct ts2phc_slave *slave)
+{
+	struct ptp_extts_request extts;
+
+	memset(&extts, 0, sizeof(extts));
+	extts.index = slave->pin_desc.chan;
+	extts.flags = 0;
+	if (ioctl(slave->fd, PTP_EXTTS_REQUEST2, &extts)) {
+		pr_err(PTP_EXTTS_REQUEST_FAILED);
+	}
+	posix_clock_close(slave->clk);
+	free(slave->name);
+	free(slave);
+}
+
+static int ts2phc_slave_event(struct ts2phc_slave *slave,
+			      struct ts2phc_source_timestamp source_ts)
+{
+	enum extts_result result;
+	uint64_t extts_ts;
+	int64_t offset;
+	double adj;
+
+	result = ts2phc_slave_offset(slave, source_ts, &offset, &extts_ts);
+	switch (result) {
+	case EXTTS_ERROR:
+		return -1;
+	case EXTTS_OK:
+		break;
+	case EXTTS_IGNORE:
+		return 0;
+	}
+
+	if (slave->no_adj) {
+		pr_info("%s master offset %10" PRId64, slave->name, offset);
+		return 0;
+	}
+
+	adj = servo_sample(slave->servo, offset, extts_ts,
+			   SAMPLE_WEIGHT, &slave->state);
+
+	pr_debug("%s master offset %10" PRId64 " s%d freq %+7.0f",
+		 slave->name, offset, slave->state, adj);
+
+	switch (slave->state) {
+	case SERVO_UNLOCKED:
+		break;
+	case SERVO_JUMP:
+		clockadj_set_freq(slave->clk, -adj);
+		clockadj_step(slave->clk, -offset);
+		break;
+	case SERVO_LOCKED:
+	case SERVO_LOCKED_STABLE:
+		clockadj_set_freq(slave->clk, -adj);
+		break;
+	}
+	return 0;
+}
+
+static enum extts_result ts2phc_slave_offset(struct ts2phc_slave *slave,
+					     struct ts2phc_source_timestamp src,
+					     int64_t *offset,
+					     uint64_t *local_ts)
+{
+	struct timespec source_ts = src.ts;
+	struct ptp_extts_event event;
+	uint64_t event_ns, source_ns;
+	int cnt;
+
+	cnt = read(slave->fd, &event, sizeof(event));
+	if (cnt != sizeof(event)) {
+		pr_err("read extts event failed: %m");
+		return EXTTS_ERROR;
+	}
+	if (event.index != slave->pin_desc.chan) {
+		pr_err("extts on unexpected channel");
+		return EXTTS_ERROR;
+	}
+	event_ns = event.t.sec * NS_PER_SEC;
+	event_ns += event.t.nsec;
+
+	if (slave->polarity == (PTP_RISING_EDGE | PTP_FALLING_EDGE) &&
+	    source_ts.tv_nsec > slave->ignore_lower &&
+	    source_ts.tv_nsec < slave->ignore_upper) {
+
+		pr_debug("%s SKIP extts index %u at %lld.%09u src %" PRIi64 ".%ld",
+		 slave->name, event.index, event.t.sec, event.t.nsec,
+		 (int64_t) source_ts.tv_sec, source_ts.tv_nsec);
+
+		return EXTTS_IGNORE;
+	}
+	if (source_ts.tv_nsec > 500000000) {
+		source_ts.tv_sec++;
+	}
+	source_ns = source_ts.tv_sec * NS_PER_SEC;
+	*offset = event_ns + slave->correction - source_ns;
+	*local_ts = event_ns + slave->correction;
+
+	pr_debug("%s extts index %u at %lld.%09u corr %d src %" PRIi64
+		 ".%ld diff %" PRId64,
+		 slave->name, event.index, event.t.sec, event.t.nsec,
+		 slave->correction,
+		 (int64_t) source_ts.tv_sec, source_ts.tv_nsec, *offset);
+
+	return EXTTS_OK;
+}
+
+/* public methods */
+
+int ts2phc_slave_add(struct config *cfg, const char *name)
+{
+	struct ts2phc_slave *slave;
+
+	/* Create each interface only once. */
+	STAILQ_FOREACH(slave, &ts2phc_slaves, list) {
+		if (0 == strcmp(name, slave->name)) {
+			return 0;
+		}
+	}
+	slave = ts2phc_slave_create(cfg, name);
+	if (!slave) {
+		pr_err("failed to create slave");
+		return -1;
+	}
+	STAILQ_INSERT_TAIL(&ts2phc_slaves, slave, list);
+	ts2phc_n_slaves++;
+
+	return 0;
+}
+
+int ts2phc_slave_arm(void)
+{
+	struct ptp_extts_request extts;
+	struct ts2phc_slave *slave;
+	int err;
+
+	memset(&extts, 0, sizeof(extts));
+
+	STAILQ_FOREACH(slave, &ts2phc_slaves, list) {
+		extts.index = slave->pin_desc.chan;
+		extts.flags = slave->polarity | PTP_ENABLE_FEATURE;
+		err = ioctl(slave->fd, PTP_EXTTS_REQUEST2, &extts);
+		if (err < 0) {
+			pr_err(PTP_EXTTS_REQUEST_FAILED);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+void ts2phc_slave_cleanup(void)
+{
+	struct ts2phc_slave *slave;
+
+	ts2phc_slave_array_destroy();
+
+	while ((slave = STAILQ_FIRST(&ts2phc_slaves))) {
+		STAILQ_REMOVE_HEAD(&ts2phc_slaves, list);
+		ts2phc_slave_destroy(slave);
+		ts2phc_n_slaves--;
+	}
+}
+
+int ts2phc_slave_poll(struct ts2phc_master *master)
+{
+	struct ts2phc_source_timestamp source_ts;
+	unsigned int i;
+	int cnt;
+
+	if (ts2phc_slave_array_create()) {
+		return -1;
+	}
+	cnt = poll(polling_array.pfd, ts2phc_n_slaves, 2000);
+	if (cnt < 0) {
+		if (EINTR == errno) {
+			return 0;
+		} else {
+			pr_emerg("poll failed");
+			return -1;
+		}
+	} else if (!cnt) {
+		pr_debug("poll returns zero, no events");
+		return 0;
+	}
+
+	source_ts.valid = ts2phc_master_getppstime(master, &source_ts.ts);
+
+	for (i = 0; i < ts2phc_n_slaves; i++) {
+		if (polling_array.pfd[i].revents & (POLLIN|POLLPRI)) {
+			ts2phc_slave_event(polling_array.slave[i], source_ts);
+		}
+	}
+	return 0;
+}
diff --git a/ts2phc_slave.h b/ts2phc_slave.h
new file mode 100644
index 0000000..2de5ab7
--- /dev/null
+++ b/ts2phc_slave.h
@@ -0,0 +1,20 @@
+/**
+ * @file ts2phc_slave.h
+ * @brief Utility program to synchronize the PHC clock to external events
+ * @note Copyright (C) 2019 Balint Ferencz <fernya@sch.bme.hu>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_SLAVE_H
+#define HAVE_TS2PHC_SLAVE_H
+
+#include "ts2phc_master.h"
+
+int ts2phc_slave_add(struct config *cfg, const char *name);
+
+int ts2phc_slave_arm(void);
+
+void ts2phc_slave_cleanup(void);
+
+int ts2phc_slave_poll(struct ts2phc_master *master);
+
+#endif
-- 
2.17.1


From 9c6e0f57b3e55db9a16ba61ebd596dd1d39c6674 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 22 Dec 2019 12:51:43 -0800
Subject: [PATCH 119/173] ts2phc: Support using a PHC as the master clock.

This patch introduces a new ts2phc source using a PHC device.  There
are multiple use cases for such a master.  By connecting pins of two
or more separate PHC devices together, one may act as the source, and
the others may be synchronized to it in hardware.  In this way, "just
a bunch of devices" together forms a Transparent Clock.  If the master
clock is synchronized to a global time source (like a PPS from a GPS),
then the system becomes a mutli-port Grand Master or a Boundary Clock
with GM capability.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 configs/ts2phc-TC.cfg |  27 ++++++++++
 makefile              |   3 +-
 ts2phc.c              |   8 ++-
 ts2phc_master.c       |   2 +
 ts2phc_phc_master.c   | 113 ++++++++++++++++++++++++++++++++++++++++++
 ts2phc_phc_master.h   |  14 ++++++
 6 files changed, 165 insertions(+), 2 deletions(-)
 create mode 100644 configs/ts2phc-TC.cfg
 create mode 100644 ts2phc_phc_master.c
 create mode 100644 ts2phc_phc_master.h

diff --git a/configs/ts2phc-TC.cfg b/configs/ts2phc-TC.cfg
new file mode 100644
index 0000000..3fa0b26
--- /dev/null
+++ b/configs/ts2phc-TC.cfg
@@ -0,0 +1,27 @@
+#
+# This example shows ts2phc keeping a group of three Intel i210 cards
+# synchronized to each other in order to form a Transparent Clock.
+# The cards are configured to use their SDP0 pins connected in
+# hardware.  Here eth3 and eth4 will be slaved to eth6.
+#
+# Important!  The polarity is set to "both" because the i210 always
+# time stamps both the rising and the falling edges of the input
+# signal.
+#
+[global]
+use_syslog		0
+verbose			1
+logging_level		6
+ts2phc.pulsewidth	500000000
+[eth6]
+ts2phc.channel		0
+ts2phc.master		1
+ts2phc.pin_index	0
+[eth3]
+ts2phc.channel		0
+ts2phc.extts_polarity	both
+ts2phc.pin_index	0
+[eth4]
+ts2phc.channel		0
+ts2phc.extts_polarity	both
+ts2phc.pin_index	0
diff --git a/makefile b/makefile
index 9d8817a..17f2e55 100644
--- a/makefile
+++ b/makefile
@@ -26,7 +26,8 @@ PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster ts2phc
 FILTERS	= filter.o mave.o mmedian.o
 SERVOS	= linreg.o ntpshm.o nullf.o pi.o servo.o
 TRANSP	= raw.o transport.o udp.o udp6.o uds.o
-TS2PHC	= ts2phc.o ts2phc_generic_master.o ts2phc_master.o ts2phc_slave.o
+TS2PHC	= ts2phc.o ts2phc_generic_master.o ts2phc_master.o ts2phc_phc_master.o \
+ ts2phc_slave.o
 OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
  e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o msg.o phc.o port.o \
  port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o \
diff --git a/ts2phc.c b/ts2phc.c
index abc54b6..fe7fb3f 100644
--- a/ts2phc.c
+++ b/ts2phc.c
@@ -45,6 +45,8 @@ static void usage(char *progname)
 		" -s [dev|name]  source of the PPS signal\n"
 		"                may take any of the following forms:\n"
 		"                    generic   - an external 1-PPS without ToD information\n"
+		"                    /dev/ptp0 - a local PTP Hardware Clock (PHC)\n"
+		"                    eth0      - a local PTP Hardware Clock (PHC)\n"
 		" -v             prints the software version and exits\n"
 		"\n",
 		progname);
@@ -179,7 +181,11 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 
-	pps_type = TS2PHC_MASTER_GENERIC;
+	if (!strcasecmp(pps_source, "generic")) {
+		pps_type = TS2PHC_MASTER_GENERIC;
+	} else {
+		pps_type = TS2PHC_MASTER_PHC;
+	}
 	master = ts2phc_master_create(cfg, pps_source, pps_type);
 	if (!master) {
 		fprintf(stderr, "failed to create master\n");
diff --git a/ts2phc_master.c b/ts2phc_master.c
index a1004f4..895a0f8 100644
--- a/ts2phc_master.c
+++ b/ts2phc_master.c
@@ -5,6 +5,7 @@
  */
 #include "ts2phc_generic_master.h"
 #include "ts2phc_master_private.h"
+#include "ts2phc_phc_master.h"
 
 struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
 					   enum ts2phc_master_type type)
@@ -18,6 +19,7 @@ struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
 	case TS2PHC_MASTER_NMEA:
 		break;
 	case TS2PHC_MASTER_PHC:
+		master = ts2phc_phc_master_create(cfg, dev);
 		break;
 	}
 	return master;
diff --git a/ts2phc_phc_master.c b/ts2phc_phc_master.c
new file mode 100644
index 0000000..9f1837b
--- /dev/null
+++ b/ts2phc_phc_master.c
@@ -0,0 +1,113 @@
+/**
+ * @file ts2phc_phc_master.c
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <linux/ptp_clock.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "config.h"
+#include "phc.h"
+#include "print.h"
+#include "missing.h"
+#include "ts2phc_master_private.h"
+#include "ts2phc_phc_master.h"
+#include "util.h"
+
+struct ts2phc_phc_master {
+	struct ts2phc_master master;
+	clockid_t clkid;
+	int channel;
+	int fd;
+};
+
+static int ts2phc_phc_master_activate(struct config *cfg, const char *dev,
+				      struct ts2phc_phc_master *master)
+{
+	struct ptp_perout_request perout_request;
+	struct ptp_pin_desc desc;
+	struct timespec ts;
+
+	memset(&desc, 0, sizeof(desc));
+
+	master->channel = config_get_int(cfg, dev, "ts2phc.channel");
+
+	desc.index = config_get_int(cfg, dev, "ts2phc.pin_index");
+	desc.func = PTP_PF_PEROUT;
+	desc.chan = master->channel;
+
+	if (phc_pin_setfunc(master->clkid, &desc)) {
+		pr_warning("Failed to set the pin. Continuing bravely on...");
+	}
+	if (clock_gettime(master->clkid, &ts)) {
+		perror("clock_gettime");
+		return -1;
+	}
+	memset(&perout_request, 0, sizeof(perout_request));
+	perout_request.index = master->channel;
+	perout_request.start.sec = ts.tv_sec + 2;
+	perout_request.start.nsec = 0;
+	perout_request.period.sec = 1;
+	perout_request.period.nsec = 0;
+
+	if (ioctl(master->fd, PTP_PEROUT_REQUEST2, &perout_request)) {
+		pr_err(PTP_PEROUT_REQUEST_FAILED);
+		return -1;
+	}
+	return 0;
+}
+
+static void ts2phc_phc_master_destroy(struct ts2phc_master *master)
+{
+	struct ts2phc_phc_master *m =
+		container_of(master, struct ts2phc_phc_master, master);
+	struct ptp_perout_request perout_request;
+
+	memset(&perout_request, 0, sizeof(perout_request));
+	perout_request.index = m->channel;
+	if (ioctl(m->fd, PTP_PEROUT_REQUEST2, &perout_request)) {
+		pr_err(PTP_PEROUT_REQUEST_FAILED);
+	}
+	posix_clock_close(m->clkid);
+	free(m);
+}
+
+static int ts2phc_phc_master_getppstime(struct ts2phc_master *m,
+					struct timespec *ts)
+{
+	struct ts2phc_phc_master *master =
+		container_of(m, struct ts2phc_phc_master, master);
+	return clock_gettime(master->clkid, ts);
+}
+
+struct ts2phc_master *ts2phc_phc_master_create(struct config *cfg,
+					       const char *dev)
+{
+	struct ts2phc_phc_master *master;
+	int junk;
+
+	master = calloc(1, sizeof(*master));
+	if (!master) {
+		return NULL;
+	}
+	master->master.destroy = ts2phc_phc_master_destroy;
+	master->master.getppstime = ts2phc_phc_master_getppstime;
+
+	master->clkid = posix_clock_open(dev, &junk);
+	if (master->clkid == CLOCK_INVALID) {
+		free(master);
+		return NULL;
+	}
+	master->fd = CLOCKID_TO_FD(master->clkid);
+
+	pr_debug("PHC master %s has ptp index %d", dev, junk);
+
+	if (ts2phc_phc_master_activate(cfg, dev, master)) {
+		ts2phc_phc_master_destroy(&master->master);
+		return NULL;
+	}
+
+	return &master->master;
+}
diff --git a/ts2phc_phc_master.h b/ts2phc_phc_master.h
new file mode 100644
index 0000000..568df1a
--- /dev/null
+++ b/ts2phc_phc_master.h
@@ -0,0 +1,14 @@
+/**
+ * @file ts2phc_phc_master.h
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_PHC_MASTER_H
+#define HAVE_TS2PHC_PHC_MASTER_H
+
+#include "ts2phc_master.h"
+
+struct ts2phc_master *ts2phc_phc_master_create(struct config *cfg,
+					       const char *dev);
+
+#endif
-- 
2.17.1


From 43c51cf1444098560c9f4f26bd60572b8b7a9d79 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 8 Mar 2020 08:20:07 -0700
Subject: [PATCH 120/173] Introduce a leap second table.

There are several issues surrounding leap seconds that emerge when a clock
takes on the Grand Master role.  One of them is the fact that GPS radios
provide time of day in the UTC time scale and not in TAI, and they do not,
in general, provide any conversion information.  Another issue is the
expectation that the GM provide correct leap second status flags to the
network.  Although both NTP and GPS do, in theory, provide on-line leap
second status, in practice the information is not reliable due to poor
implementations.

In order to provide correct leap second status and TAI - UTC offsets,
this patch introduces a leap second table based on the information
published by the IETF and NIST.  The hard coded default table can be
updated at run time by reading the standard leap seconds file from the
commonly used tzdata package.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 lstab.c | 206 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 lstab.h |  64 ++++++++++++++++++
 2 files changed, 270 insertions(+)
 create mode 100644 lstab.c
 create mode 100644 lstab.h

diff --git a/lstab.c b/lstab.c
new file mode 100644
index 0000000..5fede16
--- /dev/null
+++ b/lstab.c
@@ -0,0 +1,206 @@
+/**
+ * @file lstab.c
+ * @note Copyright (C) 2012 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "lstab.h"
+
+/*
+ * Keep a history of the TAI - UTC offset in a lookup table.
+ *
+ * Each entry gives the NTP time when a new TAI offset came into
+ * effect. This is always the second immediately after a leap second.
+ *
+ * The size of the table is the number of entries from the NIST table,
+ * plus room for two hundred more entries to be added at run time.
+ * Since there can be at most two leap seconds per year, this allows
+ * for at least one hundred years.
+ *
+ * The table data are available from
+ *
+ * https://www.ietf.org/timezones/data/leap-seconds.list
+ *
+ * ftp://ftp.nist.gov/pub/time/leap-seconds.list
+ *
+ * When updating this table, do not forget to set N_HISTORICAL_LEAPS
+ * and the expiration date.
+ */
+
+#define BASE_TAI_OFFSET		10
+#define N_HISTORICAL_LEAPS	28
+#define N_LEAPS			(N_HISTORICAL_LEAPS + 200)
+#define NTP_UTC_OFFSET		2208988800ULL
+
+struct epoch_marker {
+	int offset;	/* TAI - UTC offset of epoch */
+	uint64_t ntp;	/* NTP time of epoch */
+	uint64_t tai;	/* TAI time of epoch */
+	uint64_t utc;	/* UTC time of epoch */
+};
+
+struct lstab {
+	struct epoch_marker lstab[N_LEAPS];
+	uint64_t expiration_utc;
+	int length;
+};
+
+static const uint64_t expiration_date_ntp = 3802291200ULL; /* 28 June 2020 */
+
+static const uint64_t offset_table[N_LEAPS * 2] = {
+	2272060800ULL,	10,	/* 1 Jan 1972 */
+	2287785600ULL,	11,	/* 1 Jul 1972 */
+	2303683200ULL,	12,	/* 1 Jan 1973 */
+	2335219200ULL,	13,	/* 1 Jan 1974 */
+	2366755200ULL,	14,	/* 1 Jan 1975 */
+	2398291200ULL,	15,	/* 1 Jan 1976 */
+	2429913600ULL,	16,	/* 1 Jan 1977 */
+	2461449600ULL,	17,	/* 1 Jan 1978 */
+	2492985600ULL,	18,	/* 1 Jan 1979 */
+	2524521600ULL,	19,	/* 1 Jan 1980 */
+	2571782400ULL,	20,	/* 1 Jul 1981 */
+	2603318400ULL,	21,	/* 1 Jul 1982 */
+	2634854400ULL,	22,	/* 1 Jul 1983 */
+	2698012800ULL,	23,	/* 1 Jul 1985 */
+	2776982400ULL,	24,	/* 1 Jan 1988 */
+	2840140800ULL,	25,	/* 1 Jan 1990 */
+	2871676800ULL,	26,	/* 1 Jan 1991 */
+	2918937600ULL,	27,	/* 1 Jul 1992 */
+	2950473600ULL,	28,	/* 1 Jul 1993 */
+	2982009600ULL,	29,	/* 1 Jul 1994 */
+	3029443200ULL,	30,	/* 1 Jan 1996 */
+	3076704000ULL,	31,	/* 1 Jul 1997 */
+	3124137600ULL,	32,	/* 1 Jan 1999 */
+	3345062400ULL,	33,	/* 1 Jan 2006 */
+	3439756800ULL,	34,	/* 1 Jan 2009 */
+	3550089600ULL,	35,	/* 1 Jul 2012 */
+	3644697600ULL,	36,	/* 1 Jul 2015 */
+	3692217600ULL,	37,	/* 1 Jan 2017 */
+};
+
+static void epoch_marker_init(struct epoch_marker *ls, uint64_t val, int offset)
+{
+	ls->ntp = val;
+	ls->utc = val - NTP_UTC_OFFSET;
+	ls->tai = val - NTP_UTC_OFFSET + offset;
+	ls->offset = offset;
+}
+
+static void lstab_init(struct lstab *lstab)
+{
+	struct epoch_marker *ls;
+	uint64_t offset, val;
+	int i;
+
+	for (i = 0; i < N_HISTORICAL_LEAPS; i++) {
+		ls = lstab->lstab + i;
+		val = offset_table[2 * i];
+		offset = offset_table[2 * i + 1];
+		epoch_marker_init(ls, val, offset);
+	}
+	lstab->expiration_utc = expiration_date_ntp - NTP_UTC_OFFSET;
+	lstab->length = i;
+}
+
+void lstab_print(struct lstab *lstab, FILE *fp)
+{
+	int i, len = lstab->length;
+
+	fprintf(fp, "%3s%12s%12s%12s%4s\n", "idx", "NTP", "TAI", "UTC", "OFF");
+	for (i = 0; i < len; i++) {
+		fprintf(fp, "%3d" "%12" PRIu64 "%12" PRIu64 "%12" PRIu64 "%4d\n", i,
+			lstab->lstab[i].ntp, lstab->lstab[i].tai,
+			lstab->lstab[i].utc, lstab->lstab[i].offset);
+	}
+}
+
+static int lstab_read(struct lstab *lstab, const char *name)
+{
+	uint64_t expiration, val;
+	struct epoch_marker *ls;
+	int index = 0, offset;
+	char buf[1024];
+	FILE *fp;
+
+	fp = fopen(name, "r");
+	if (!fp) {
+		fprintf(stderr, "failed to open '%s' for reading: %m\n", name);
+		return -1;
+	}
+	while (1) {
+		if (!fgets(buf, sizeof(buf), fp)) {
+			break;
+		}
+		if (1 == sscanf(buf, "#@ %" PRIu64, &expiration)) {
+			lstab->expiration_utc = expiration - NTP_UTC_OFFSET;
+			continue;
+		}
+		if (2 == sscanf(buf, "%" PRIu64 " %d", &val, &offset)) {
+			ls = lstab->lstab + index;
+			epoch_marker_init(ls, val, offset);
+			index++;
+		}
+	}
+	if (!lstab->expiration_utc) {
+		fprintf(stderr, "missing expiration date in '%s'\n", name);
+		return -1;
+	}
+	lstab->length = index;
+
+	return 0;
+}
+
+struct lstab *lstab_create(const char *filename)
+{
+	struct lstab *lstab = calloc(1, sizeof(*lstab));
+
+	if (!lstab) {
+		return NULL;
+	}
+	if (filename && filename[0]) {
+		if (lstab_read(lstab, filename)) {
+			free(lstab);
+			return NULL;
+		}
+	} else {
+		lstab_init(lstab);
+	}
+	return lstab;
+}
+
+void lstab_destroy(struct lstab *lstab)
+{
+	free(lstab);
+}
+
+enum lstab_result lstab_utc2tai(struct lstab *lstab, uint64_t utctime,
+				int *tai_offset)
+{
+	int epoch = -1, index, next;
+
+	if (utctime > lstab->expiration_utc) {
+		return LSTAB_UNKNOWN;
+	}
+
+	for (index = lstab->length - 1; index > -1; index--) {
+		if (utctime >= lstab->lstab[index].utc) {
+			epoch = index;
+			break;
+		}
+	}
+
+	if (epoch == -1) {
+		return LSTAB_UNKNOWN;
+	}
+
+	*tai_offset = lstab->lstab[epoch].offset;
+	next = epoch + 1;
+
+	if (next < lstab->length && utctime == lstab->lstab[next].utc - 1) {
+		return LSTAB_AMBIGUOUS;
+	}
+	return LSTAB_OK;
+}
diff --git a/lstab.h b/lstab.h
new file mode 100644
index 0000000..7c5d918
--- /dev/null
+++ b/lstab.h
@@ -0,0 +1,64 @@
+/**
+ * @file lstab.h
+ * @note Copyright (C) 2012 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_LEAP_SECONDS_H
+#define HAVE_LEAP_SECONDS_H
+
+#include <stdint.h>
+
+/** Opaque type */
+struct lstab;
+
+/**
+ * Creates an instance of a leap second table.
+ * @param filename  File from which to initialize the table.  If NULL or empty,
+ *                  the hard coded default table will be used.
+ * @return A pointer to a leap second table on success, NULL otherwise.
+ */
+struct lstab *lstab_create(const char *filename);
+
+/**
+ * Destroys a leap second table instance.
+ * @param lstab  A pointer obtained via lstab_create().
+ */
+void lstab_destroy(struct lstab *lstab);
+
+/**
+ * Enumerates the possible result code for the lstab_utc2tai() method.
+ */
+enum lstab_result {
+	/**
+	 * The given UTC value was found in the table, and the
+	 * corresponding TAI time is utctime + tai_offset.
+	 */
+	LSTAB_OK,
+
+	/**
+	 * The given UTC value is out of the range of the table, and
+	 * the tai_offset return value is not set.
+	 */
+	LSTAB_UNKNOWN,
+
+	/**
+	 * The given UTC value is ambiguous.  The corresponding TAI time is either
+	 *
+	 *     utctime + tai_offset
+	 * or
+	 *     utctime + tai_offset + 1.
+	 */
+	LSTAB_AMBIGUOUS,
+};
+
+/**
+ * Returns the TAI - UTC offset for a given UTC time value.
+ * @param lstab       A pointer obtained via lstab_create().
+ * @param utctime     The UTC time value of interest.
+ * @param tai_offset  Pointer to a buffer to hold the result.
+ * @return            One of the lstab_result enumeration values.
+ */
+enum lstab_result lstab_utc2tai(struct lstab *lstab, uint64_t utctime,
+				int *tai_offset);
+
+#endif
-- 
2.17.1


From 7486e6e4e1b13bd9bceb23c40ace7e048a88b8e5 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 29 Dec 2019 11:12:32 -0800
Subject: [PATCH 121/173] ts2phc: Support using a GPS radio as the master
 clock.

Many GPS radios provide both a 1-PPS and time of day information via
NMEA sentences.  This patch introduces a ts2phc master that decodes
the "recommended minimum data" sentence, RMC, which provides UTC time
and a validity flag.  Together with the file based leap second table,
this sentence provides adequate time of day for determining the time
of the PPS edge.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 config.c             |   3 +
 makefile             |   6 +-
 nmea.c               | 202 ++++++++++++++++++++++++++++++++++++++
 nmea.h               |  44 +++++++++
 serial.c             |  96 ++++++++++++++++++
 serial.h             |  19 ++++
 sock.c               |  58 +++++++++++
 sock.h               |  17 ++++
 ts2phc.c             |   3 +
 ts2phc_master.c      |   2 +
 ts2phc_nmea_master.c | 227 +++++++++++++++++++++++++++++++++++++++++++
 ts2phc_nmea_master.h |  13 +++
 12 files changed, 687 insertions(+), 3 deletions(-)
 create mode 100644 nmea.c
 create mode 100644 nmea.h
 create mode 100644 serial.c
 create mode 100644 serial.h
 create mode 100644 sock.c
 create mode 100644 sock.h
 create mode 100644 ts2phc_nmea_master.c
 create mode 100644 ts2phc_nmea_master.h

diff --git a/config.c b/config.c
index b81149c..53ad788 100644
--- a/config.c
+++ b/config.c
@@ -309,6 +309,9 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("ts2phc.extts_correction", 0, INT_MIN, INT_MAX),
 	PORT_ITEM_ENU("ts2phc.extts_polarity", PTP_RISING_EDGE, extts_polarity_enu),
 	PORT_ITEM_INT("ts2phc.master", 0, 0, 1),
+	GLOB_ITEM_STR("ts2phc.nmea_remote_host", ""),
+	GLOB_ITEM_STR("ts2phc.nmea_remote_port", ""),
+	GLOB_ITEM_STR("ts2phc.nmea_serialport", "/dev/ttyS0"),
 	PORT_ITEM_INT("ts2phc.pin_index", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("ts2phc.pulsewidth", 500000000, 1000000, 999000000),
 	PORT_ITEM_ENU("tsproc_mode", TSPROC_FILTER, tsproc_enu),
diff --git a/makefile b/makefile
index 17f2e55..acc94f7 100644
--- a/makefile
+++ b/makefile
@@ -21,13 +21,13 @@ DEBUG	=
 CC	= $(CROSS_COMPILE)gcc
 VER     = -DVER=$(version)
 CFLAGS	= -Wall $(VER) $(incdefs) $(DEBUG) $(EXTRA_CFLAGS)
-LDLIBS	= -lm -lrt $(EXTRA_LDFLAGS)
+LDLIBS	= -lm -lrt -pthread $(EXTRA_LDFLAGS)
 PRG	= ptp4l hwstamp_ctl nsm phc2sys phc_ctl pmc timemaster ts2phc
 FILTERS	= filter.o mave.o mmedian.o
 SERVOS	= linreg.o ntpshm.o nullf.o pi.o servo.o
 TRANSP	= raw.o transport.o udp.o udp6.o uds.o
-TS2PHC	= ts2phc.o ts2phc_generic_master.o ts2phc_master.o ts2phc_phc_master.o \
- ts2phc_slave.o
+TS2PHC	= ts2phc.o lstab.o nmea.o serial.o sock.o ts2phc_generic_master.o \
+ ts2phc_master.o ts2phc_phc_master.o ts2phc_nmea_master.o ts2phc_slave.o
 OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
  e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o msg.o phc.o port.o \
  port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o \
diff --git a/nmea.c b/nmea.c
new file mode 100644
index 0000000..dc865d0
--- /dev/null
+++ b/nmea.c
@@ -0,0 +1,202 @@
+/**
+ * @file nmea.c
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <malloc.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "nmea.h"
+#include "print.h"
+
+#define NMEA_CHAR_MIN	' '
+#define NMEA_CHAR_MAX	'~'
+#define NMEA_MAX_LENGTH	256
+
+enum nmea_state {
+	NMEA_IDLE,
+	NMEA_HAVE_DOLLAR,
+	NMEA_HAVE_STARTG,
+	NMEA_HAVE_STARTX,
+	NMEA_HAVE_BODY,
+	NMEA_HAVE_CSUMA,
+	NMEA_HAVE_CSUM_MSB,
+	NMEA_HAVE_CSUM_LSB,
+	NMEA_HAVE_PENULTIMATE,
+};
+
+struct nmea_parser {
+	char sentence[NMEA_MAX_LENGTH + 1];
+	char payload_checksum[3];
+	enum nmea_state state;
+	uint8_t checksum;
+	int offset;
+};
+
+static void nmea_reset(struct nmea_parser *np);
+
+static void nmea_accumulate(struct nmea_parser *np, char c)
+{
+	if (c < NMEA_CHAR_MIN || c > NMEA_CHAR_MAX) {
+		nmea_reset(np);
+		return;
+	}
+	if (np->offset == NMEA_MAX_LENGTH) {
+		nmea_reset(np);
+	}
+	np->sentence[np->offset++] = c;
+	np->checksum ^= c;
+}
+
+static int nmea_parse_symbol(struct nmea_parser *np, char c)
+{
+	switch (np->state) {
+	case NMEA_IDLE:
+		if (c == '$') {
+			np->state = NMEA_HAVE_DOLLAR;
+		}
+		break;
+	case NMEA_HAVE_DOLLAR:
+		if (c == 'G') {
+			np->state = NMEA_HAVE_STARTG;
+			nmea_accumulate(np, c);
+		} else {
+			nmea_reset(np);
+		}
+		break;
+	case NMEA_HAVE_STARTG:
+		np->state = NMEA_HAVE_STARTX;
+		nmea_accumulate(np, c);
+		break;
+	case NMEA_HAVE_STARTX:
+		np->state = NMEA_HAVE_BODY;
+		nmea_accumulate(np, c);
+		break;
+	case NMEA_HAVE_BODY:
+		if (c == '*') {
+			np->state = NMEA_HAVE_CSUMA;
+		} else {
+			nmea_accumulate(np, c);
+		}
+		break;
+	case NMEA_HAVE_CSUMA:
+		np->state = NMEA_HAVE_CSUM_MSB;
+		np->payload_checksum[0] = c;
+		break;
+	case NMEA_HAVE_CSUM_MSB:
+		np->state = NMEA_HAVE_CSUM_LSB;
+		np->payload_checksum[1] = c;
+		break;
+	case NMEA_HAVE_CSUM_LSB:
+		if (c == '\n') {
+			/*skip the CR*/
+			return 0;
+		}
+		if (c == '\r') {
+			np->state = NMEA_HAVE_PENULTIMATE;
+		} else {
+			nmea_reset(np);
+		}
+		break;
+	case NMEA_HAVE_PENULTIMATE:
+		if (c == '\n') {
+			return 0;
+		}
+		nmea_reset(np);
+		break;
+	}
+	return -1;
+}
+
+static void nmea_reset(struct nmea_parser *np)
+{
+	memset(np, 0, sizeof(*np));
+}
+
+static int nmea_scan_rmc(struct nmea_parser *np, struct nmea_rmc *result)
+{
+	int cnt, i, msec = 0;
+	char *ptr, status;
+	uint8_t checksum;
+	struct tm tm;
+
+	pr_debug("nmea sentence: %s", np->sentence);
+	cnt = sscanf(np->payload_checksum, "%02hhx", &checksum);
+	if (cnt != 1) {
+		return -1;
+	}
+	if (checksum != np->checksum) {
+		pr_err("checksum mismatch 0x%02hhx != 0x%02hhx on %s",
+		       checksum, np->checksum, np->sentence);
+		return -1;
+	}
+	cnt = sscanf(np->sentence,
+		     "G%*cRMC,%2d%2d%2d.%d,%c",
+		     &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &msec, &status);
+	if (cnt != 5) {
+		cnt = sscanf(np->sentence,
+			     "G%*cRMC,%2d%2d%2d,%c",
+			     &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &status);
+		if (cnt != 4) {
+			return -1;
+		}
+	}
+	ptr = np->sentence;
+	for (i = 0; i < 9; i++) {
+		ptr = strchr(ptr, ',');
+		if (!ptr) {
+			return -1;
+		}
+		ptr++;
+	}
+	cnt = sscanf(ptr, "%2d%2d%2d", &tm.tm_mday, &tm.tm_mon, &tm.tm_year);
+	if (cnt != 3) {
+		return -1;
+	}
+	tm.tm_year += 100;
+	tm.tm_mon--;
+	result->ts.tv_sec = mktime(&tm);
+	result->ts.tv_nsec = msec * 1000000UL;
+	result->fix_valid = status == 'A' ? true : false;
+	return 0;
+}
+
+int nmea_parse(struct nmea_parser *np, const char *ptr, int buflen,
+	       struct nmea_rmc *result, int *parsed)
+{
+	int count = 0;
+	while (buflen) {
+		if (!nmea_parse_symbol(np, *ptr)) {
+			if (!nmea_scan_rmc(np, result)) {
+				*parsed = count + 1;
+				return 0;
+			}
+			nmea_reset(np);
+		}
+		buflen--;
+		count++;
+		ptr++;
+	}
+	*parsed = count;
+	return -1;
+}
+
+struct nmea_parser *nmea_parser_create(void)
+{
+	struct nmea_parser *np;
+	np = malloc(sizeof(*np));
+	if (!np) {
+		return NULL;
+	}
+	nmea_reset(np);
+	/* Ensure that mktime(3) returns a value in the UTC time scale. */
+	setenv("TZ", "UTC", 1);
+	return np;
+}
+
+void nmea_parser_destroy(struct nmea_parser *np)
+{
+	free(np);
+}
diff --git a/nmea.h b/nmea.h
new file mode 100644
index 0000000..4f0c152
--- /dev/null
+++ b/nmea.h
@@ -0,0 +1,44 @@
+/**
+ * @file nmea.h
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_NMEA_H
+#define HAVE_NMEA_H
+
+#include <stdbool.h>
+#include <time.h>
+
+/** Opaque type. */
+struct nmea_parser;
+
+struct nmea_rmc {
+	struct timespec ts;
+	bool fix_valid;
+};
+
+/**
+ * Parses NMEA RMC sentences out of a given buffer.
+ * @param np		Pointer obtained via nmea_parser_create().
+ * @param buf		Pointer to the data to be parsed.
+ * @param buflen	Length of 'buf' in bytes.
+ * @param rmc		Pointer to hold the result.
+ * @param parsed	Returns the number of bytes parsed, possibly less than buflen.
+ * @return		Zero on success, non-zero otherwise.
+ */
+int nmea_parse(struct nmea_parser *np, const char *buf, int buflen,
+	       struct nmea_rmc *rmc, int *parsed);
+
+/**
+ * Creates an instance of an NMEA parser.
+ * @return	Pointer to a new instance on success, NULL otherwise.
+ */
+struct nmea_parser *nmea_parser_create(void);
+
+/**
+ * Destroys an NMEA parser instance.
+ * @param np	Pointer obtained via nmea_parser_create().
+ */
+void nmea_parser_destroy(struct nmea_parser *np);
+
+#endif
diff --git a/serial.c b/serial.c
new file mode 100644
index 0000000..29cef0c
--- /dev/null
+++ b/serial.c
@@ -0,0 +1,96 @@
+/**
+ * @file serial.c
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <termios.h>
+
+#include "print.h"
+#include "serial.h"
+
+#define CANONICAL 1
+
+static int open_serial_baud(const char *name, tcflag_t baud, int icrnl, int hwfc)
+{
+	struct termios nterm;
+	int fd;
+
+	fd = open(name, O_RDWR | O_NOCTTY);
+	if (fd < 0) {
+		pr_err("cannot open %s : %m", name);
+		return fd;
+	}
+	memset(&nterm, 0, sizeof(nterm));
+
+	/* Input Modes */
+	nterm.c_iflag = IGNPAR; /* Ignore framing errors and parity errors */
+	if (icrnl) {
+		/* Translate carriage return to newline on input */
+		nterm.c_iflag |= ICRNL;
+	}
+
+	/* Output Modes */
+	nterm.c_oflag = 0;
+
+	/* Control Modes */
+	nterm.c_cflag = baud;
+	nterm.c_cflag |= CS8;    /* Character size */
+	nterm.c_cflag |= CLOCAL; /* Ignore modem control lines */
+	nterm.c_cflag |= CREAD;  /* Enable receiver */
+	if (hwfc) {
+		/* Enable RTS/CTS (hardware) flow control */
+		nterm.c_cflag |= CRTSCTS;
+	}
+
+	/* Local Modes */
+	if (CANONICAL) {
+		nterm.c_lflag = ICANON; /* Enable canonical mode */
+	}
+
+	nterm.c_cc[VTIME] = 10;   /* timeout is 10 deciseconds */
+	nterm.c_cc[VMIN] = 1;     /* blocking read until N chars received */
+	tcflush(fd, TCIFLUSH);
+	tcsetattr(fd, TCSANOW, &nterm);
+	return fd;
+}
+
+int serial_open(const char *name, int bps, int icrnl, int hwfc)
+{
+	tcflag_t baud;
+
+	switch (bps) {
+	case 1200:
+		baud = B1200;
+		break;
+	case 1800:
+		baud = B1800;
+		break;
+	case 2400:
+		baud = B2400;
+		break;
+	case 4800:
+		baud = B4800;
+		break;
+	case 9600:
+		baud = B9600;
+		break;
+	case 19200:
+		baud = B19200;
+		break;
+	case 38400:
+		baud = B38400;
+		break;
+	case 57600:
+		baud = B57600;
+		break;
+	case 115200:
+		baud = B115200;
+		break;
+	default:
+		return -1;
+	}
+	return open_serial_baud(name, baud, icrnl, hwfc);
+}
diff --git a/serial.h b/serial.h
new file mode 100644
index 0000000..6a7d8a1
--- /dev/null
+++ b/serial.h
@@ -0,0 +1,19 @@
+/**
+ * @file serial.h
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_SERIAL_H
+#define HAVE_SERIAL_H
+
+/**
+ * Opens a serial port device.
+ * @param name		Serial port device to open.
+ * @param bps		Baud rate in bits per second.
+ * @param icrnl		Pass 1 to map CR to NL on input, zero otherwise.
+ * @param hwfc		Pass 1 to enable hardware flow control, zero otherwise.
+ * @return		An open file descriptor on success, -1 otherwise.
+ */
+int serial_open(const char *name, int bps, int icrnl, int hwfc);
+
+#endif
diff --git a/sock.c b/sock.c
new file mode 100644
index 0000000..89b3d71
--- /dev/null
+++ b/sock.c
@@ -0,0 +1,58 @@
+/**
+ * @file sock.c
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <netdb.h>
+#include <netinet/tcp.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "print.h"
+#include "sock.h"
+
+typedef void *so_t;
+
+int sock_open(const char *server, const char *port)
+{
+	int i, err, family[2] = { AF_INET, AF_INET6 }, fd;
+	struct addrinfo	hints, *result = NULL;
+	socklen_t addrlen;
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_flags = AI_CANONNAME;
+	hints.ai_socktype = SOCK_STREAM;
+
+	for (i = 0; i < 2; i++) {
+		hints.ai_family = family[i];
+		err = getaddrinfo(server, port, &hints, &result);
+		if (err) {
+			pr_debug("%s: getaddrinfo failed family %d: %s",
+				 __func__, hints.ai_family, gai_strerror(err));
+			result = NULL;
+		} else {
+			break;
+		}
+	}
+	if (!result) {
+		return -1;
+	}
+
+	addrlen = (socklen_t) result->ai_addrlen;
+	pr_debug("%s: connecting to server %s canonical %s",
+		 __func__, server, result->ai_canonname);
+
+	fd = socket(result->ai_family, SOCK_STREAM, result->ai_protocol);
+	if (fd < 0) {
+		pr_err("%s: socket failed: %m", __func__);
+		goto failed;
+	}
+	if (connect(fd, result->ai_addr, addrlen) < 0) {
+		pr_err("%s: connect failed: %m", __func__);
+		close(fd);
+		fd = -1;
+	}
+failed:
+	freeaddrinfo(result);
+	return fd;
+}
diff --git a/sock.h b/sock.h
new file mode 100644
index 0000000..fe5aa78
--- /dev/null
+++ b/sock.h
@@ -0,0 +1,17 @@
+/**
+ * @file sock.h
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_SOCK_H
+#define HAVE_SOCK_H
+
+/**
+ * Opens a socket connected to a given remote address.
+ * @param server	Host name or IP address of the server.
+ * @param port		Port on the server with which to connect.
+ * @return		An open file descriptor on success, -1 otherwise.
+ */
+int sock_open(const char *server, const char *port);
+
+#endif
diff --git a/ts2phc.c b/ts2phc.c
index fe7fb3f..2342858 100644
--- a/ts2phc.c
+++ b/ts2phc.c
@@ -47,6 +47,7 @@ static void usage(char *progname)
 		"                    generic   - an external 1-PPS without ToD information\n"
 		"                    /dev/ptp0 - a local PTP Hardware Clock (PHC)\n"
 		"                    eth0      - a local PTP Hardware Clock (PHC)\n"
+		"                    nmea      - a gps device connected by serial port or network\n"
 		" -v             prints the software version and exits\n"
 		"\n",
 		progname);
@@ -183,6 +184,8 @@ int main(int argc, char *argv[])
 
 	if (!strcasecmp(pps_source, "generic")) {
 		pps_type = TS2PHC_MASTER_GENERIC;
+	} else if (!strcasecmp(pps_source, "nmea")) {
+		pps_type = TS2PHC_MASTER_NMEA;
 	} else {
 		pps_type = TS2PHC_MASTER_PHC;
 	}
diff --git a/ts2phc_master.c b/ts2phc_master.c
index 895a0f8..9283580 100644
--- a/ts2phc_master.c
+++ b/ts2phc_master.c
@@ -5,6 +5,7 @@
  */
 #include "ts2phc_generic_master.h"
 #include "ts2phc_master_private.h"
+#include "ts2phc_nmea_master.h"
 #include "ts2phc_phc_master.h"
 
 struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
@@ -17,6 +18,7 @@ struct ts2phc_master *ts2phc_master_create(struct config *cfg, const char *dev,
 		master = ts2phc_generic_master_create(cfg, dev);
 		break;
 	case TS2PHC_MASTER_NMEA:
+		master = ts2phc_nmea_master_create(cfg, dev);
 		break;
 	case TS2PHC_MASTER_PHC:
 		master = ts2phc_phc_master_create(cfg, dev);
diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
new file mode 100644
index 0000000..2b9af3b
--- /dev/null
+++ b/ts2phc_nmea_master.c
@@ -0,0 +1,227 @@
+/**
+ * @file ts2phc_nmea_master.c
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <poll.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "config.h"
+#include "lstab.h"
+#include "missing.h"
+#include "nmea.h"
+#include "print.h"
+#include "serial.h"
+#include "sock.h"
+#include "tmv.h"
+#include "ts2phc_master_private.h"
+#include "ts2phc_nmea_master.h"
+#include "util.h"
+
+#define BAUD		9600
+#define NMEA_TMO	2000 /*milliseconds*/
+
+struct ts2phc_nmea_master {
+	struct ts2phc_master master;
+	struct config *config;
+	struct lstab *lstab;
+	pthread_t worker;
+	/* Protects anonymous struct fields, below, from concurrent access. */
+	pthread_mutex_t mutex;
+	struct {
+		struct timespec local_monotime;
+		struct timespec local_utctime;
+		struct timespec rmc_utctime;
+		bool rmc_fix_valid;
+	};
+};
+
+static int open_nmea_connection(const char *host, const char *port,
+				const char *serialport)
+{
+	int fd;
+
+	if (host[0] && port[0]) {
+		fd = sock_open(host, port);
+		if (fd == -1) {
+			pr_err("failed to open nmea source %s:%s", host, port);
+		}
+		return fd;
+	}
+	fd = serial_open(serialport, BAUD, 0, 0);
+	if (fd == -1) {
+		pr_err("failed to open nmea source %s", serialport);
+	}
+	return fd;
+}
+
+static void *monitor_nmea_status(void *arg)
+{
+	struct nmea_parser *np = nmea_parser_create();
+	struct pollfd pfd = { -1, POLLIN | POLLPRI };
+	char *host, input[256], *port, *ptr, *uart;
+	struct ts2phc_nmea_master *master = arg;
+	struct timespec rxtime, tmo = { 2, 0 };
+	int cnt, num, parsed;
+	struct nmea_rmc rmc;
+	struct timex ntx;
+
+	if (!np) {
+		pr_err("failed to create NMEA parser");
+		return NULL;
+	}
+	host = config_get_string(master->config, NULL, "ts2phc.nmea_remote_host");
+	port = config_get_string(master->config, NULL, "ts2phc.nmea_remote_port");
+	uart = config_get_string(master->config, NULL, "ts2phc.nmea_serialport");
+	memset(&ntx, 0, sizeof(ntx));
+	ntx.modes = ADJ_NANO;
+
+	while (is_running()) {
+		if (pfd.fd == -1) {
+			pfd.fd = open_nmea_connection(host, port, uart);
+			if (pfd.fd == -1) {
+				clock_nanosleep(CLOCK_MONOTONIC, 0, &tmo, NULL);
+				continue;
+			}
+		}
+		num = poll(&pfd, 1, NMEA_TMO);
+		clock_gettime(CLOCK_MONOTONIC, &rxtime);
+		adjtimex(&ntx);
+		if (num < 0) {
+			pr_err("poll failed");
+			break;
+		}
+		if (!num) {
+			pr_err("nmea source timed out");
+			close(pfd.fd);
+			pfd.fd = -1;
+			continue;
+		}
+		if (pfd.revents & POLLERR) {
+			pr_err("nmea source socket error");
+			close(pfd.fd);
+			pfd.fd = -1;
+			continue;
+		}
+		if (!(pfd.revents & (POLLIN | POLLPRI))) {
+			continue;
+		}
+		cnt = read(pfd.fd, input, sizeof(input));
+		if (cnt < 0) {
+			pr_err("failed to read from nmea source");
+			close(pfd.fd);
+			pfd.fd = -1;
+			continue;
+		}
+		ptr = input;
+		do {
+			if (!nmea_parse(np, ptr, cnt, &rmc, &parsed)) {
+				pthread_mutex_lock(&master->mutex);
+				master->local_monotime = rxtime;
+				master->local_utctime.tv_sec = ntx.time.tv_sec;
+				master->local_utctime.tv_nsec = ntx.time.tv_usec;
+				master->rmc_utctime = rmc.ts;
+				master->rmc_fix_valid = rmc.fix_valid;
+				pthread_mutex_unlock(&master->mutex);
+			}
+			cnt -= parsed;
+			ptr += parsed;
+		} while (cnt);
+	}
+
+	nmea_parser_destroy(np);
+	if (pfd.fd != -1) {
+		close(pfd.fd);
+	}
+	return NULL;
+}
+
+static void ts2phc_nmea_master_destroy(struct ts2phc_master *master)
+{
+	struct ts2phc_nmea_master *m =
+		container_of(master, struct ts2phc_nmea_master, master);
+	pthread_join(m->worker, NULL);
+	pthread_mutex_destroy(&m->mutex);
+	lstab_destroy(m->lstab);
+	free(m);
+}
+
+static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
+					 struct timespec *ts)
+{
+	struct ts2phc_nmea_master *m =
+		container_of(master, struct ts2phc_nmea_master, master);
+	tmv_t delay_t1, delay_t2, local_t1, local_t2, rmc;
+	int lstab_error = 0, tai_offset = 0;
+	enum lstab_result result;
+	struct timespec now;
+	int64_t utc_time;
+	bool fix_valid;
+
+	clock_gettime(CLOCK_MONOTONIC, &now);
+	local_t2 = timespec_to_tmv(now);
+
+	pthread_mutex_lock(&m->mutex);
+
+	local_t1 = timespec_to_tmv(m->local_monotime);
+	delay_t2 = timespec_to_tmv(m->local_utctime);
+	rmc = timespec_to_tmv(m->rmc_utctime);
+	fix_valid = m->rmc_fix_valid;
+
+	pthread_mutex_unlock(&m->mutex);
+
+	delay_t1 = rmc;
+	pr_debug("nmea delay: %" PRId64 " ns",
+		 tmv_to_nanoseconds(tmv_sub(delay_t2, delay_t1)));
+
+	//
+	// TODO - check that (local_t2 - local_t1) is smaller than X.
+	//
+	rmc = tmv_add(rmc, tmv_sub(local_t2, local_t1));
+	utc_time = tmv_to_nanoseconds(rmc);
+	*ts = tmv_to_timespec(rmc);
+
+	result = lstab_utc2tai(m->lstab, utc_time, &tai_offset);
+	switch (result) {
+	case LSTAB_OK:
+		lstab_error = 0;
+		break;
+	case LSTAB_UNKNOWN:
+	case LSTAB_AMBIGUOUS:
+		lstab_error = -1;
+		break;
+	}
+	ts->tv_sec += tai_offset;
+
+	return fix_valid ? lstab_error : -1;
+}
+
+struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *dev)
+{
+	struct ts2phc_nmea_master *master;
+	const char *leapfile = NULL;	// TODO - read from config.
+	int err;
+
+	master = calloc(1, sizeof(*master));
+	if (!master) {
+		return NULL;
+	}
+	master->lstab = lstab_create(leapfile);
+	if (!master->lstab) {
+		return NULL;
+	}
+	master->master.destroy = ts2phc_nmea_master_destroy;
+	master->master.getppstime = ts2phc_nmea_master_getppstime;
+	master->config = cfg;
+	pthread_mutex_init(&master->mutex, NULL);
+	err = pthread_create(&master->worker, NULL, monitor_nmea_status, master);
+	if (err) {
+		pr_err("failed to create worker thread: %s", strerror(err));
+		free(master);
+		return NULL;
+	}
+
+	return &master->master;
+}
diff --git a/ts2phc_nmea_master.h b/ts2phc_nmea_master.h
new file mode 100644
index 0000000..7430e20
--- /dev/null
+++ b/ts2phc_nmea_master.h
@@ -0,0 +1,13 @@
+/**
+ * @file ts2phc_nmea_master.h
+ * @note Copyright (C) 2019 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_TS2PHC_NMEA_MASTER_H
+#define HAVE_TS2PHC_NMEA_MASTER_H
+
+#include "ts2phc_master.h"
+
+struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg,
+						const char *dev);
+#endif
-- 
2.17.1


From acd142964586b5c562bf139700378bf3be05a98a Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 23 Dec 2019 22:37:22 -0800
Subject: [PATCH 122/173] Add documentation for the ts2phc program.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc.8 | 217 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 217 insertions(+)
 create mode 100644 ts2phc.8

diff --git a/ts2phc.8 b/ts2phc.8
new file mode 100644
index 0000000..07a4026
--- /dev/null
+++ b/ts2phc.8
@@ -0,0 +1,217 @@
+.TH TS2PHC 8 "December 2019" "linuxptp"
+.SH NAME
+ts2phc - Synchronizes one or more PTP Hardware Clocks using external time stamps.
+
+.SH SYNOPSIS
+.B ts2phc
+[
+.B \-hmqv
+] [
+.BI \-c " device|name"
+] [
+.BI \-f " config"
+] [
+.BI \-l " print-level"
+] [
+.BI \-s " device|name"
+] [
+.I long-options
+]
+.I .\|.\|.
+
+.SH DESCRIPTION
+.B ts2phc
+synchronizes PTP Hardware Clocks (PHC) to external time stamp signals.
+A single source may be used to distribute time to one or more PHC devices.
+
+.SH OPTIONS
+.TP
+.BI \-c " device|name"
+Specifies a PHC slave clock to be synchronized.
+The clock may be identified by its character device (like /dev/ptp0)
+or its associated network interface (like eth0).
+This option may be given multiple times.
+.TP
+.BI \-f " config"
+Read configuration from the specified file.
+No configuration file is read by default.
+.TP
+.BI \-h
+Displays the command line help summary.
+.TP
+.BI \-l " print-level"
+Sets the maximum syslog level of messages which should be printed or
+sent to the system logger. The default is 6 (LOG_INFO).
+.TP
+.B \-m
+Prints log messages to the standard output.
+.TP
+.B \-q
+Prevents sending log messages to the system logger.
+.TP
+.BI \-s " device|name"
+Specifies the source of the PPS signal.
+Use the key word "generic" for an external 1-PPS without ToD information.
+When using a master PHC, the clock may be identified by its character
+device (like /dev/ptp0) or its associated network interface (like
+eth0).
+Use the key word "nmea" for an external 1-PPS from a GPS providing ToD
+information via the RMC NMEA sentence.
+.TP
+.B \-v
+Prints the software version and exits.
+
+.SH LONG OPTIONS
+
+Each and every configuration file option (see below) may also appear
+as a "long" style command line argument.  For example, the use_syslog
+option may be set using either of these two forms.
+
+.RS
+\f(CW\-\-use_syslog 1   \-\-use_syslog=1\fP
+.RE
+
+Option values given on the command line override values in the global
+section of the configuration file.
+
+.SH CONFIGURATION FILE
+
+The configuration file is divided into sections. Each section starts with a
+line containing its name enclosed in brackets and it follows with settings.
+Each setting is placed on a separate line, it contains the name of the
+option and the value separated by whitespace characters. Empty lines and lines
+starting with # are ignored.
+
+There are two different section types.
+
+.TP
+.B 1.
+The global section (indicated as
+.BR [global] )
+sets the program options and default slave clock options. Other
+sections are clock specific sections, and they override the default
+options.
+.TP
+.B 2.
+Slave clock sections give the name of the configured slave (e.g.
+.BR [eth0] ).
+Slave clocks specified in the configuration file need not be specified
+with the
+.B \-c
+command line option.
+
+.SH GLOBAL OPTIONS
+
+.TP
+.B first_step_threshold
+The maximum offset, specified in seconds, that the servo will correct
+by changing the clock frequency instead of stepping the clock. This is
+only applied on the first update. When set to 0.0, the servo will not
+step the clock on start.
+The default is 0.00002 (20 microseconds).
+.TP
+.B free_running
+When set to 1, no the slave clock will be adjusted.
+This option can be useful in test scenarios, for example to determine
+how well synchronized a group of local clocks are to each other.
+The default is 0 (adjust the slave clocks).
+.TP
+.B logging_level
+The maximum logging level of messages which should be printed.
+The default is 6 (LOG_INFO).
+.TP
+.B max_frequency
+The maximum allowed frequency adjustment of the clock in parts per
+billion.  This is an additional limit to the maximum allowed by the
+hardware. When set to 0, the hardware limit will be used.
+The default is 900000000 (90%).
+.TP
+.B message_tag
+The tag which is added to all messages printed to the standard output
+or system log.  The default is an empty string (which cannot be set in
+the configuration file as the option requires an argument).
+.TP
+.B step_threshold
+The maximum offset, specified in seconds, that the servo will correct
+by changing the clock frequency instead of stepping the clock. When
+set to 0.0, the servo will never step the clock except on start.
+The default is 0.0.
+.TP
+.B ts2phc.nmea_remote_host, ts2phc.nmea_remote_port
+Specifies the serial port character device providing ToD information
+when using the "nmea" PPS signal source.  Note that if these two
+options are both specified, then the given remote connection will be
+used in preference to the configured serial port.
+These options default to the empty string, that is, not specified.
+.TP
+.B ts2phc.nmea_serialport
+Specifies the serial port character device providing ToD information
+when using the "nmea" PPS signal source.  Note that if the options,
+ts2phc.nmea_remote_host and ts2phc.nmea_remote_port, are both
+specified, then the given remote connection will be used in preference
+to the configured serial port.
+The default is "/dev/ttyS0".
+.TP
+.B ts2phc.pulsewidth
+The expected pulse width of the external PPS signal in nanoseconds.
+When 'ts2phc.extts_polarity' is "both", the given pulse width is used
+to detect and discard the time stamp of the unwanted edge.
+The supported range is 1000000 to 990000000 nanoseconds.
+The default is 500000000 nanoseconds.
+.TP
+.B use_syslog
+Print messages to the system log if enabled.  The default is 1 (enabled).
+.TP
+.B verbose
+Print messages to the standard output if enabled.  The default is 0 (disabled).
+
+.SH SLAVE CLOCK OPTIONS
+
+.TP
+.B ts2phc.channel
+The external time stamping or periodic output channel to be used.
+Some PHC devices feature programmable pins and one or more time
+stamping channels.  This option allows selecting a particular channel
+to be used.  When using a PHC device as the PPS source, this option
+selects the periodic output channel.
+The default is channel 0.
+.TP
+.B ts2phc.extts_correction
+The value, in nanoseconds, to be added to each PPS time stamp.
+The default is 0 (no correction).
+.TP
+.B ts2phc.extts_polarity
+The polarity of the external PPS signal, either "rising" or "falling".
+Some PHC devices always time stamp both edges.  Setting this option to
+"both" will allow the ts2phc program to work with such devices by
+detecting and ignoring the unwanted edge.  In this case be sure to
+set 'ts2phc.pulsewidth' to the correct value.
+The default is "rising".
+.TP
+.B ts2phc.master
+Setting this option to 1 configures the given PHC device as the source
+of the PPS signal.
+The default is 0 for the slave role.
+.TP
+.B ts2phc.pin_index
+The pin index to be used.
+Some PHC devices feature programmable pins, and this option allows
+configuration of a particular pin for the external time stamping or
+periodic output function.
+The default is pin index 0.
+
+.SH WARNING
+
+Be cautious when sharing the same configuration file between ptp4l,
+phc2sys, and ts2phc.  Keep in mind that values specified in the
+configuration file take precedence over the default values.  If an
+option which is common to the other programs is set in the
+configuration file, then the value will be applied to all the programs
+using the file, and this might not be what is expected.
+
+It is recommended to use separate configuration files for ptp4l,
+phc2sys, and ts2phc in order to avoid any unexpected behavior.
+
+.SH SEE ALSO
+.BR phc2sys (8)
+.BR ptp4l (8)
-- 
2.17.1


From d4b97f497c49b65f6a37bf35c3b513bd4f18e7e6 Mon Sep 17 00:00:00 2001
From: Vincent Cheng <vincent.cheng.xh@renesas.com>
Date: Thu, 23 Jan 2020 14:07:22 -0500
Subject: [PATCH 123/173] Decouple servo state from automotive profile.

The logic for the Automotive Profile added a message interval update
mechanism that triggers whenever the servo enters the "stable locked"
state.  This SERVO_LOCKED_STABLE state is active when the
configuration option servo_offset_threshold is non-zero and
servo_offset_threshold criteria is satisfied.

However, in general, the state of the servo can and should be
independent of any profile specific optional behavior.  In particular,
the "stable locked" state will be used in the future to trigger other
kinds useful logic.  For example, an upcoming write phase mode feature
would like to take advantage of the SERVO_LOCKED_STABLE state to
trigger its activation.

This patch introduces a proper configuration option to enable
transmission of the message interval request that is specific to the
Automotive Profile.

Signed-off-by: Vincent Cheng <vincent.cheng.xh@renesas.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 config.c                     |  1 +
 configs/automotive-slave.cfg |  1 +
 configs/default.cfg          |  1 +
 port.c                       | 41 +++++++++++++++++-----------
 port_private.h               |  1 +
 ptp4l.8                      | 52 +++++++++++++++++++++---------------
 6 files changed, 60 insertions(+), 37 deletions(-)

diff --git a/config.c b/config.c
index 53ad788..0cbab4c 100644
--- a/config.c
+++ b/config.c
@@ -271,6 +271,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_STR("manufacturerIdentity", "00:00:00"),
 	GLOB_ITEM_INT("max_frequency", 900000000, 0, INT_MAX),
 	PORT_ITEM_INT("min_neighbor_prop_delay", -20000000, INT_MIN, -1),
+	PORT_ITEM_INT("msg_interval_request", 0, 0, 1),
 	PORT_ITEM_INT("neighborPropDelayThresh", 20000000, 0, INT_MAX),
 	PORT_ITEM_INT("net_sync_monitor", 0, 0, 1),
 	PORT_ITEM_ENU("network_transport", TRANS_UDP_IPV4, nw_trans_enu),
diff --git a/configs/automotive-slave.cfg b/configs/automotive-slave.cfg
index 8cc7221..0898660 100644
--- a/configs/automotive-slave.cfg
+++ b/configs/automotive-slave.cfg
@@ -33,5 +33,6 @@ ignore_source_id	1
 step_threshold          1
 operLogSyncInterval     0
 operLogPdelayReqInterval 2
+msg_interval_request     1
 servo_offset_threshold   30
 servo_num_offset_values  10
diff --git a/configs/default.cfg b/configs/default.cfg
index 119df7b..91f6aaa 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -77,6 +77,7 @@ max_frequency		900000000
 clock_servo		pi
 sanity_freq_limit	200000000
 ntpshm_segment		0
+msg_interval_request	0
 servo_num_offset_values 10
 servo_offset_threshold  0
 #
diff --git a/port.c b/port.c
index 6b87bc9..368c3b8 100644
--- a/port.c
+++ b/port.c
@@ -1131,6 +1131,30 @@ static void port_slave_priority_warning(struct port *p)
 	pr_warning("port %hu: defaultDS.priority1 probably misconfigured", n);
 }
 
+static void message_interval_request(struct port *p,
+				     enum servo_state last_state,
+				     Integer8 sync_interval)
+{
+	if (!p->msg_interval_request)
+		return;
+
+	if (last_state == SERVO_LOCKED) {
+		p->logPdelayReqInterval = p->operLogPdelayReqInterval;
+		p->logSyncInterval = p->operLogSyncInterval;
+		port_tx_interval_request(p, SIGNAL_NO_CHANGE,
+					 p->logSyncInterval,
+					 SIGNAL_NO_CHANGE);
+		port_dispatch(p, EV_MASTER_CLOCK_SELECTED, 0);
+	} else if (sync_interval != p->operLogSyncInterval) {
+		/*
+		 * The most likely reason for this to happen is the
+		 * master daemon re-initialized due to some fault.
+		 */
+		servo_reset(clock_servo(p->clock));
+		port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
+	}
+}
+
 static void port_synchronize(struct port *p,
 			     tmv_t ingress_ts,
 			     struct timestamp origin_ts,
@@ -1174,21 +1198,7 @@ static void port_synchronize(struct port *p,
 		port_dispatch(p, EV_MASTER_CLOCK_SELECTED, 0);
 		break;
 	case SERVO_LOCKED_STABLE:
-		if (last_state == SERVO_LOCKED) {
-			p->logPdelayReqInterval = p->operLogPdelayReqInterval;
-			p->logSyncInterval = p->operLogSyncInterval;
-			port_tx_interval_request(p, SIGNAL_NO_CHANGE,
-						 p->logSyncInterval,
-						 SIGNAL_NO_CHANGE);
-			port_dispatch(p, EV_MASTER_CLOCK_SELECTED, 0);
-		} else if (sync_interval != p->operLogSyncInterval) {
-			/*
-			 * The most likely reason for this to happen is the
-			 * master daemon re-initialized due to some fault.
-			 */
-			servo_reset(clock_servo(p->clock));
-			port_dispatch(p, EV_SYNCHRONIZATION_FAULT, 0);
-		}
+		message_interval_request(p, last_state, sync_interval);
 		break;
 	}
 }
@@ -3029,6 +3039,7 @@ struct port *port_open(const char *phc_device,
 	p->announce_span = transport == TRANS_UDS ? 0 : ANNOUNCE_SPAN;
 	p->follow_up_info = config_get_int(cfg, p->name, "follow_up_info");
 	p->freq_est_interval = config_get_int(cfg, p->name, "freq_est_interval");
+	p->msg_interval_request = config_get_int(cfg, p->name, "msg_interval_request");
 	p->net_sync_monitor = config_get_int(cfg, p->name, "net_sync_monitor");
 	p->path_trace_enabled = config_get_int(cfg, p->name, "path_trace_enabled");
 	p->tc_spanning_tree = config_get_int(cfg, p->name, "tc_spanning_tree");
diff --git a/port_private.h b/port_private.h
index bc16d95..82d1801 100644
--- a/port_private.h
+++ b/port_private.h
@@ -128,6 +128,7 @@ struct port {
 	int                 hybrid_e2e;
 	int                 master_only;
 	int                 match_transport_specific;
+	int                 msg_interval_request;
 	int                 min_neighbor_prop_delay;
 	int                 net_sync_monitor;
 	int                 path_trace_enabled;
diff --git a/ptp4l.8 b/ptp4l.8
index c4e1464..79bc9d9 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -162,11 +162,12 @@ accuracy of the local clock. It's specified as a power of two in seconds.
 The default is 0 (1 second).
 .TP
 .B operLogSyncInterval
-The mean time interval between Sync messages. This value is only used by the
-slave device when interval_update_timer is enabled. Slave will send this
-interval to the master to switch to. This is done via a signaling message after
-interval_update_timer expires. It's specified as a power of two in seconds. The
-default value is 0 (1 second).
+The Sync message interval to be requested once the clock enters the
+SERVO_LOCKED_STABLE state.  If the 'msg_interval_request' option is
+set, then the local slave port will request the remote master to
+switch to the given message rate via a signaling message containing a
+Message interval request TLV.  This option is specified as a power of
+two in seconds, and default value is 0 (1 second).
 .TP
 .B logMinDelayReqInterval
 The minimum permitted mean time interval between Delay_Req messages. A shorter
@@ -180,11 +181,11 @@ specified as a power of two in seconds.
 The default is 0 (1 second).
 .TP
 .B operLogPdelayReqInterval
-The mean time interval between Pdelay Request messages. This value is only used
-by the slave device when interval_update_timer is enabled. Slave will switch to
-the interval specified by this config option after the interval_update_timer
-expires. It's specified as a power of two in seconds. The default value is 0 (1
-second).
+The Pdelay Request messages interval to be used once the clock enters
+the SERVO_LOCKED_STABLE state.  If the 'msg_interval_request' option
+is set, then the local slave port will adopt this rate when the local
+clock enters the "locked stable" state.  This option is specified as a
+power of two in seconds, and the default value is 0 (1 second).
 .TP
 .B inhibit_delay_req
 Don't send any delay requests. This will need the asCapable config option to be
@@ -740,21 +741,28 @@ messages. This is useful when the announce messages are disabled in the master
 and the slave does not have any way to know it's identity. The default is 0
 (disabled).
 .TP
+.B msg_interval_request
+This option, when set, will trigger an adjustment to the Sync and peer
+delay request message intervals when the clock servo transitions into
+the SERVO_LOCKED_STABLE state.  The Sync interval will be adjusted via
+the signaling mechanism while the pdelay request interval is simply
+adjusted locally.  The values to use for the new Sync and peer delay
+request intervals are specified by the operLogSyncInterval and
+operLogPdelayReqInterval options, respectively.
+The default value of msg_interval_request is 0 (disabled).
+.TP
 .B servo_num_offset_values
-The number of offset values calculated in previously received Sync messages to
-consider when adjusting the Sync and Pdelay request intervals. More information
-provided in the description of 'offset_threshold'. The default value is 10.
+The number of offset values considered in order to transition from the
+SERVO_LOCKED to the SERVO_LOCKED_STABLE state.
+The transition occurs once the last 'servo_num_offset_values' offsets
+are all below the 'servo_offset_threshold' value.
+The default value is 10.
 .TP
 .B servo_offset_threshold
-This value is used by the slave for adjusting the intervals for Sync and Pdelay
-request messages. The slave will check the last 'num_offset_values' offsets and
-if all those offsets are less than the offset_threshold, it will adjust both
-the intervals. The Sync interval is adjusted via the signaling mechanism and
-the pdelay request interval is just adjusted locally. The new values to use for
-sync message intervals and pdelay request intervals can be indicated by
-operLogSyncInterval and operLogPdelayReqInterval respectively. This mechanism
-is currently only supported when BMCA == 'noop'. The default
-value of offset_threshold is 0 (disabled).
+The offset threshold used in order to transition from the SERVO_LOCKED
+to the SERVO_LOCKED_STABLE state.  The transition occurs once the last
+'servo_num_offset_values' offsets are all below the threshold value.
+The default value of offset_threshold is 0 (disabled).
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From 7df88afab97b68ce4cc1842c494904d1bd389aaa Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 4 May 2020 11:07:57 -0700
Subject: [PATCH 124/173] Add support for write phase mode.

Recently the Linux kernel's PTP Hardware Clock interface was expanded
to include a "write phase" mode where the clock servo in implemented
in hardware.  This mode hearkens back to the tradition ntp_adjtime
interface, passing a measured offset into the kernel's servo.

This patch adds a new configuration option and logic to support the
write phase mode.

Because the hardware's adjustment bandwidth may be limited, this mode
is only activated when the servo reaches SERVO_LOCKED_STABLE state, in
order to achieve reasonably fast locking times.  Users may control the
SERVO_LOCKED_STABLE state by configuring 'servo_offset_threshold' and
'servo_num_offset_values' accordingly.

Example configuration file highlights:

  unicast_listen          1
  logSyncInterval         0
  logMinDelayReqInterval  0
  first_step_threshold    0.001000000
  step_threshold          0
  clock_servo             pi

  write_phase_mode        1
  servo_offset_threshold  50
  servo_num_offset_values 10
  tsproc_mode             raw

Signed-off-by: Vincent Cheng <vincent.cheng.xh@renesas.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c             | 60 +++++++++++++++++++++++++++++++--------------
 clockadj.c          | 12 +++++++++
 clockadj.h          |  7 ++++++
 config.c            |  1 +
 configs/default.cfg |  1 +
 missing.h           | 13 +++++++---
 phc.c               | 10 ++++++++
 phc.h               | 10 ++++++++
 ptp4l.8             |  6 +++++
 9 files changed, 99 insertions(+), 21 deletions(-)

diff --git a/clock.c b/clock.c
index b928f56..a6e31e6 100644
--- a/clock.c
+++ b/clock.c
@@ -22,6 +22,7 @@
 #include <poll.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/ioctl.h>
 #include <sys/queue.h>
 
 #include "address.h"
@@ -102,6 +103,7 @@ struct clock {
 	int sde;
 	int free_running;
 	int freq_est_interval;
+	int write_phase_mode;
 	int grand_master_capable; /* for 802.1AS only */
 	int utc_timescale;
 	int utc_offset_set;
@@ -1028,6 +1030,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	c->config = config;
 	c->free_running = config_get_int(config, NULL, "free_running");
 	c->freq_est_interval = config_get_int(config, NULL, "freq_est_interval");
+	c->write_phase_mode = config_get_int(config, NULL, "write_phase_mode");
 	c->grand_master_capable = config_get_int(config, NULL, "gmCapable");
 	c->kernel_leap = config_get_int(config, NULL, "kernel_leap");
 	c->utc_offset = config_get_int(config, NULL, "utc_offset");
@@ -1076,6 +1079,12 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 		   and return 0. Set the frequency back to make sure fadj is
 		   the actual frequency of the clock. */
 		clockadj_set_freq(c->clkid, fadj);
+
+		/* Disable write phase mode if not implemented by driver */
+		if (c->write_phase_mode && !phc_has_writephase(c->clkid)) {
+			pr_err("clock does not support write phase mode");
+			return NULL;
+		}
 	}
 	c->servo = servo_create(c->config, servo, -fadj, max_adj, sw_ts);
 	if (!c->servo) {
@@ -1632,10 +1641,22 @@ int clock_switch_phc(struct clock *c, int phc_index)
 	return 0;
 }
 
+static void clock_synchronize_locked(struct clock *c, double adj)
+{
+	clockadj_set_freq(c->clkid, -adj);
+	if (c->clkid == CLOCK_REALTIME) {
+		sysclk_set_sync();
+	}
+	if (c->sanity_check) {
+		clockcheck_set_freq(c->sanity_check, -adj);
+	}
+}
+
 enum servo_state clock_synchronize(struct clock *c, tmv_t ingress, tmv_t origin)
 {
-	double adj, weight;
 	enum servo_state state = SERVO_UNLOCKED;
+	double adj, weight;
+	int64_t offset;
 
 	c->ingress_ts = ingress;
 
@@ -1659,19 +1680,11 @@ enum servo_state clock_synchronize(struct clock *c, tmv_t ingress, tmv_t origin)
 		return clock_no_adjust(c, ingress, origin);
 	}
 
-	adj = servo_sample(c->servo, tmv_to_nanoseconds(c->master_offset),
-			   tmv_to_nanoseconds(ingress), weight, &state);
+	offset = tmv_to_nanoseconds(c->master_offset);
+	adj = servo_sample(c->servo, offset, tmv_to_nanoseconds(ingress),
+			   weight, &state);
 	c->servo_state = state;
 
-	if (c->stats.max_count > 1) {
-		clock_stats_update(&c->stats, tmv_dbl(c->master_offset), adj);
-	} else {
-		pr_info("master offset %10" PRId64 " s%d freq %+7.0f "
-			"path delay %9" PRId64,
-			tmv_to_nanoseconds(c->master_offset), state, adj,
-			tmv_to_nanoseconds(c->path_delay));
-	}
-
 	tsproc_set_clock_rate_ratio(c->tsproc, clock_rate_ratio(c));
 
 	switch (state) {
@@ -1689,16 +1702,27 @@ enum servo_state clock_synchronize(struct clock *c, tmv_t ingress, tmv_t origin)
 		tsproc_reset(c->tsproc, 0);
 		break;
 	case SERVO_LOCKED:
+		clock_synchronize_locked(c, adj);
+		break;
 	case SERVO_LOCKED_STABLE:
-		clockadj_set_freq(c->clkid, -adj);
-		if (c->clkid == CLOCK_REALTIME) {
-			sysclk_set_sync();
-		}
-		if (c->sanity_check) {
-			clockcheck_set_freq(c->sanity_check, -adj);
+		if (c->write_phase_mode) {
+			clockadj_set_phase(c->clkid, -offset);
+			adj = 0;
+		} else {
+			clock_synchronize_locked(c, adj);
 		}
 		break;
 	}
+
+	if (c->stats.max_count > 1) {
+		clock_stats_update(&c->stats, tmv_dbl(c->master_offset), adj);
+	} else {
+		pr_info("master offset %10" PRId64 " s%d freq %+7.0f "
+			"path delay %9" PRId64,
+			tmv_to_nanoseconds(c->master_offset), state, adj,
+			tmv_to_nanoseconds(c->path_delay));
+	}
+
 	return state;
 }
 
diff --git a/clockadj.c b/clockadj.c
index 0485d8c..b5c78cd 100644
--- a/clockadj.c
+++ b/clockadj.c
@@ -79,6 +79,18 @@ double clockadj_get_freq(clockid_t clkid)
 	return f;
 }
 
+void clockadj_set_phase(clockid_t clkid, long offset)
+{
+	struct timex tx;
+	memset(&tx, 0, sizeof(tx));
+
+	tx.modes = ADJ_OFFSET | ADJ_NANO;
+	tx.offset = offset;
+	if (clock_adjtime(clkid, &tx) < 0) {
+		pr_err("failed to set the clock offset: %m");
+	}
+}
+
 void clockadj_step(clockid_t clkid, int64_t step)
 {
 	struct timex tx;
diff --git a/clockadj.h b/clockadj.h
index 4ea98c1..43325c8 100644
--- a/clockadj.h
+++ b/clockadj.h
@@ -43,6 +43,13 @@ void clockadj_set_freq(clockid_t clkid, double freq);
  */
 double clockadj_get_freq(clockid_t clkid);
 
+/**
+ * Set clock's phase offset.
+ * @param clkid  A clock ID obtained using phc_open() or CLOCK_REALTIME.
+ * @param offset The phase offset in nanoseconds.
+ */
+void clockadj_set_phase(clockid_t clkid, long offset);
+
 /**
  * Step clock's time.
  * @param clkid A clock ID obtained using phc_open() or CLOCK_REALTIME.
diff --git a/config.c b/config.c
index 0cbab4c..269183c 100644
--- a/config.c
+++ b/config.c
@@ -328,6 +328,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_STR("userDescription", ""),
 	GLOB_ITEM_INT("utc_offset", CURRENT_UTC_OFFSET, 0, INT_MAX),
 	GLOB_ITEM_INT("verbose", 0, 0, 1),
+	GLOB_ITEM_INT("write_phase_mode", 0, 0, 1),
 };
 
 static struct unicast_master_table *current_uc_mtab;
diff --git a/configs/default.cfg b/configs/default.cfg
index 91f6aaa..8c19129 100644
--- a/configs/default.cfg
+++ b/configs/default.cfg
@@ -80,6 +80,7 @@ ntpshm_segment		0
 msg_interval_request	0
 servo_num_offset_values 10
 servo_offset_threshold  0
+write_phase_mode	0
 #
 # Transport options
 #
diff --git a/missing.h b/missing.h
index 4726803..bc708cb 100644
--- a/missing.h
+++ b/missing.h
@@ -24,6 +24,7 @@
 #define HAVE_MISSING_H
 
 #include <linux/ptp_clock.h>
+#include <linux/version.h>
 #include <sys/syscall.h>
 #include <sys/timex.h>
 #include <time.h>
@@ -75,9 +76,9 @@ enum {
 #define PTP_PEROUT_REQUEST2 PTP_PEROUT_REQUEST
 #endif
 
-#ifndef PTP_PIN_SETFUNC
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0)
 
-/* from Linux kernel version 5.4 */
+/* from upcoming Linux kernel version 5.8 */
 struct compat_ptp_clock_caps {
 	int max_adj;   /* Maximum frequency adjustment in parts per billon. */
 	int n_alarm;   /* Number of programmable alarms. */
@@ -87,11 +88,17 @@ struct compat_ptp_clock_caps {
 	int n_pins;    /* Number of input/output pins. */
 	/* Whether the clock supports precise system-device cross timestamps */
 	int cross_timestamping;
-	int rsv[13];   /* Reserved for future use. */
+	/* Whether the clock supports adjust phase */
+	int adjust_phase;
+	int rsv[12];   /* Reserved for future use. */
 };
 
 #define ptp_clock_caps compat_ptp_clock_caps
 
+#endif /*LINUX_VERSION_CODE < 5.8*/
+
+#ifndef PTP_PIN_SETFUNC
+
 enum ptp_pin_function {
 	PTP_PF_NONE,
 	PTP_PF_EXTTS,
diff --git a/phc.c b/phc.c
index 14132db..37f6b9f 100644
--- a/phc.c
+++ b/phc.c
@@ -127,3 +127,13 @@ int phc_has_pps(clockid_t clkid)
 		return 0;
 	return caps.pps;
 }
+
+int phc_has_writephase(clockid_t clkid)
+{
+	struct ptp_clock_caps caps;
+
+	if (phc_get_caps(clkid, &caps)) {
+		return 0;
+	}
+	return caps.adjust_phase;
+}
diff --git a/phc.h b/phc.h
index 4dbc374..c48f906 100644
--- a/phc.h
+++ b/phc.h
@@ -77,4 +77,14 @@ int phc_pin_setfunc(clockid_t clkid, struct ptp_pin_desc *desc);
  */
 int phc_has_pps(clockid_t clkid);
 
+/**
+ * Checks whether the given PTP hardware clock device supports write phase mode.
+ *
+ * @param clkid A clock ID obtained using phc_open().
+ *
+ * @return Zero if write phase mode is not supported by the clock, non-zero
+ * otherwise.
+ */
+int phc_has_writephase(clockid_t clkid);
+
 #endif
diff --git a/ptp4l.8 b/ptp4l.8
index 79bc9d9..24ce10d 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -763,6 +763,12 @@ The offset threshold used in order to transition from the SERVO_LOCKED
 to the SERVO_LOCKED_STABLE state.  The transition occurs once the last
 'servo_num_offset_values' offsets are all below the threshold value.
 The default value of offset_threshold is 0 (disabled).
+.TP
+.B write_phase_mode
+This option enables using the "write phase" feature of a PTP Hardware
+Clock.  If supported by the device, this mode uses the hardware's
+built in phase offset control instead of frequency offset control.
+The default value is 0 (disabled).
 
 .SH UNICAST DISCOVERY OPTIONS
 
-- 
2.17.1


From b8194a177a63dbad148a813fbf99ea61948fc66c Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 5 May 2020 12:27:42 -0700
Subject: [PATCH 125/173] Implement the synchronization uncertain flag.

IEEE 1588 v2.1 and ITU G.8275.1/2 call for an optional "synchronization
uncertain" flag passed in Announce messages along with the other flags
from the time properties data set.  The value of the flag depends is a
logical OR function of the inputs from the remote master and the local
process.  This patch adds background support for handling the flag.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 50 ++++++++++++++++++++++++++++++++++++++++++++++----
 clock.h |  4 ++--
 msg.h   |  1 +
 port.c  | 12 ++++++------
 tlv.h   |  6 ++++++
 5 files changed, 61 insertions(+), 12 deletions(-)

diff --git a/clock.c b/clock.c
index a6e31e6..11082fe 100644
--- a/clock.c
+++ b/clock.c
@@ -103,6 +103,7 @@ struct clock {
 	int sde;
 	int free_running;
 	int freq_est_interval;
+	int local_sync_uncertain;
 	int write_phase_mode;
 	int grand_master_capable; /* for 802.1AS only */
 	int utc_timescale;
@@ -137,6 +138,7 @@ struct clock the_clock;
 static void handle_state_decision_event(struct clock *c);
 static int clock_resize_pollfd(struct clock *c, int new_nports);
 static void clock_remove_port(struct clock *c, struct port *p);
+static void clock_stats_display(struct clock_stats *s);
 
 static void remove_subscriber(struct clock_subscriber *s)
 {
@@ -446,6 +448,11 @@ static int clock_management_fill_response(struct clock *c, struct port *p,
 		clock_get_subscription(c, req, sen->bitmask, &sen->duration);
 		datalen = sizeof(*sen);
 		break;
+	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+		mtd = (struct management_tlv_datum *) tlv->data;
+		mtd->val = c->local_sync_uncertain;
+		datalen = sizeof(*mtd);
+		break;
 	default:
 		/* The caller should *not* respond to this message. */
 		tlv_extra_recycle(extra);
@@ -519,6 +526,21 @@ static int clock_management_set(struct clock *c, struct port *p,
 		clock_update_subscription(c, req, sen->bitmask, sen->duration);
 		respond = 1;
 		break;
+	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+		mtd = (struct management_tlv_datum *) tlv->data;
+		switch (mtd->val) {
+		case SYNC_UNCERTAIN_DONTCARE:
+		case SYNC_UNCERTAIN_FALSE:
+		case SYNC_UNCERTAIN_TRUE:
+			/* Display stats on change of local_sync_uncertain */
+			if (c->local_sync_uncertain != mtd->val
+			    && stats_get_num_values(c->stats.offset))
+				clock_stats_display(&c->stats);
+			c->local_sync_uncertain = mtd->val;
+			respond = 1;
+			break;
+		}
+		break;
 	}
 	if (respond && !clock_management_get_response(c, p, id, req))
 		pr_err("failed to send management set response");
@@ -528,14 +550,19 @@ static int clock_management_set(struct clock *c, struct port *p,
 static void clock_stats_update(struct clock_stats *s,
 			       double offset, double freq)
 {
-	struct stats_result offset_stats, freq_stats, delay_stats;
-
 	stats_add_value(s->offset, offset);
 	stats_add_value(s->freq, freq);
 
 	if (stats_get_num_values(s->offset) < s->max_count)
 		return;
 
+	clock_stats_display(s);
+}
+
+static void clock_stats_display(struct clock_stats *s)
+{
+	struct stats_result offset_stats, freq_stats, delay_stats;
+
 	stats_get_result(s->offset, &offset_stats);
 	stats_get_result(s->freq, &freq_stats);
 
@@ -1030,6 +1057,7 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	c->config = config;
 	c->free_running = config_get_int(config, NULL, "free_running");
 	c->freq_est_interval = config_get_int(config, NULL, "freq_est_interval");
+	c->local_sync_uncertain = SYNC_UNCERTAIN_DONTCARE;
 	c->write_phase_mode = config_get_int(config, NULL, "write_phase_mode");
 	c->grand_master_capable = config_get_int(config, NULL, "gmCapable");
 	c->kernel_leap = config_get_int(config, NULL, "kernel_leap");
@@ -1429,6 +1457,7 @@ int clock_manage(struct clock *c, struct port *p, struct ptp_message *msg)
 	case TLV_TIME_STATUS_NP:
 	case TLV_GRANDMASTER_SETTINGS_NP:
 	case TLV_SUBSCRIBE_EVENTS_NP:
+	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
 		clock_management_send_error(p, msg, TLV_NOT_SUPPORTED);
 		break;
 	default:
@@ -1751,9 +1780,22 @@ void clock_sync_interval(struct clock *c, int n)
 	servo_sync_interval(c->servo, n < 0 ? 1.0 / (1 << -n) : 1 << n);
 }
 
-struct timePropertiesDS *clock_time_properties(struct clock *c)
+struct timePropertiesDS clock_time_properties(struct clock *c)
 {
-	return &c->tds;
+	struct timePropertiesDS tds = c->tds;
+
+	switch (c->local_sync_uncertain) {
+	case SYNC_UNCERTAIN_DONTCARE:
+		tds.flags &= ~SYNC_UNCERTAIN;
+		break;
+	case SYNC_UNCERTAIN_FALSE:
+		/* Pass the upstream value, if any. */
+		break;
+	case SYNC_UNCERTAIN_TRUE:
+		tds.flags |= SYNC_UNCERTAIN;
+		break;
+	}
+	return tds;
 }
 
 void clock_update_time_properties(struct clock *c, struct timePropertiesDS tds)
diff --git a/clock.h b/clock.h
index 9d3133a..1256856 100644
--- a/clock.h
+++ b/clock.h
@@ -320,9 +320,9 @@ void clock_sync_interval(struct clock *c, int n);
 /**
  * Obtain a clock's time properties data set.
  * @param c  The clock instance.
- * @return   A pointer to the time properties data set of the clock.
+ * @return   A copy of the clock's time properties data set.
  */
-struct timePropertiesDS *clock_time_properties(struct clock *c);
+struct timePropertiesDS clock_time_properties(struct clock *c);
 
 /**
  * Update a clock's time properties data set.
diff --git a/msg.h b/msg.h
index c1294c2..e71d3ce 100644
--- a/msg.h
+++ b/msg.h
@@ -56,6 +56,7 @@
 #define PTP_TIMESCALE  (1<<3)
 #define TIME_TRACEABLE (1<<4)
 #define FREQ_TRACEABLE (1<<5)
+#define SYNC_UNCERTAIN (1<<6)
 
 /*
  * Signaling interval special values. For more info look at 802.1AS table 10-11
diff --git a/port.c b/port.c
index 368c3b8..6104061 100644
--- a/port.c
+++ b/port.c
@@ -412,7 +412,7 @@ static int follow_up_info_append(struct ptp_message *m)
 
 static int net_sync_resp_append(struct port *p, struct ptp_message *m)
 {
-	struct timePropertiesDS *tp = clock_time_properties(p->clock);
+	struct timePropertiesDS tp = clock_time_properties(p->clock);
 	struct ClockIdentity cid = clock_identity(p->clock), pid;
 	struct currentDS *cds = clock_current_dataset(p->clock);
 	struct parent_ds *dad = clock_parent_ds(p->clock);
@@ -468,7 +468,7 @@ static int net_sync_resp_append(struct port *p, struct ptp_message *m)
 
 	memcpy(&extra->foot->parent, &dad->pds, sizeof(extra->foot->parent));
 	memcpy(&extra->foot->current, cds, sizeof(extra->foot->current));
-	memcpy(&extra->foot->timeprop, tp, sizeof(extra->foot->timeprop));
+	memcpy(&extra->foot->timeprop, &tp, sizeof(extra->foot->timeprop));
 	memcpy(&extra->foot->lastsync, &last_sync, sizeof(extra->foot->lastsync));
 
 	return 0;
@@ -1407,7 +1407,7 @@ out:
 
 int port_tx_announce(struct port *p, struct address *dst)
 {
-	struct timePropertiesDS *tp = clock_time_properties(p->clock);
+	struct timePropertiesDS tp = clock_time_properties(p->clock);
 	struct parent_ds *dad = clock_parent_ds(p->clock);
 	struct ptp_message *msg;
 	int err;
@@ -1434,19 +1434,19 @@ int port_tx_announce(struct port *p, struct address *dst)
 	msg->header.control            = CTL_OTHER;
 	msg->header.logMessageInterval = p->logAnnounceInterval;
 
-	msg->header.flagField[1] = tp->flags;
+	msg->header.flagField[1] = tp.flags;
 
 	if (dst) {
 		msg->address = *dst;
 		msg->header.flagField[0] |= UNICAST;
 	}
-	msg->announce.currentUtcOffset        = tp->currentUtcOffset;
+	msg->announce.currentUtcOffset        = tp.currentUtcOffset;
 	msg->announce.grandmasterPriority1    = dad->pds.grandmasterPriority1;
 	msg->announce.grandmasterClockQuality = dad->pds.grandmasterClockQuality;
 	msg->announce.grandmasterPriority2    = dad->pds.grandmasterPriority2;
 	msg->announce.grandmasterIdentity     = dad->pds.grandmasterIdentity;
 	msg->announce.stepsRemoved            = clock_steps_removed(p->clock);
-	msg->announce.timeSource              = tp->timeSource;
+	msg->announce.timeSource              = tp.timeSource;
 
 	if (p->path_trace_enabled && path_trace_append(p, msg, dad)) {
 		pr_err("port %hu: append path trace failed", portnum(p));
diff --git a/tlv.h b/tlv.h
index faf5742..75aa1de 100644
--- a/tlv.h
+++ b/tlv.h
@@ -84,6 +84,7 @@ enum management_action {
 #define TLV_TIME_STATUS_NP				0xC000
 #define TLV_GRANDMASTER_SETTINGS_NP			0xC001
 #define TLV_SUBSCRIBE_EVENTS_NP				0xC003
+#define TLV_SYNCHRONIZATION_UNCERTAIN_NP		0xC006
 
 /* Port management ID values */
 #define TLV_NULL_MANAGEMENT				0x0000
@@ -116,6 +117,11 @@ enum management_action {
 #define TLV_NOT_SUPPORTED				0x0006
 #define TLV_GENERAL_ERROR				0xFFFE
 
+/* Values for the SYNCHRONIZATION_UNCERTAIN_NP management TLV */
+#define SYNC_UNCERTAIN_DONTCARE	0xff
+#define SYNC_UNCERTAIN_FALSE	0
+#define SYNC_UNCERTAIN_TRUE	1
+
 #define CANCEL_UNICAST_MAINTAIN_REQUEST	(1 << 0)
 #define CANCEL_UNICAST_MAINTAIN_GRANT	(1 << 1)
 #define GRANT_UNICAST_RENEWAL_INVITED	(1 << 0)
-- 
2.17.1


From 6c5b61a64c4bd31090703f1e24f89e140dc490d7 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 5 May 2020 12:36:44 -0700
Subject: [PATCH 126/173] pmc: Support getting and setting the local
 synchronization uncertain flag.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc.c        |  5 +++++
 pmc_common.c | 22 ++++++++++++++++++++++
 2 files changed, 27 insertions(+)

diff --git a/pmc.c b/pmc.c
index f074621..490c140 100644
--- a/pmc.c
+++ b/pmc.c
@@ -305,6 +305,11 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 			sen->duration,
 			(sen->bitmask[0] & 1 << NOTIFY_PORT_STATE) ? "on" : "off");
 		break;
+	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+		mtd = (struct management_tlv_datum *) mgt->data;
+		fprintf(fp, "SYNCHRONIZATION_UNCERTAIN_NP "
+			IFMT "uncertain %hhu", mtd->val);
+		break;
 	case TLV_PORT_DATA_SET:
 		p = (struct portDS *) mgt->data;
 		if (p->portState > PS_SLAVE) {
diff --git a/pmc_common.c b/pmc_common.c
index 822dd6d..f07f6f6 100644
--- a/pmc_common.c
+++ b/pmc_common.c
@@ -110,6 +110,7 @@ struct management_id idtab[] = {
 	{ "TIME_STATUS_NP", TLV_TIME_STATUS_NP, do_get_action },
 	{ "GRANDMASTER_SETTINGS_NP", TLV_GRANDMASTER_SETTINGS_NP, do_set_action },
 	{ "SUBSCRIBE_EVENTS_NP", TLV_SUBSCRIBE_EVENTS_NP, do_set_action },
+	{ "SYNCHRONIZATION_UNCERTAIN_NP", TLV_SYNCHRONIZATION_UNCERTAIN_NP, do_set_action },
 /* Port management ID values */
 	{ "NULL_MANAGEMENT", TLV_NULL_MANAGEMENT, null_management },
 	{ "CLOCK_DESCRIPTION", TLV_CLOCK_DESCRIPTION, do_get_action },
@@ -236,6 +237,27 @@ static void do_set_action(struct pmc *pmc, int action, int index, char *str)
 		}
 		pmc_send_set_action(pmc, code, &sen, sizeof(sen));
 		break;
+	case TLV_SYNCHRONIZATION_UNCERTAIN_NP:
+		cnt = sscanf(str,  " %*s %*s %hhu", &mtd.val);
+		if (cnt != 1) {
+			fprintf(stderr, "%s SET needs 1 value\n",
+				idtab[index].name);
+			break;
+		}
+		switch (mtd.val) {
+		case SYNC_UNCERTAIN_DONTCARE:
+		case SYNC_UNCERTAIN_FALSE:
+		case SYNC_UNCERTAIN_TRUE:
+			pmc_send_set_action(pmc, code, &mtd, sizeof(mtd));
+			break;
+		default:
+			fprintf(stderr, "\nusage: set SYNCHRONIZATION_UNCERTAIN_NP "
+				"%hhu (false), %hhu (true), or %hhu (don't care)\n\n",
+				SYNC_UNCERTAIN_FALSE,
+				SYNC_UNCERTAIN_TRUE,
+				SYNC_UNCERTAIN_DONTCARE);
+		}
+		break;
 	case TLV_PORT_DATA_SET_NP:
 		cnt = sscanf(str, " %*s %*s "
 			     "neighborPropDelayThresh %u "
-- 
2.17.1


From f8078f00f7eac64596ecd4dbb411c1c76be8817e Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 5 May 2020 16:22:17 -0700
Subject: [PATCH 127/173] Let the free running port state reflect the
 synchronization uncertain flag.

When using the "free running" option, a slaved port remains in the
UNCALIBRATED state.  If the actual servo resides in and external program,
for example when following the 802.1AS recommendations, that program can
signal the synchronization state using the "synchronization uncertain"
management message. This patch lets the port state transitions from
UNCALIBRATED to SLAVE based on that message.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/clock.c b/clock.c
index 11082fe..a559cd4 100644
--- a/clock.c
+++ b/clock.c
@@ -589,10 +589,16 @@ static void clock_stats_display(struct clock_stats *s)
 static enum servo_state clock_no_adjust(struct clock *c, tmv_t ingress,
 					tmv_t origin)
 {
-	double fui;
-	double ratio, freq;
 	struct freq_estimator *f = &c->fest;
-	enum servo_state state = SERVO_UNLOCKED;
+	double freq, fui, ratio;
+	enum servo_state state;
+
+	if (c->local_sync_uncertain == SYNC_UNCERTAIN_FALSE) {
+		state = SERVO_LOCKED;
+	} else {
+		state = SERVO_UNLOCKED;
+	}
+
 	/*
 	 * The ratio of the local clock freqency to the master clock
 	 * is estimated by:
-- 
2.17.1


From 306ac674608e5a8d1affbdc2e459f8f011eca115 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:12:23 -0700
Subject: [PATCH 128/173] transport: Correct grammar in the doxygen comments.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 transport.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/transport.h b/transport.h
index 5b8c413..7a7f87b 100644
--- a/transport.h
+++ b/transport.h
@@ -70,7 +70,7 @@ int transport_recv(struct transport *t, int fd, struct ptp_message *msg);
  * @param fda	The array of descriptors filled in by transport_open.
  * @param event	One of the @ref transport_event enumeration values.
  * @param msg	The message to send.
- * @return	Number of bytes send, or negative value in case of an error.
+ * @return	Number of bytes sent, or negative value in case of an error.
  */
 int transport_send(struct transport *t, struct fdarray *fda,
 		   enum transport_event event, struct ptp_message *msg);
@@ -83,7 +83,7 @@ int transport_send(struct transport *t, struct fdarray *fda,
  * @param fda	The array of descriptors filled in by transport_open.
  * @param event	One of the @ref transport_event enumeration values.
  * @param msg	The message to send.
- * @return	Number of bytes send, or negative value in case of an error.
+ * @return	Number of bytes sent, or negative value in case of an error.
  */
 int transport_peer(struct transport *t, struct fdarray *fda,
 		   enum transport_event event, struct ptp_message *msg);
@@ -96,7 +96,7 @@ int transport_peer(struct transport *t, struct fdarray *fda,
  * @param event	One of the @ref transport_event enumeration values.
  * @param msg	The message to send. The address of the destination has to
  *		be set in the address field.
- * @return	Number of bytes send, or negative value in case of an error.
+ * @return	Number of bytes sent, or negative value in case of an error.
  */
 int transport_sendto(struct transport *t, struct fdarray *fda,
 		     enum transport_event event, struct ptp_message *msg);
-- 
2.17.1


From d4fbb0701d70e27cdc02037cf31ae2c438867ab9 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:08:45 -0700
Subject: [PATCH 129/173] udp: Convey transmit path errors to the caller.

The transport layer's functional interface foresees having error codes
percolate back up to the caller.  However, up until now, the udp module
simply returned -1 for any error.  This patch lets the code return the
specific error instead.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 udp.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/udp.c b/udp.c
index eb7be78..36802fb 100644
--- a/udp.c
+++ b/udp.c
@@ -256,7 +256,7 @@ static int udp_send(struct transport *t, struct fdarray *fda,
 	cnt = sendto(fd, buf, len, 0, &addr->sa, sizeof(addr->sin));
 	if (cnt < 1) {
 		pr_err("sendto failed: %m");
-		return cnt;
+		return -errno;
 	}
 	/*
 	 * Get the time stamp right away.
-- 
2.17.1


From b2bf55aebd3059624a92965240a76b975bcbbeec Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:09:02 -0700
Subject: [PATCH 130/173] udp6: Convey transmit path errors to the caller.

The transport layer's functional interface foresees having error codes
percolate back up to the caller.  However, up until now, the udp6 module
simply returned -1 for any error.  This patch lets the code return the
specific error instead.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 udp6.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/udp6.c b/udp6.c
index 6cb571b..744a5bc 100644
--- a/udp6.c
+++ b/udp6.c
@@ -271,7 +271,7 @@ static int udp6_send(struct transport *t, struct fdarray *fda,
 	cnt = sendto(fd, buf, len, 0, &addr->sa, sizeof(addr->sin6));
 	if (cnt < 1) {
 		pr_err("sendto failed: %m");
-		return cnt;
+		return -errno;
 	}
 	/*
 	 * Get the time stamp right away.
-- 
2.17.1


From 0d82c41ac1a0a68e91b75dffba5a622d10f9aa3e Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:11:37 -0700
Subject: [PATCH 131/173] uds: Convey transmit path errors to the caller.

The transport layer's functional interface foresees having error codes
percolate back up to the caller.  However, up until now, the uds module
simply returned -1 for any error.  This patch lets the code return the
specific error instead.  In addition, it removes the gratuitous printing
of the error message, leaving that task up to caller, just like the other
transport modules.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 uds.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/uds.c b/uds.c
index a4c856b..641a672 100644
--- a/uds.c
+++ b/uds.c
@@ -119,8 +119,8 @@ static int uds_send(struct transport *t, struct fdarray *fda,
 		addr = &uds->address;
 
 	cnt = sendto(fd, buf, buflen, 0, &addr->sa, addr->len);
-	if (cnt <= 0 && errno != ECONNREFUSED) {
-		pr_err("uds: sendto failed: %m");
+	if (cnt < 1) {
+		return -errno;
 	}
 	return cnt;
 }
@@ -144,4 +144,3 @@ struct transport *uds_transport_create(void)
 	uds->t.release = uds_release;
 	return &uds->t;
 }
-
-- 
2.17.1


From d95fbcb566e5d9c564c62085df7d132b4cb1ff50 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:15:54 -0700
Subject: [PATCH 132/173] raw: Convey transmit path errors to the caller.

The transport layer's functional interface foresees having error codes
percolate back up to the caller.  However, up until now, the raw module
simply returned -1 for any error.  This patch lets the code return the
specific error instead.  In addition, it removes the gratuitous printing
of the error message, leaving that task up to caller, just like the other
transport modules.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 raw.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/raw.c b/raw.c
index 81ec431..15c9756 100644
--- a/raw.c
+++ b/raw.c
@@ -336,8 +336,7 @@ static int raw_send(struct transport *t, struct fdarray *fda,
 
 	cnt = send(fd, ptr, len, 0);
 	if (cnt < 1) {
-		pr_err("send failed: %d %m", errno);
-		return cnt;
+		return -errno;
 	}
 	/*
 	 * Get the time stamp right away.
-- 
2.17.1


From a6e0b83bd5038f4d749e44e52d11cf24e0727089 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:13:33 -0700
Subject: [PATCH 133/173] sk: Convey transmit path errors to the caller.

The transport layer's functional interface foresees having error codes
percolate back up to the caller.  However, up until now, the sk module
simply returned -1 for any error.  This patch lets the code return the
specific error instead.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 sk.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/sk.c b/sk.c
index e211175..c9ef4d2 100644
--- a/sk.c
+++ b/sk.c
@@ -354,7 +354,7 @@ int sk_receive(int fd, void *buf, int buflen,
 			             "timed out while polling for tx timestamp");
 			pr_err("increasing tx_timestamp_timeout may correct "
 			       "this issue, but it is likely caused by a driver bug");
-			return res;
+			return -errno;
 		} else if (!(pfd.revents & sk_revents)) {
 			pr_err("poll for tx timestamp woke up on non ERR event");
 			return -1;
@@ -362,24 +362,24 @@ int sk_receive(int fd, void *buf, int buflen,
 	}
 
 	cnt = recvmsg(fd, &msg, flags);
-	if (cnt < 0)
+	if (cnt < 0) {
 		pr_err("recvmsg%sfailed: %m",
 		       flags == MSG_ERRQUEUE ? " tx timestamp " : " ");
-
+	}
 	for (cm = CMSG_FIRSTHDR(&msg); cm != NULL; cm = CMSG_NXTHDR(&msg, cm)) {
 		level = cm->cmsg_level;
 		type  = cm->cmsg_type;
 		if (SOL_SOCKET == level && SO_TIMESTAMPING == type) {
 			if (cm->cmsg_len < sizeof(*ts) * 3) {
 				pr_warning("short SO_TIMESTAMPING message");
-				return -1;
+				return -EMSGSIZE;
 			}
 			ts = (struct timespec *) CMSG_DATA(cm);
 		}
 		if (SOL_SOCKET == level && SO_TIMESTAMPNS == type) {
 			if (cm->cmsg_len < sizeof(*sw)) {
 				pr_warning("short SO_TIMESTAMPNS message");
-				return -1;
+				return -EMSGSIZE;
 			}
 			sw = (struct timespec *) CMSG_DATA(cm);
 			hwts->sw = timespec_to_tmv(*sw);
@@ -391,7 +391,7 @@ int sk_receive(int fd, void *buf, int buflen,
 
 	if (!ts) {
 		memset(&hwts->ts, 0, sizeof(hwts->ts));
-		return cnt;
+		return cnt < 1 ? -errno : cnt;
 	}
 
 	switch (hwts->type) {
@@ -407,7 +407,7 @@ int sk_receive(int fd, void *buf, int buflen,
 		hwts->ts = timespec_to_tmv(ts[1]);
 		break;
 	}
-	return cnt;
+	return cnt < 1 ? -errno : cnt;
 }
 
 int sk_set_priority(int fd, int family, uint8_t dscp)
-- 
2.17.1


From 5aa19dd3f40502525aab925703ad2665e4bfc810 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 30 Apr 2020 06:20:17 -0700
Subject: [PATCH 134/173] port: Convey targeted forwarding errors to the
 caller.

The port_forward_to() method clobbers the specific error code returned
by the transport layer with -1.  This patch lets the code preserve the
specific error in question.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 6 ++++--
 port.h | 2 +-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/port.c b/port.c
index 6104061..48fff1c 100644
--- a/port.c
+++ b/port.c
@@ -2737,8 +2737,10 @@ int port_forward_to(struct port *p, struct ptp_message *msg)
 {
 	int cnt;
 	cnt = transport_sendto(p->trp, &p->fda, TRANS_GENERAL, msg);
-	if (cnt <= 0) {
-		return -1;
+	if (cnt < 0) {
+		return cnt;
+	} else if (!cnt) {
+		return -EIO;
 	}
 	port_stats_inc_tx(p, msg);
 	return 0;
diff --git a/port.h b/port.h
index a45a7a4..e347e36 100644
--- a/port.h
+++ b/port.h
@@ -94,7 +94,7 @@ int port_forward(struct port *p, struct ptp_message *msg);
  * Forward a message on a given port to the address stored in the message.
  * @param port    A pointer previously obtained via port_open().
  * @param msg     The message to send. Must be in network byte order.
- * @return        Zero on success, non-zero otherwise.
+ * @return        Zero on success, negative errno value otherwise.
  */
 int port_forward_to(struct port *p, struct ptp_message *msg);
 
-- 
2.17.1


From 44c06f5d445f7dcd94eb9f190738cb01f66e6597 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 13 Apr 2020 19:02:25 -0700
Subject: [PATCH 135/173] util: Mark port identity comparisons as const.

The utility function to compare port IDs takes pointers, but it only needs
to read the referenced data.  This patch marks the parameters as const,
allowing passing constants in the future.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 util.h | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/util.h b/util.h
index 6e104ea..41e33d4 100644
--- a/util.h
+++ b/util.h
@@ -131,7 +131,8 @@ clockid_t posix_clock_open(const char *device, int *phc_index);
  * @param b  Second port identity.
  * @return   1 if identities are equal, 0 otherwise.
  */
-static inline int pid_eq(struct PortIdentity *a, struct PortIdentity *b)
+static inline int pid_eq(const struct PortIdentity *a,
+			 const struct PortIdentity *b)
 {
 	return memcmp(a, b, sizeof(*a)) == 0;
 }
-- 
2.17.1


From 0695d483323f3be2344394ae418f6961292f373f Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 13 Apr 2020 19:05:16 -0700
Subject: [PATCH 136/173] port: Export the value of the wildcard port identity.

Code in other modules will need this special port ID value.  This patch
makes it available through the port header file.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.h           | 3 +++
 port_signaling.c | 4 ++--
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/port.h b/port.h
index e347e36..80c543e 100644
--- a/port.h
+++ b/port.h
@@ -33,6 +33,9 @@ struct clock;
 /** Opaque type. */
 struct port;
 
+/** The port identity that matches any port. */
+extern const struct PortIdentity wildcard_pid;
+
 /**
  * Returns the dataset from a port's best foreign clock record, if any
  * has yet been discovered. This function does not bring the returned
diff --git a/port_signaling.c b/port_signaling.c
index c4d5469..cbd0cf4 100644
--- a/port_signaling.c
+++ b/port_signaling.c
@@ -23,7 +23,7 @@
 #include "unicast_client.h"
 #include "unicast_service.h"
 
-static struct PortIdentity wildcard = {
+const struct PortIdentity wildcard_pid = {
 	.clockIdentity = {
 		{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
 	},
@@ -126,7 +126,7 @@ int process_signaling(struct port *p, struct ptp_message *m)
 
 	/* Ignore signaling messages not addressed to this port. */
 	if (!pid_eq(&m->signaling.targetPortIdentity, &p->portIdentity) &&
-	    !pid_eq(&m->signaling.targetPortIdentity, &wildcard)) {
+	    !pid_eq(&m->signaling.targetPortIdentity, &wildcard_pid)) {
 		return 0;
 	}
 
-- 
2.17.1


From 8f523e4d629e671598ed73a408c88dbbe2c6d490 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 13 Apr 2020 19:09:16 -0700
Subject: [PATCH 137/173] port: Publish the method for creating signaling
 messages.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.h           | 3 +++
 port_signaling.c | 4 ++--
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/port.h b/port.h
index 80c543e..0b07d55 100644
--- a/port.h
+++ b/port.h
@@ -210,6 +210,9 @@ struct port *port_open(const char *phc_device,
 		       struct interface *interface,
 		       struct clock *clock);
 
+struct ptp_message *port_signaling_construct(struct port *p,
+					     const struct PortIdentity *tpid);
+
 /**
  * Returns a port's current state.
  * @param port  A port instance.
diff --git a/port_signaling.c b/port_signaling.c
index cbd0cf4..2f5a682 100644
--- a/port_signaling.c
+++ b/port_signaling.c
@@ -30,8 +30,8 @@ const struct PortIdentity wildcard_pid = {
 	.portNumber = 0xffff,
 };
 
-static struct ptp_message *port_signaling_construct(struct port *p,
-						    struct PortIdentity *tpid)
+struct ptp_message *port_signaling_construct(struct port *p,
+					     const struct PortIdentity *tpid)
 {
 	struct ptp_message *msg;
 
-- 
2.17.1


From faea24aa328dc5254a687f7f67fd78bbd7c1e7fd Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 5 Apr 2020 18:08:27 -0700
Subject: [PATCH 138/173] Reject path trace TLVs with excessive elements.

The current code truncates the size of path trace TLVs which exceed the
expected maximum based on the largest possible message size.  However if
another TLV follows, then a gap would appear, that is, an area in the
message buffer not pointed to by any TLV descriptor.  In order to avoid
forwarding such malformed messages, this patch changes the logic to reject
them.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 tlv.c | 22 ++++++++++++++++------
 1 file changed, 16 insertions(+), 6 deletions(-)

diff --git a/tlv.c b/tlv.c
index 2440482..6ab54a5 100644
--- a/tlv.c
+++ b/tlv.c
@@ -18,6 +18,7 @@
  */
 #include <arpa/inet.h>
 #include <errno.h>
+#include <stdbool.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -79,6 +80,17 @@ static int64_t net2host64_unaligned(int64_t *p)
 	return v;
 }
 
+static bool tlv_array_invalid(struct TLV *tlv, size_t base_size, size_t item_size)
+{
+	size_t expected_length, n_items;
+
+	n_items = (tlv->length - base_size) / item_size;
+
+	expected_length = base_size + n_items * item_size;
+
+	return (tlv->length == expected_length) ? false : true;
+}
+
 static int mgt_post_recv(struct management_tlv *m, uint16_t data_len,
 			 struct tlv_extra *extra)
 {
@@ -678,11 +690,10 @@ void tlv_extra_recycle(struct tlv_extra *extra)
 
 int tlv_post_recv(struct tlv_extra *extra)
 {
-	int result = 0;
-	struct management_tlv *mgt;
 	struct management_error_status *mes;
 	struct TLV *tlv = extra->tlv;
-	struct path_trace_tlv *ptt;
+	struct management_tlv *mgt;
+	int result = 0;
 
 	switch (tlv->type) {
 	case TLV_MANAGEMENT:
@@ -712,9 +723,8 @@ int tlv_post_recv(struct tlv_extra *extra)
 		result = unicast_negotiation_post_recv(extra);
 		break;
 	case TLV_PATH_TRACE:
-		ptt = (struct path_trace_tlv *) tlv;
-		if (path_length(ptt) > PATH_TRACE_MAX) {
-			ptt->length = PATH_TRACE_MAX * sizeof(struct ClockIdentity);
+		if (tlv_array_invalid(tlv, 0, sizeof(struct ClockIdentity))) {
+			goto bad_length;
 		}
 		break;
 	case TLV_ALTERNATE_TIME_OFFSET_INDICATOR:
-- 
2.17.1


From b4d3b4126fbd02c486bdd9327b277fda8e959ca7 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sat, 4 Apr 2020 13:03:33 -0700
Subject: [PATCH 139/173] tlv: Update macro definitions.

The 2019 version of 1588 known as v2.1 introduces new TLV type and
management IDs.  This patch adds the new definitions.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 tlv.c | 28 ++++++++++++++++++++++++++--
 tlv.h | 19 ++++++++++++++++++-
 2 files changed, 44 insertions(+), 3 deletions(-)

diff --git a/tlv.c b/tlv.c
index 6ab54a5..0cf6d5c 100644
--- a/tlv.c
+++ b/tlv.c
@@ -728,7 +728,7 @@ int tlv_post_recv(struct tlv_extra *extra)
 		}
 		break;
 	case TLV_ALTERNATE_TIME_OFFSET_INDICATOR:
-	case TLV_AUTHENTICATION:
+	case TLV_AUTHENTICATION_2008:
 	case TLV_AUTHENTICATION_CHALLENGE:
 	case TLV_SECURITY_ASSOCIATION_UPDATE:
 	case TLV_CUM_FREQ_SCALE_FACTOR_OFFSET:
@@ -737,6 +737,18 @@ int tlv_post_recv(struct tlv_extra *extra)
 	case TLV_PTPMON_RESP:
 		result = nsm_resp_post_recv(extra);
 		break;
+	case TLV_ORGANIZATION_EXTENSION_PROPAGATE:
+	case TLV_ENHANCED_ACCURACY_METRICS:
+	case TLV_ORGANIZATION_EXTENSION_DO_NOT_PROPAGATE:
+	case TLV_L1_SYNC:
+	case TLV_PORT_COMMUNICATION_AVAILABILITY:
+	case TLV_PROTOCOL_ADDRESS:
+	case TLV_SLAVE_RX_SYNC_TIMING_DATA:
+	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
+	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
+	case TLV_CUMULATIVE_RATE_RATIO:
+	case TLV_PAD:
+	case TLV_AUTHENTICATION:
 	default:
 		break;
 	}
@@ -773,7 +785,7 @@ void tlv_pre_send(struct TLV *tlv, struct tlv_extra *extra)
 		break;
 	case TLV_PATH_TRACE:
 	case TLV_ALTERNATE_TIME_OFFSET_INDICATOR:
-	case TLV_AUTHENTICATION:
+	case TLV_AUTHENTICATION_2008:
 	case TLV_AUTHENTICATION_CHALLENGE:
 	case TLV_SECURITY_ASSOCIATION_UPDATE:
 	case TLV_CUM_FREQ_SCALE_FACTOR_OFFSET:
@@ -782,6 +794,18 @@ void tlv_pre_send(struct TLV *tlv, struct tlv_extra *extra)
 	case TLV_PTPMON_RESP:
 		nsm_resp_pre_send(extra);
 		break;
+	case TLV_ORGANIZATION_EXTENSION_PROPAGATE:
+	case TLV_ENHANCED_ACCURACY_METRICS:
+	case TLV_ORGANIZATION_EXTENSION_DO_NOT_PROPAGATE:
+	case TLV_L1_SYNC:
+	case TLV_PORT_COMMUNICATION_AVAILABILITY:
+	case TLV_PROTOCOL_ADDRESS:
+	case TLV_SLAVE_RX_SYNC_TIMING_DATA:
+	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
+	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
+	case TLV_CUMULATIVE_RATE_RATIO:
+	case TLV_PAD:
+	case TLV_AUTHENTICATION:
 	default:
 		break;
 	}
diff --git a/tlv.h b/tlv.h
index 75aa1de..f46a3b8 100644
--- a/tlv.h
+++ b/tlv.h
@@ -35,12 +35,24 @@
 #define TLV_ACKNOWLEDGE_CANCEL_UNICAST_TRANSMISSION	0x0007
 #define TLV_PATH_TRACE					0x0008
 #define TLV_ALTERNATE_TIME_OFFSET_INDICATOR		0x0009
-#define TLV_AUTHENTICATION				0x2000
+#define TLV_AUTHENTICATION_2008				0x2000
 #define TLV_AUTHENTICATION_CHALLENGE			0x2001
 #define TLV_SECURITY_ASSOCIATION_UPDATE			0x2002
 #define TLV_CUM_FREQ_SCALE_FACTOR_OFFSET		0x2003
 #define TLV_PTPMON_REQ					0x21FE
 #define TLV_PTPMON_RESP					0x21FF
+#define TLV_ORGANIZATION_EXTENSION_PROPAGATE		0x4000
+#define TLV_ENHANCED_ACCURACY_METRICS			0x4001
+#define TLV_ORGANIZATION_EXTENSION_DO_NOT_PROPAGATE	0x8000
+#define TLV_L1_SYNC					0x8001
+#define TLV_PORT_COMMUNICATION_AVAILABILITY		0x8002
+#define TLV_PROTOCOL_ADDRESS				0x8003
+#define TLV_SLAVE_RX_SYNC_TIMING_DATA			0x8004
+#define TLV_SLAVE_RX_SYNC_COMPUTED_DATA			0x8005
+#define TLV_SLAVE_TX_EVENT_TIMESTAMPS			0x8006
+#define TLV_CUMULATIVE_RATE_RATIO			0x8007
+#define TLV_PAD						0x8008
+#define TLV_AUTHENTICATION				0x8009
 
 enum management_action {
 	GET,
@@ -79,6 +91,8 @@ enum management_action {
 #define TLV_ALTERNATE_TIME_OFFSET_NAME			0x201F
 #define TLV_ALTERNATE_TIME_OFFSET_MAX_KEY		0x2020
 #define TLV_ALTERNATE_TIME_OFFSET_PROPERTIES		0x2021
+#define TLV_EXTERNAL_PORT_CONFIGURATION_ENABLED		0x3000
+#define TLV_HOLDOVER_UPGRADE_ENABLE			0x3002
 #define TLV_TRANSPARENT_CLOCK_DEFAULT_DATA_SET		0x4000
 #define TLV_PRIMARY_DOMAIN				0x4002
 #define TLV_TIME_STATUS_NP				0xC000
@@ -101,6 +115,9 @@ enum management_action {
 #define TLV_UNICAST_MASTER_MAX_TABLE_SIZE		0x2019
 #define TLV_ACCEPTABLE_MASTER_TABLE_ENABLED		0x201B
 #define TLV_ALTERNATE_MASTER				0x201D
+#define TLV_MASTER_ONLY					0x3001
+#define TLV_EXT_PORT_CONFIG_PORT_DATA_SET		0x3003
+#define TLV_SLAVE_EVENT_MONITORING			0x3004	// TODO - proposed value, missing in 1588 v2.1
 #define TLV_TRANSPARENT_CLOCK_PORT_DATA_SET		0x4001
 #define TLV_DELAY_MECHANISM				0x6000
 #define TLV_LOG_MIN_PDELAY_REQ_INTERVAL			0x6001
-- 
2.17.1


From d0aa29b932bdfb5c8bad2ebb76a8cf8934b948ff Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 6 Apr 2020 16:33:13 -0700
Subject: [PATCH 140/173] tlv: Encode and decode SLAVE_RX_SYNC_TIMING_DATA
 TLVs.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 tlv.c | 78 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 tlv.h | 28 ++++++++++++++++++---
 2 files changed, 101 insertions(+), 5 deletions(-)

diff --git a/tlv.c b/tlv.c
index 0cf6d5c..e12e5ae 100644
--- a/tlv.c
+++ b/tlv.c
@@ -53,6 +53,20 @@ static void scaled_ns_h2n(ScaledNs *sns)
 	sns->fractional_nanoseconds = htons(sns->fractional_nanoseconds);
 }
 
+static void timestamp_host2net(struct Timestamp *t)
+{
+	HTONL(t->seconds_lsb);
+	HTONS(t->seconds_msb);
+	HTONL(t->nanoseconds);
+}
+
+static void timestamp_net2host(struct Timestamp *t)
+{
+	NTOHL(t->seconds_lsb);
+	NTOHS(t->seconds_msb);
+	NTOHL(t->nanoseconds);
+}
+
 static uint16_t flip16(uint16_t *p)
 {
 	uint16_t v;
@@ -80,11 +94,16 @@ static int64_t net2host64_unaligned(int64_t *p)
 	return v;
 }
 
+static size_t tlv_array_count(struct TLV *tlv, size_t base_size, size_t item_size)
+{
+	return (tlv->length - base_size) / item_size;
+}
+
 static bool tlv_array_invalid(struct TLV *tlv, size_t base_size, size_t item_size)
 {
 	size_t expected_length, n_items;
 
-	n_items = (tlv->length - base_size) / item_size;
+	n_items = tlv_array_count(tlv, base_size, item_size);
 
 	expected_length = base_size + n_items * item_size;
 
@@ -575,6 +594,57 @@ static void org_pre_send(struct organization_tlv *org)
 	}
 }
 
+static int slave_rx_sync_timing_data_post_revc(struct tlv_extra *extra)
+{
+	struct slave_rx_sync_timing_data_tlv *slave_data =
+		(struct slave_rx_sync_timing_data_tlv *) extra->tlv;
+	size_t base_size = sizeof(slave_data->sourcePortIdentity), n_items;
+	struct slave_rx_sync_timing_record *record;
+
+	if (tlv_array_invalid(extra->tlv, base_size, sizeof(*record))) {
+		return -EBADMSG;
+	}
+	n_items = tlv_array_count(extra->tlv, base_size, sizeof(*record));
+	record = slave_data->record;
+
+	NTOHS(slave_data->sourcePortIdentity.portNumber);
+
+	while (n_items) {
+		NTOHS(record->sequenceId);
+		timestamp_net2host(&record->syncOriginTimestamp);
+		net2host64_unaligned(&record->totalCorrectionField);
+		NTOHL(record->scaledCumulativeRateOffset);
+		timestamp_net2host(&record->syncEventIngressTimestamp);
+		n_items--;
+		record++;
+	}
+
+	return 0;
+}
+
+static void slave_rx_sync_timing_data_pre_send(struct tlv_extra *extra)
+{
+	struct slave_rx_sync_timing_data_tlv *slave_data =
+		(struct slave_rx_sync_timing_data_tlv *) extra->tlv;
+	size_t base_size = sizeof(slave_data->sourcePortIdentity), n_items;
+	struct slave_rx_sync_timing_record *record;
+
+	n_items = tlv_array_count(extra->tlv, base_size, sizeof(*record));
+	record = slave_data->record;
+
+	HTONS(slave_data->sourcePortIdentity.portNumber);
+
+	while (n_items) {
+		HTONS(record->sequenceId);
+		timestamp_host2net(&record->syncOriginTimestamp);
+		host2net64_unaligned(&record->totalCorrectionField);
+		HTONL(record->scaledCumulativeRateOffset);
+		timestamp_host2net(&record->syncEventIngressTimestamp);
+		n_items--;
+		record++;
+	}
+}
+
 static int unicast_message_type_valid(uint8_t message_type)
 {
 	message_type >>= 4;
@@ -743,7 +813,10 @@ int tlv_post_recv(struct tlv_extra *extra)
 	case TLV_L1_SYNC:
 	case TLV_PORT_COMMUNICATION_AVAILABILITY:
 	case TLV_PROTOCOL_ADDRESS:
+		break;
 	case TLV_SLAVE_RX_SYNC_TIMING_DATA:
+		result = slave_rx_sync_timing_data_post_revc(extra);
+		break;
 	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
 	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
 	case TLV_CUMULATIVE_RATE_RATIO:
@@ -800,7 +873,10 @@ void tlv_pre_send(struct TLV *tlv, struct tlv_extra *extra)
 	case TLV_L1_SYNC:
 	case TLV_PORT_COMMUNICATION_AVAILABILITY:
 	case TLV_PROTOCOL_ADDRESS:
+		break;
 	case TLV_SLAVE_RX_SYNC_TIMING_DATA:
+		slave_rx_sync_timing_data_pre_send(extra);
+		break;
 	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
 	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
 	case TLV_CUMULATIVE_RATE_RATIO:
diff --git a/tlv.h b/tlv.h
index f46a3b8..8212325 100644
--- a/tlv.h
+++ b/tlv.h
@@ -224,6 +224,11 @@ struct path_trace_tlv {
 	struct ClockIdentity cid[0];
 } PACKED;
 
+static inline unsigned int path_length(struct path_trace_tlv *p)
+{
+	return p->length / sizeof(struct ClockIdentity);
+}
+
 struct request_unicast_xmit_tlv {
 	Enumeration16   type;
 	UInteger16      length;
@@ -232,10 +237,25 @@ struct request_unicast_xmit_tlv {
 	UInteger32      durationField;
 } PACKED;
 
-static inline unsigned int path_length(struct path_trace_tlv *p)
-{
-	return p->length / sizeof(struct ClockIdentity);
-}
+struct slave_rx_sync_timing_record {
+	UInteger16          sequenceId;
+	struct Timestamp    syncOriginTimestamp;
+	TimeInterval        totalCorrectionField;
+	Integer32           scaledCumulativeRateOffset;
+	struct Timestamp    syncEventIngressTimestamp;
+} PACKED;
+
+struct slave_rx_sync_timing_data_tlv {
+	Enumeration16        type;
+	UInteger16           length;
+	struct PortIdentity  sourcePortIdentity;
+	struct slave_rx_sync_timing_record record[0];
+} PACKED;
+
+#define SLAVE_RX_SYNC_TIMING_MAX \
+	((sizeof(struct message_data) - sizeof(struct signaling_msg) -	\
+	  sizeof(struct slave_rx_sync_timing_data_tlv)) /		\
+	 sizeof(struct slave_rx_sync_timing_record))
 
 typedef struct Integer96 {
 	uint16_t nanoseconds_msb;
-- 
2.17.1


From d3a519e26d2edd351bf4e6e16e24badaaf5f3646 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 13 Apr 2020 18:57:16 -0700
Subject: [PATCH 141/173] Introduce a module for slave event monitoring.

This patch adds a new module for slave event monitoring with its own
configuration option, a UDS address.  If the option is enabled, then
the monitor will send events to the configured address.  The default
setting produces an inactive monitor that does nothing.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 config.c  |   1 +
 makefile  |   6 +-
 monitor.c | 171 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 monitor.h |  22 +++++++
 ptp4l.8   |   6 ++
 5 files changed, 203 insertions(+), 3 deletions(-)
 create mode 100644 monitor.c
 create mode 100644 monitor.h

diff --git a/config.c b/config.c
index 269183c..d3446b4 100644
--- a/config.c
+++ b/config.c
@@ -297,6 +297,7 @@ struct config_item config_tab[] = {
 	GLOB_ITEM_INT("sanity_freq_limit", 200000000, 0, INT_MAX),
 	GLOB_ITEM_INT("servo_num_offset_values", 10, 0, INT_MAX),
 	GLOB_ITEM_INT("servo_offset_threshold", 0, 0, INT_MAX),
+	GLOB_ITEM_STR("slave_event_monitor", ""),
 	GLOB_ITEM_INT("slaveOnly", 0, 0, 1),
 	GLOB_ITEM_INT("socket_priority", 0, 0, 15),
 	GLOB_ITEM_DBL("step_threshold", 0.0, 0.0, DBL_MAX),
diff --git a/makefile b/makefile
index acc94f7..27c4d78 100644
--- a/makefile
+++ b/makefile
@@ -29,9 +29,9 @@ TRANSP	= raw.o transport.o udp.o udp6.o uds.o
 TS2PHC	= ts2phc.o lstab.o nmea.o serial.o sock.o ts2phc_generic_master.o \
  ts2phc_master.o ts2phc_phc_master.o ts2phc_nmea_master.o ts2phc_slave.o
 OBJ	= bmc.o clock.o clockadj.o clockcheck.o config.o designated_fsm.o \
- e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o msg.o phc.o port.o \
- port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) sk.o \
- stats.o tc.o $(TRANSP) telecom.o tlv.o tsproc.o unicast_client.o \
+ e2e_tc.o fault.o $(FILTERS) fsm.o hash.o interface.o monitor.o msg.o phc.o \
+ port.o port_signaling.o pqueue.o print.o ptp4l.o p2p_tc.o rtnl.o $(SERVOS) \
+ sk.o stats.o tc.o $(TRANSP) telecom.o tlv.o tsproc.o unicast_client.o \
  unicast_fsm.o unicast_service.o util.o version.o
 
 OBJECTS	= $(OBJ) hwstamp_ctl.o nsm.o phc2sys.o phc_ctl.o pmc.o pmc_common.o \
diff --git a/monitor.c b/monitor.c
new file mode 100644
index 0000000..5706e5d
--- /dev/null
+++ b/monitor.c
@@ -0,0 +1,171 @@
+/**
+ * @file monitor.c
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#include <stdbool.h>
+#include <stdlib.h>
+
+#include "address.h"
+#include "monitor.h"
+#include "print.h"
+
+#define RECORDS_PER_MESSAGE 1
+
+struct monitor_message {
+	struct ptp_message *msg;
+	int records_per_msg;
+	int count;
+};
+
+struct monitor {
+	struct port *dst_port;
+	struct slave_rx_sync_timing_data_tlv *sync_tlv;
+	struct monitor_message sync;
+};
+
+static bool monitor_active(struct monitor *monitor)
+{
+	return monitor->dst_port ? true : false;
+}
+
+static int monitor_forward(struct port *port, struct ptp_message *msg)
+{
+	int err, pdulen = msg->header.messageLength;
+
+	if (msg_pre_send(msg)) {
+		return -1;
+	}
+	err = port_forward_to(port, msg);
+	if (err) {
+		pr_debug("failed to send signaling message to slave event monitor: %s",
+			 strerror(-err));
+	}
+	if (msg_post_recv(msg, pdulen)) {
+		return -1;
+	}
+	msg->header.sequenceId++;
+
+	return 0;
+}
+
+static struct tlv_extra *monitor_init_message(struct monitor_message *mm,
+					      struct port *destination,
+					      uint16_t tlv_type,
+					      size_t tlv_size,
+					      struct address address)
+{
+	struct ptp_message *msg;
+	struct tlv_extra *extra;
+
+	msg = port_signaling_construct(destination, &wildcard_pid);
+	if (!msg) {
+		return NULL;
+	}
+	extra = msg_tlv_append(msg, tlv_size);
+	if (!extra) {
+		msg_put(msg);
+		return NULL;
+	}
+	extra->tlv->type = tlv_type;
+	extra->tlv->length = tlv_size - sizeof(extra->tlv->type) -
+		sizeof(extra->tlv->length);
+
+	mm->msg = msg;
+	mm->msg->address = address;
+	mm->records_per_msg = RECORDS_PER_MESSAGE;
+	mm->count = 0;
+
+	return extra;
+}
+
+static int monitor_init_sync(struct monitor *monitor, struct address address)
+{
+	const size_t tlv_size = sizeof(struct slave_rx_sync_timing_data_tlv) +
+		sizeof(struct slave_rx_sync_timing_record) * RECORDS_PER_MESSAGE;
+	struct tlv_extra *extra;
+
+	extra = monitor_init_message(&monitor->sync, monitor->dst_port,
+				     TLV_SLAVE_RX_SYNC_TIMING_DATA, tlv_size,
+				     address);
+	if (!extra) {
+		return -1;
+	}
+	monitor->sync_tlv = (struct slave_rx_sync_timing_data_tlv *) extra->tlv;
+
+	return 0;
+}
+
+struct monitor *monitor_create(struct config *config, struct port *dst)
+{
+	struct monitor *monitor;
+	struct address address;
+	struct sockaddr_un sa;
+	const char *path;
+
+	monitor = calloc(1, sizeof(*monitor));
+	if (!monitor) {
+		return NULL;
+	}
+	path = config_get_string(config, NULL, "slave_event_monitor");
+	if (!path || !path[0]) {
+		/* Return an inactive monitor. */
+		return monitor;
+	}
+	memset(&sa, 0, sizeof(sa));
+	sa.sun_family = AF_LOCAL;
+	snprintf(sa.sun_path, sizeof(sa.sun_path) - 1, "%s", path);
+	address.sun = sa;
+	address.len = sizeof(sa);
+
+	monitor->dst_port = dst;
+
+	if (monitor_init_sync(monitor, address)) {
+		free(monitor);
+		return NULL;
+	}
+
+	return monitor;
+}
+
+void monitor_destroy(struct monitor *monitor)
+{
+	if (monitor->sync.msg) {
+		msg_put(monitor->sync.msg);
+	}
+	free(monitor);
+}
+
+int monitor_sync(struct monitor *monitor, struct PortIdentity source_pid,
+		 uint16_t seqid, tmv_t t1, tmv_t corr, tmv_t t2)
+{
+	struct slave_rx_sync_timing_record *record;
+	struct ptp_message *msg;
+
+	if (!monitor_active(monitor)) {
+		return 0;
+	}
+
+	msg = monitor->sync.msg;
+
+	if (!pid_eq(&monitor->sync_tlv->sourcePortIdentity, &source_pid)) {
+		/* There was a change in remote master. Drop stale records. */
+		memcpy(&monitor->sync_tlv->sourcePortIdentity, &source_pid,
+		       sizeof(monitor->sync_tlv->sourcePortIdentity));
+		monitor->sync.count = 0;
+	}
+
+	record = monitor->sync_tlv->record + monitor->sync.count;
+	record->sequenceId                 = seqid;
+	record->syncOriginTimestamp        = tmv_to_Timestamp(t1);
+	record->totalCorrectionField       = tmv_to_TimeInterval(corr);
+	record->scaledCumulativeRateOffset = 0;
+	record->syncEventIngressTimestamp  = tmv_to_Timestamp(t2);
+
+	monitor->sync.count++;
+	if (monitor->sync.count == monitor->sync.records_per_msg) {
+		monitor->sync.count = 0;
+		return monitor_forward(monitor->dst_port, msg);
+	}
+	return 0;
+}
diff --git a/monitor.h b/monitor.h
new file mode 100644
index 0000000..e2a6ca3
--- /dev/null
+++ b/monitor.h
@@ -0,0 +1,22 @@
+/**
+ * @file monitor.h
+ * @note Copyright (C) 2020 Richard Cochran <richardcochran@gmail.com>
+ * @note SPDX-License-Identifier: GPL-2.0+
+ */
+#ifndef HAVE_MONITOR_H
+#define HAVE_MONITOR_H
+
+#include "config.h"
+#include "port.h"
+#include "tmv.h"
+
+struct monitor;
+
+struct monitor *monitor_create(struct config *config, struct port *dst);
+
+void monitor_destroy(struct monitor *monitor);
+
+int monitor_sync(struct monitor *monitor, struct PortIdentity source_pid,
+		 uint16_t seqid, tmv_t t1, tmv_t corr, tmv_t t2);
+
+#endif
diff --git a/ptp4l.8 b/ptp4l.8
index 24ce10d..b179b81 100644
--- a/ptp4l.8
+++ b/ptp4l.8
@@ -764,6 +764,12 @@ to the SERVO_LOCKED_STABLE state.  The transition occurs once the last
 'servo_num_offset_values' offsets are all below the threshold value.
 The default value of offset_threshold is 0 (disabled).
 .TP
+.B slave_event_monitor
+Specifies the address of a UNIX domain socket for slave event
+monitoring.  A local client bound to this address will receive
+SLAVE_RX_SYNC_TIMING_DATA and SLAVE_DELAY_TIMING_DATA_NP TLVs.
+The default is the empty string (disabled).
+.TP
 .B write_phase_mode
 This option enables using the "write phase" feature of a PTP Hardware
 Clock.  If supported by the device, this mode uses the hardware's
-- 
2.17.1


From 6f95c2e92cf9d33a6813bfefa06e52c7f0810f72 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 14 Apr 2020 18:13:11 -0700
Subject: [PATCH 142/173] clock: Create a slave event monitor.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 13 +++++++++++++
 clock.h |  8 ++++++++
 2 files changed, 21 insertions(+)

diff --git a/clock.c b/clock.c
index a559cd4..f43cc2a 100644
--- a/clock.c
+++ b/clock.c
@@ -131,6 +131,7 @@ struct clock {
 	struct clockcheck *sanity_check;
 	struct interface *udsif;
 	LIST_HEAD(clock_subscribers_head, clock_subscriber) subscribers;
+	struct monitor *slave_event_monitor;
 };
 
 struct clock the_clock;
@@ -271,6 +272,7 @@ void clock_destroy(struct clock *c)
 	LIST_FOREACH_SAFE(p, &c->ports, list, tmp) {
 		clock_remove_port(c, p);
 	}
+	monitor_destroy(c->slave_event_monitor);
 	port_close(c->uds_port);
 	free(c->pollfd);
 	if (c->clkid != CLOCK_REALTIME) {
@@ -1185,6 +1187,12 @@ struct clock *clock_create(enum clock_type type, struct config *config,
 	}
 	clock_fda_changed(c);
 
+	c->slave_event_monitor = monitor_create(config, c->uds_port);
+	if (!c->slave_event_monitor) {
+		pr_err("failed to create slave event monitor");
+		return NULL;
+	}
+
 	/* Create the ports. */
 	STAILQ_FOREACH(iface, &config->interfaces, list) {
 		if (clock_add_port(c, phc_device, phc_index, timestamping, iface)) {
@@ -1626,6 +1634,11 @@ void clock_peer_delay(struct clock *c, tmv_t ppd, tmv_t req, tmv_t rx,
 		stats_add_value(c->stats.delay, tmv_dbl(ppd));
 }
 
+struct monitor *clock_slave_monitor(struct clock *c)
+{
+	return c->slave_event_monitor;
+}
+
 int clock_slave_only(struct clock *c)
 {
 	return c->dds.flags & DDS_SLAVE_ONLY;
diff --git a/clock.h b/clock.h
index 1256856..e7daf97 100644
--- a/clock.h
+++ b/clock.h
@@ -23,6 +23,7 @@
 #include "dm.h"
 #include "ds.h"
 #include "config.h"
+#include "monitor.h"
 #include "notification.h"
 #include "servo.h"
 #include "tlv.h"
@@ -267,6 +268,13 @@ struct servo *clock_servo(struct clock *c);
  */
 enum servo_state clock_servo_state(struct clock *c);
 
+/**
+ * Obtain the slave monitor instance from a clock.
+ * @param c The clock instance.
+ * @return  The slave monitor associated with the clock.
+ */
+struct monitor *clock_slave_monitor(struct clock *c);
+
 /**
  * Obtain the slave-only flag from a clock's default data set.
  * @param c  The clock instance.
-- 
2.17.1


From 18bd3054ffaba01d57568b5cccc8457078c6ca0c Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 14 Apr 2020 18:10:34 -0700
Subject: [PATCH 143/173] port: Support slave event monitoring of Sync timing
 data.

The monitoring module accepts Sync timing events.  This patch hooks up the
port receive path to call into the monitor.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c         | 22 +++++++++++++++++++---
 port_private.h |  3 +++
 2 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/port.c b/port.c
index 48fff1c..a74937c 100644
--- a/port.c
+++ b/port.c
@@ -1156,6 +1156,7 @@ static void message_interval_request(struct port *p,
 }
 
 static void port_synchronize(struct port *p,
+			     uint16_t seqid,
 			     tmv_t ingress_ts,
 			     struct timestamp origin_ts,
 			     Integer64 correction1, Integer64 correction2,
@@ -1172,6 +1173,17 @@ static void port_synchronize(struct port *p,
 	c2 = correction_to_tmv(correction2);
 	t1c = tmv_add(t1, tmv_add(c1, c2));
 
+	switch (p->state) {
+	case PS_UNCALIBRATED:
+	case PS_SLAVE:
+		monitor_sync(p->slave_event_monitor,
+			     clock_parent_identity(p->clock), seqid,
+			     t1, tmv_add(c1, c2), t2);
+		break;
+	default:
+		break;
+	}
+
 	last_state = clock_servo_state(p->clock);
 	state = clock_synchronize(p->clock, t2, t1c);
 	switch (state) {
@@ -1251,7 +1263,8 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 			break;
 		case FUP_MATCH:
 			syn = p->last_syncfup;
-			port_synchronize(p, syn->hwts.ts, m->ts.pdu,
+			port_synchronize(p, syn->header.sequenceId,
+					 syn->hwts.ts, m->ts.pdu,
 					 syn->header.correction,
 					 m->header.correction,
 					 m->header.logMessageInterval);
@@ -1271,7 +1284,8 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 			break;
 		case SYNC_MATCH:
 			fup = p->last_syncfup;
-			port_synchronize(p, m->hwts.ts, fup->ts.pdu,
+			port_synchronize(p, fup->header.sequenceId,
+					 m->hwts.ts, fup->ts.pdu,
 					 m->header.correction,
 					 fup->header.correction,
 					 m->header.logMessageInterval);
@@ -2297,7 +2311,8 @@ void process_sync(struct port *p, struct ptp_message *m)
 	m->header.correction += p->asymmetry;
 
 	if (one_step(m)) {
-		port_synchronize(p, m->hwts.ts, m->ts.pdu,
+		port_synchronize(p, m->header.sequenceId,
+				 m->hwts.ts, m->ts.pdu,
 				 m->header.correction, 0,
 				 m->header.logMessageInterval);
 		flush_last_sync(p);
@@ -3061,6 +3076,7 @@ struct port *port_open(const char *phc_device,
 	p->state = PS_INITIALIZING;
 	p->delayMechanism = config_get_int(cfg, p->name, "delay_mechanism");
 	p->versionNumber = PTP_VERSION;
+	p->slave_event_monitor = clock_slave_monitor(clock);
 
 	if (number && unicast_client_initialize(p)) {
 		goto err_transport;
diff --git a/port_private.h b/port_private.h
index 82d1801..fcabaa6 100644
--- a/port_private.h
+++ b/port_private.h
@@ -24,6 +24,7 @@
 #include "as_capable.h"
 #include "clock.h"
 #include "fsm.h"
+#include "monitor.h"
 #include "msg.h"
 #include "tmv.h"
 
@@ -150,6 +151,8 @@ struct port {
 	/* unicast service mode */
 	struct unicast_service *unicast_service;
 	int inhibit_multicast_service;
+	/* slave event monitoring */
+	struct monitor *slave_event_monitor;
 };
 
 #define portnum(p) (p->portIdentity.portNumber)
-- 
2.17.1


From 2d2637989c4b57f709406ac345514ecc69a0da9d Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Tue, 14 Apr 2020 18:12:31 -0700
Subject: [PATCH 144/173] pmc: Show slave receive timing data TLVs attached to
 signaling messages.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc.c | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/pmc.c b/pmc.c
index 490c140..8e30b1c 100644
--- a/pmc.c
+++ b/pmc.c
@@ -55,6 +55,59 @@ static char *bin2str(Octet *data, int len)
 	return bin2str_impl(data, len, buf, sizeof(buf));
 }
 
+#define SHOW_TIMESTAMP(ts) \
+	((uint64_t)ts.seconds_lsb) | (((uint64_t)ts.seconds_msb) << 32), ts.nanoseconds
+
+static void pmc_show_rx_sync_timing(struct slave_rx_sync_timing_record *record,
+				    FILE *fp)
+{
+	fprintf(fp,
+		IFMT "sequenceId                 %hu"
+		IFMT "syncOriginTimestamp        %" PRId64 ".%09u"
+		IFMT "totalCorrectionField       %" PRId64
+		IFMT "scaledCumulativeRateOffset %u"
+		IFMT "syncEventIngressTimestamp  %" PRId64 ".%09u",
+		record->sequenceId,
+		SHOW_TIMESTAMP(record->syncOriginTimestamp),
+		record->totalCorrectionField << 16,
+		record->scaledCumulativeRateOffset,
+		SHOW_TIMESTAMP(record->syncEventIngressTimestamp));
+}
+
+static void pmc_show_signaling(struct ptp_message *msg, FILE *fp)
+{
+	struct slave_rx_sync_timing_record *sync_record;
+	struct slave_rx_sync_timing_data_tlv *srstd;
+	struct tlv_extra *extra;
+	int i, cnt;
+
+	fprintf(fp, "\t%s seq %hu %s ",
+		pid2str(&msg->header.sourcePortIdentity),
+		msg->header.sequenceId, "SIGNALING");
+
+	TAILQ_FOREACH(extra, &msg->tlv_list, list) {
+		switch (extra->tlv->type) {
+		case TLV_SLAVE_RX_SYNC_TIMING_DATA:
+			srstd = (struct slave_rx_sync_timing_data_tlv *) extra->tlv;
+			cnt = (srstd->length - sizeof(srstd->sourcePortIdentity)) /
+				sizeof(*sync_record);
+			fprintf(fp, "SLAVE_RX_SYNC_TIMING_DATA N %d "
+				IFMT "sourcePortIdentity         %s",
+				cnt, pid2str(&srstd->sourcePortIdentity));
+			sync_record = srstd->record;
+			for (i = 0; i < cnt; i++) {
+				pmc_show_rx_sync_timing(sync_record, fp);
+				sync_record++;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	fprintf(fp, "\n");
+	fflush(fp);
+}
+
 static void pmc_show(struct ptp_message *msg, FILE *fp)
 {
 	struct grandmaster_settings_np *gsn;
@@ -75,6 +128,10 @@ static void pmc_show(struct ptp_message *msg, FILE *fp)
 	struct TLV *tlv;
 	int action;
 
+	if (msg_type(msg) == SIGNALING) {
+		pmc_show_signaling(msg, fp);
+		return;
+	}
 	if (msg_type(msg) != MANAGEMENT) {
 		return;
 	}
-- 
2.17.1


From ef9d51a47d470e045c4ec4cbc51e4cd7911953a9 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 15 Apr 2020 10:53:22 -0700
Subject: [PATCH 145/173] tlv: Encode and decode SLAVE_DELAY_TIMING_DATA_NP
 TLVs.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 tlv.c | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 tlv.h | 20 ++++++++++++++++++++
 2 files changed, 77 insertions(+)

diff --git a/tlv.c b/tlv.c
index e12e5ae..738e404 100644
--- a/tlv.c
+++ b/tlv.c
@@ -594,6 +594,55 @@ static void org_pre_send(struct organization_tlv *org)
 	}
 }
 
+static int slave_delay_timing_data_post_revc(struct tlv_extra *extra)
+{
+	struct slave_delay_timing_data_tlv *slave_delay =
+		(struct slave_delay_timing_data_tlv *) extra->tlv;
+	size_t base_size = sizeof(slave_delay->sourcePortIdentity), n_items;
+	struct slave_delay_timing_record *record;
+
+	if (tlv_array_invalid(extra->tlv, base_size, sizeof(*record))) {
+		return -EBADMSG;
+	}
+	n_items = tlv_array_count(extra->tlv, base_size, sizeof(*record));
+	record = slave_delay->record;
+
+	NTOHS(slave_delay->sourcePortIdentity.portNumber);
+
+	while (n_items) {
+		NTOHS(record->sequenceId);
+		timestamp_net2host(&record->delayOriginTimestamp);
+		net2host64_unaligned(&record->totalCorrectionField);
+		timestamp_net2host(&record->delayResponseTimestamp);
+		n_items--;
+		record++;
+	}
+
+	return 0;
+}
+
+static void slave_delay_timing_data_pre_send(struct tlv_extra *extra)
+{
+	struct slave_delay_timing_data_tlv *slave_delay =
+		(struct slave_delay_timing_data_tlv *) extra->tlv;
+	size_t base_size = sizeof(slave_delay->sourcePortIdentity), n_items;
+	struct slave_delay_timing_record *record;
+
+	n_items = tlv_array_count(extra->tlv, base_size, sizeof(*record));
+	record = slave_delay->record;
+
+	HTONS(slave_delay->sourcePortIdentity.portNumber);
+
+	while (n_items) {
+		HTONS(record->sequenceId);
+		timestamp_host2net(&record->delayOriginTimestamp);
+		host2net64_unaligned(&record->totalCorrectionField);
+		timestamp_host2net(&record->delayResponseTimestamp);
+		n_items--;
+		record++;
+	}
+}
+
 static int slave_rx_sync_timing_data_post_revc(struct tlv_extra *extra)
 {
 	struct slave_rx_sync_timing_data_tlv *slave_data =
@@ -819,6 +868,10 @@ int tlv_post_recv(struct tlv_extra *extra)
 		break;
 	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
 	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
+		break;
+	case TLV_SLAVE_DELAY_TIMING_DATA_NP:
+		result = slave_delay_timing_data_post_revc(extra);
+		break;
 	case TLV_CUMULATIVE_RATE_RATIO:
 	case TLV_PAD:
 	case TLV_AUTHENTICATION:
@@ -879,6 +932,10 @@ void tlv_pre_send(struct TLV *tlv, struct tlv_extra *extra)
 		break;
 	case TLV_SLAVE_RX_SYNC_COMPUTED_DATA:
 	case TLV_SLAVE_TX_EVENT_TIMESTAMPS:
+		break;
+	case TLV_SLAVE_DELAY_TIMING_DATA_NP:
+		slave_delay_timing_data_pre_send(extra);
+		break;
 	case TLV_CUMULATIVE_RATE_RATIO:
 	case TLV_PAD:
 	case TLV_AUTHENTICATION:
diff --git a/tlv.h b/tlv.h
index 8212325..a205119 100644
--- a/tlv.h
+++ b/tlv.h
@@ -50,6 +50,7 @@
 #define TLV_SLAVE_RX_SYNC_TIMING_DATA			0x8004
 #define TLV_SLAVE_RX_SYNC_COMPUTED_DATA			0x8005
 #define TLV_SLAVE_TX_EVENT_TIMESTAMPS			0x8006
+#define TLV_SLAVE_DELAY_TIMING_DATA_NP			0x7F00
 #define TLV_CUMULATIVE_RATE_RATIO			0x8007
 #define TLV_PAD						0x8008
 #define TLV_AUTHENTICATION				0x8009
@@ -237,6 +238,25 @@ struct request_unicast_xmit_tlv {
 	UInteger32      durationField;
 } PACKED;
 
+struct slave_delay_timing_record {
+	UInteger16          sequenceId;
+	struct Timestamp    delayOriginTimestamp;
+	TimeInterval        totalCorrectionField;
+	struct Timestamp    delayResponseTimestamp;
+} PACKED;
+
+struct slave_delay_timing_data_tlv {
+	Enumeration16        type;
+	UInteger16           length;
+	struct PortIdentity  sourcePortIdentity;
+	struct slave_delay_timing_record record[0];
+} PACKED;
+
+#define SLAVE_DELAY_TIMING_MAX \
+	((sizeof(struct message_data) - sizeof(struct signaling_msg) -	\
+	  sizeof(struct slave_delay_timing_data_tlv)) /		\
+	 sizeof(struct slave_delay_timing_record))
+
 struct slave_rx_sync_timing_record {
 	UInteger16          sequenceId;
 	struct Timestamp    syncOriginTimestamp;
-- 
2.17.1


From 4466d7b8ab6e88f36f0768563640194b0b65825b Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 16 Apr 2020 14:24:19 -0700
Subject: [PATCH 146/173] monitor: Add support for slave delay timing data TLV.

The slave delay timing data TLV provides the delay time stamps along with
the associated correction field.  This patch introduces a method to allow
publication of these values to a remote monitor.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 monitor.c | 60 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 monitor.h |  3 +++
 2 files changed, 63 insertions(+)

diff --git a/monitor.c b/monitor.c
index 5706e5d..ed451ac 100644
--- a/monitor.c
+++ b/monitor.c
@@ -21,6 +21,8 @@ struct monitor_message {
 struct monitor {
 	struct port *dst_port;
 	struct slave_rx_sync_timing_data_tlv *sync_tlv;
+	struct slave_delay_timing_data_tlv *delay_tlv;
+	struct monitor_message delay;
 	struct monitor_message sync;
 };
 
@@ -79,6 +81,23 @@ static struct tlv_extra *monitor_init_message(struct monitor_message *mm,
 	return extra;
 }
 
+static int monitor_init_delay(struct monitor *monitor, struct address address)
+{
+	const size_t tlv_size = sizeof(struct slave_delay_timing_data_tlv) +
+		sizeof(struct slave_delay_timing_record) * RECORDS_PER_MESSAGE;
+	struct tlv_extra *extra;
+
+	extra = monitor_init_message(&monitor->delay, monitor->dst_port,
+				     TLV_SLAVE_DELAY_TIMING_DATA_NP, tlv_size,
+				     address);
+	if (!extra) {
+		return -1;
+	}
+	monitor->delay_tlv = (struct slave_delay_timing_data_tlv *) extra->tlv;
+
+	return 0;
+}
+
 static int monitor_init_sync(struct monitor *monitor, struct address address)
 {
 	const size_t tlv_size = sizeof(struct slave_rx_sync_timing_data_tlv) +
@@ -120,7 +139,12 @@ struct monitor *monitor_create(struct config *config, struct port *dst)
 
 	monitor->dst_port = dst;
 
+	if (monitor_init_delay(monitor, address)) {
+		free(monitor);
+		return NULL;
+	}
 	if (monitor_init_sync(monitor, address)) {
+		msg_put(monitor->delay.msg);
 		free(monitor);
 		return NULL;
 	}
@@ -128,8 +152,44 @@ struct monitor *monitor_create(struct config *config, struct port *dst)
 	return monitor;
 }
 
+int monitor_delay(struct monitor *monitor, struct PortIdentity source_pid,
+		  uint16_t seqid, tmv_t t3, tmv_t corr, tmv_t t4)
+{
+	struct slave_delay_timing_record *record;
+	struct ptp_message *msg;
+
+	if (!monitor_active(monitor)) {
+		return 0;
+	}
+
+	msg = monitor->delay.msg;
+
+	if (!pid_eq(&monitor->delay_tlv->sourcePortIdentity, &source_pid)) {
+		/* There was a change in remote master. Drop stale records. */
+		memcpy(&monitor->delay_tlv->sourcePortIdentity, &source_pid,
+		       sizeof(monitor->delay_tlv->sourcePortIdentity));
+		monitor->delay.count = 0;
+	}
+
+	record = monitor->delay_tlv->record + monitor->delay.count;
+	record->sequenceId                  = seqid;
+	record->delayOriginTimestamp        = tmv_to_Timestamp(t3);
+	record->totalCorrectionField        = tmv_to_TimeInterval(corr);
+	record->delayResponseTimestamp      = tmv_to_Timestamp(t4);
+
+	monitor->delay.count++;
+	if (monitor->delay.count == monitor->delay.records_per_msg) {
+		monitor->delay.count = 0;
+		return monitor_forward(monitor->dst_port, msg);
+	}
+	return 0;
+}
+
 void monitor_destroy(struct monitor *monitor)
 {
+	if (monitor->delay.msg) {
+		msg_put(monitor->delay.msg);
+	}
 	if (monitor->sync.msg) {
 		msg_put(monitor->sync.msg);
 	}
diff --git a/monitor.h b/monitor.h
index e2a6ca3..c489aa9 100644
--- a/monitor.h
+++ b/monitor.h
@@ -14,6 +14,9 @@ struct monitor;
 
 struct monitor *monitor_create(struct config *config, struct port *dst);
 
+int monitor_delay(struct monitor *monitor, struct PortIdentity source_pid,
+		  uint16_t seqid, tmv_t t3, tmv_t corr, tmv_t t4);
+
 void monitor_destroy(struct monitor *monitor);
 
 int monitor_sync(struct monitor *monitor, struct PortIdentity source_pid,
-- 
2.17.1


From 271a6d53f69f1c3e5a05ca07421b8e6cc94f4155 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Thu, 16 Apr 2020 14:38:52 -0700
Subject: [PATCH 147/173] port: Support slave event monitoring of delay timing
 data.

After a successful message exchange, the delay measurement values are
processed by the port code.  This patch makes the values available to a
monitor by calling the appropriate method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/port.c b/port.c
index a74937c..729cbd7 100644
--- a/port.c
+++ b/port.c
@@ -1952,6 +1952,9 @@ void process_delay_resp(struct port *p, struct ptp_message *m)
 	t4 = timestamp_to_tmv(m->ts.pdu);
 	t4c = tmv_sub(t4, c3);
 
+	monitor_delay(p->slave_event_monitor, clock_parent_identity(p->clock),
+		      m->header.sequenceId, t3, c3, t4);
+
 	clock_path_delay(p->clock, t3, t4c);
 
 	TAILQ_REMOVE(&p->delay_req, req, list);
-- 
2.17.1


From 6eb9898f61472dc15bae3cd2a47a774d53fa1080 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 15 Apr 2020 10:54:43 -0700
Subject: [PATCH 148/173] pmc: Show slave delay timing data TLVs attached to
 signaling messages.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 pmc.c | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/pmc.c b/pmc.c
index 8e30b1c..65d1d61 100644
--- a/pmc.c
+++ b/pmc.c
@@ -58,6 +58,20 @@ static char *bin2str(Octet *data, int len)
 #define SHOW_TIMESTAMP(ts) \
 	((uint64_t)ts.seconds_lsb) | (((uint64_t)ts.seconds_msb) << 32), ts.nanoseconds
 
+static void pmc_show_delay_timing(struct slave_delay_timing_record *record,
+				  FILE *fp)
+{
+	fprintf(fp,
+		IFMT "sequenceId                 %hu"
+		IFMT "delayOriginTimestamp       %" PRId64 ".%09u"
+		IFMT "totalCorrectionField       %" PRId64
+		IFMT "delayResponseTimestamp     %" PRId64 ".%09u",
+		record->sequenceId,
+		SHOW_TIMESTAMP(record->delayOriginTimestamp),
+		record->totalCorrectionField << 16,
+		SHOW_TIMESTAMP(record->delayResponseTimestamp));
+}
+
 static void pmc_show_rx_sync_timing(struct slave_rx_sync_timing_record *record,
 				    FILE *fp)
 {
@@ -77,7 +91,9 @@ static void pmc_show_rx_sync_timing(struct slave_rx_sync_timing_record *record,
 static void pmc_show_signaling(struct ptp_message *msg, FILE *fp)
 {
 	struct slave_rx_sync_timing_record *sync_record;
+	struct slave_delay_timing_record *delay_record;
 	struct slave_rx_sync_timing_data_tlv *srstd;
+	struct slave_delay_timing_data_tlv *sdtdt;
 	struct tlv_extra *extra;
 	int i, cnt;
 
@@ -100,6 +116,19 @@ static void pmc_show_signaling(struct ptp_message *msg, FILE *fp)
 				sync_record++;
 			}
 			break;
+		case TLV_SLAVE_DELAY_TIMING_DATA_NP:
+			sdtdt = (struct slave_delay_timing_data_tlv *) extra->tlv;
+			cnt = (sdtdt->length - sizeof(sdtdt->sourcePortIdentity)) /
+				sizeof(*delay_record);
+			fprintf(fp, "SLAVE_DELAY_TIMING_DATA_NP N %d "
+				IFMT "sourcePortIdentity         %s",
+				cnt, pid2str(&sdtdt->sourcePortIdentity));
+			delay_record = sdtdt->record;
+			for (i = 0; i < cnt; i++) {
+				pmc_show_delay_timing(delay_record, fp);
+				delay_record++;
+			}
+			break;
 		default:
 			break;
 		}
-- 
2.17.1


From 7de73fefc378cc42b9ed1115b3afa409d0250a48 Mon Sep 17 00:00:00 2001
From: Christian Eggers <ceggers@arri.de>
Date: Tue, 2 Jun 2020 15:01:20 +0200
Subject: [PATCH 149/173] Fix printf if time_t is long long

On some platforms, time_t has recently switched from "long" to "long
long" [1]. For these platforms it is necessary to use "%lld" as printf
format specifier because the ABI differs between "long" and "long long".

I found no way for creating something similar to PRId64 for time_t. No
idea how to determine whether it's "long" or "long long". So I cast
everything to "long long" instead.

[1] https://git.musl-libc.org/cgit/musl/commit/?id=38143339646a4ccce8afe298c34467767c899f51

Signed-off-by: Christian Eggers <ceggers@arri.de>
---
 phc_ctl.c         |  8 ++++----
 print.c           |  8 ++++----
 unicast_client.c  |  4 ++--
 unicast_service.c | 16 ++++++++--------
 4 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/phc_ctl.c b/phc_ctl.c
index 149ee9e..9191342 100644
--- a/phc_ctl.c
+++ b/phc_ctl.c
@@ -197,8 +197,8 @@ static int do_set(clockid_t clkid, int cmdc, char *cmdv[])
 			strerror(errno));
 		return -1;
 	} else {
-		pr_notice("set clock time to %ld.%09ld or %s",
-			ts.tv_sec, ts.tv_nsec, ctime(&ts.tv_sec));
+		pr_notice("set clock time to %lld.%09ld or %s",
+			(long long)ts.tv_sec, ts.tv_nsec, ctime(&ts.tv_sec));
 	}
 
 	return args_to_eat;
@@ -215,8 +215,8 @@ static int do_get(clockid_t clkid, int cmdc, char *cmdv[])
 
 		return -1;
 	} else {
-		pr_notice("clock time is %ld.%09lu or %s",
-			ts.tv_sec, ts.tv_nsec, ctime(&ts.tv_sec));
+		pr_notice("clock time is %lld.%09lu or %s",
+			(long long)ts.tv_sec, ts.tv_nsec, ctime(&ts.tv_sec));
 	}
 
 	/* get operation does not require any arguments */
diff --git a/print.c b/print.c
index 6c48e1e..c428895 100644
--- a/print.c
+++ b/print.c
@@ -73,16 +73,16 @@ void print(int level, char const *format, ...)
 
 	if (verbose) {
 		f = level >= LOG_NOTICE ? stdout : stderr;
-		fprintf(f, "%s[%ld.%03ld]: %s%s%s\n",
+		fprintf(f, "%s[%lld.%03ld]: %s%s%s\n",
 			progname ? progname : "",
-			ts.tv_sec, ts.tv_nsec / 1000000,
+			(long long)ts.tv_sec, ts.tv_nsec / 1000000,
 			message_tag ? message_tag : "", message_tag ? " " : "",
 			buf);
 		fflush(f);
 	}
 	if (use_syslog) {
-		syslog(level, "[%ld.%03ld] %s%s%s",
-		       ts.tv_sec, ts.tv_nsec / 1000000,
+		syslog(level, "[%lld.%03ld] %s%s%s",
+		       (long long)ts.tv_sec, ts.tv_nsec / 1000000,
 		       message_tag ? message_tag : "", message_tag ? " " : "",
 		       buf);
 	}
diff --git a/unicast_client.c b/unicast_client.c
index 67e50ce..98ccc89 100644
--- a/unicast_client.c
+++ b/unicast_client.c
@@ -207,7 +207,7 @@ static void unicast_client_set_renewal(struct port *p,
 				       long duration)
 {
 	struct timespec now;
-	long tmo;
+	time_t tmo;
 
 	if (clock_gettime(CLOCK_MONOTONIC, &now)) {
 		pr_err("clock_gettime failed: %m");
@@ -217,7 +217,7 @@ static void unicast_client_set_renewal(struct port *p,
 	tmo = now.tv_sec + duration;
 	if (!master->renewal_tmo || tmo < master->renewal_tmo) {
 		master->renewal_tmo = tmo;
-		pr_debug("port %d: renewal timeout at %ld", portnum(p), tmo);
+		pr_debug("port %d: renewal timeout at %lld", portnum(p), (long long)tmo);
 	}
 }
 
diff --git a/unicast_service.c b/unicast_service.c
index ec5ee6c..d42c549 100644
--- a/unicast_service.c
+++ b/unicast_service.c
@@ -209,9 +209,9 @@ static void unicast_service_extend(struct unicast_client_address *client,
 	tmo = now.tv_sec + req->durationField;
 	if (tmo > client->grant_tmo) {
 		client->grant_tmo = tmo;
-		pr_debug("%s grant of 0x%x extended to %ld",
+		pr_debug("%s grant of 0x%x extended to %lld",
 			 pid2str(&client->portIdentity),
-			 client->message_types, tmo);
+			 client->message_types, (long long)tmo);
 	}
 }
 
@@ -226,8 +226,8 @@ static int unicast_service_rearm_timer(struct port *p)
 	interval = pqueue_peek(p->unicast_service->queue);
 	if (interval) {
 		tmo.it_value = interval->tmo;
-		pr_debug("arming timer tmo={%ld,%ld}",
-			 interval->tmo.tv_sec, interval->tmo.tv_nsec);
+		pr_debug("arming timer tmo={%lld,%ld}",
+			 (long long)interval->tmo.tv_sec, interval->tmo.tv_nsec);
 	} else {
 		pr_debug("stopping unicast service timer");
 	}
@@ -499,8 +499,8 @@ int unicast_service_timer(struct port *p)
 
 	while ((interval = pqueue_peek(p->unicast_service->queue)) != NULL) {
 
-		pr_debug("peek i={2^%d} tmo={%ld,%ld}", interval->log_period,
-			 interval->tmo.tv_sec, interval->tmo.tv_nsec);
+		pr_debug("peek i={2^%d} tmo={%lld,%ld}", interval->log_period,
+			 (long long)interval->tmo.tv_sec, interval->tmo.tv_nsec);
 
 		if (timespec_compare(&now, &interval->tmo) > 0) {
 			break;
@@ -519,8 +519,8 @@ int unicast_service_timer(struct port *p)
 		}
 
 		interval_increment(interval);
-		pr_debug("next i={2^%d} tmo={%ld,%ld}", interval->log_period,
-			 interval->tmo.tv_sec, interval->tmo.tv_nsec);
+		pr_debug("next i={2^%d} tmo={%lld,%ld}", interval->log_period,
+			 (long long)interval->tmo.tv_sec, interval->tmo.tv_nsec);
 		pqueue_insert(p->unicast_service->queue, interval);
 	}
 
-- 
2.17.1


From 7c49882e348ef05dfd6a1d10f86a837615527500 Mon Sep 17 00:00:00 2001
From: Werner Macho <werner.macho@gmail.com>
Date: Mon, 15 Jun 2020 14:14:54 +0100
Subject: [PATCH 150/173] fix small typo

Signed-off-by: Werner Macho <werner.macho@gmail.com>
---
 phc_ctl.8 | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/phc_ctl.8 b/phc_ctl.8
index 609dbab..650e661 100644
--- a/phc_ctl.8
+++ b/phc_ctl.8
@@ -66,7 +66,7 @@ it.
 Compare the PHC clock device to CLOCK_REALTIME, using the best method available.
 .TP
 .BI caps
-Display the device capabiltiies. This is the default command if no commands are
+Display the device capabilities. This is the default command if no commands are
 provided.
 .TP
 .BI wait " seconds"
-- 
2.17.1


From 5cca24bc07ff9ff1a5eb2665d62334ec70de1a1d Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Mon, 15 Jun 2020 18:23:19 +0300
Subject: [PATCH 151/173] ptp4l: call recvmsg() with the MSG_DONTWAIT flag

The application's main event loop (clock_poll) is woken up by poll() and
dispatches the socket receive queue events to the corresponding ports as
needed.

So it is a bug if poll() wakes up the process for data availability on a
socket's receive queue, and then recvmsg(), called immediately
afterwards, goes to sleep trying to retrieve it. This patch will
generate an error that will be propagated to the user if this condition
happens.

Can it happen?

As of this patch, ptp4l uses the SO_SELECT_ERR_QUEUE socket option,
which means that poll() will wake the process up, with revents ==
(POLLIN | POLLERR), if data is available in the error queue. But
clock_poll() does not check POLLERR, just POLLIN, and draws the wrong
conclusion that there is data available in the receive queue (when it is
in fact available in the error queue).

When the above condition happens, recvmsg() will sleep typically for a
whole sync interval waiting for data on the event socket, and will be
woken up when the new real frame arrives. It will not dequeue follow-up
messages during this time (which are sent to the general message socket)
and when it does, it will already be late for them (their seqid will be
out of order). So it will drop them and everything that comes after. The
synchronization process will fail.

The above condition shouldn't typically happen, but exceptional kernel
events will trigger it. It helps to be strict in ptp4l in order for
those events to not blow up in even stranger symptoms unrelated to the
root cause of the problem.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 raw.c  | 2 +-
 udp.c  | 2 +-
 udp6.c | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/raw.c b/raw.c
index 15c9756..0bd15b0 100644
--- a/raw.c
+++ b/raw.c
@@ -279,7 +279,7 @@ static int raw_recv(struct transport *t, int fd, void *buf, int buflen,
 	buflen += hlen;
 	hdr = (struct eth_hdr *) ptr;
 
-	cnt = sk_receive(fd, ptr, buflen, addr, hwts, 0);
+	cnt = sk_receive(fd, ptr, buflen, addr, hwts, MSG_DONTWAIT);
 
 	if (cnt >= 0)
 		cnt -= hlen;
diff --git a/udp.c b/udp.c
index 36802fb..826bd12 100644
--- a/udp.c
+++ b/udp.c
@@ -210,7 +210,7 @@ no_event:
 static int udp_recv(struct transport *t, int fd, void *buf, int buflen,
 		    struct address *addr, struct hw_timestamp *hwts)
 {
-	return sk_receive(fd, buf, buflen, addr, hwts, 0);
+	return sk_receive(fd, buf, buflen, addr, hwts, MSG_DONTWAIT);
 }
 
 static int udp_send(struct transport *t, struct fdarray *fda,
diff --git a/udp6.c b/udp6.c
index 744a5bc..ba5482e 100644
--- a/udp6.c
+++ b/udp6.c
@@ -227,7 +227,7 @@ no_event:
 static int udp6_recv(struct transport *t, int fd, void *buf, int buflen,
 		     struct address *addr, struct hw_timestamp *hwts)
 {
-	return sk_receive(fd, buf, buflen, addr, hwts, 0);
+	return sk_receive(fd, buf, buflen, addr, hwts, MSG_DONTWAIT);
 }
 
 static int udp6_send(struct transport *t, struct fdarray *fda,
-- 
2.17.1


From bf0a644b991b42aaa56b88e2f2180b7d81318c5c Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Mon, 15 Jun 2020 18:23:21 +0300
Subject: [PATCH 152/173] port: print sync/follow-up mismatch events

ptp4l is too silent when receiving, for whatever reason, out of order
messages. If the reordering is persistent (which is either a broken
network, or a broken kernel), the behavior looks like a complete
synchronization stall, since the application is designed to never
attempt to recover from such a condition.

At least save some people some debugging hours and print when the
application reaches this code path. Since it's a debugging tool, we
don't want to create false alarms when the occasional packet gets
reordered in a production system, but have this information readily
available when the program's log level is set to debug, instead of
having users fish for it with code instrumentation.

[ RC - corrected printf format for sequence id. ]

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 port.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/port.c b/port.c
index 729cbd7..fa49663 100644
--- a/port.c
+++ b/port.c
@@ -1215,6 +1215,23 @@ static void port_synchronize(struct port *p,
 	}
 }
 
+static void port_syfufsm_print_mismatch(struct port *p, enum syfu_event event,
+					struct ptp_message *m)
+{
+	int expected_msgtype;
+
+	if (event == SYNC_MISMATCH)
+		expected_msgtype = FOLLOW_UP;
+	else
+		expected_msgtype = SYNC;
+
+	pr_debug("port %hu: have %s %hu, expecting %s but got %s %hu, dropping",
+		 portnum(p), msg_type_string(msg_type(p->last_syncfup)),
+		 p->last_syncfup->header.sequenceId,
+		 msg_type_string(expected_msgtype),
+		 msg_type_string(msg_type(m)), m->header.sequenceId);
+}
+
 /*
  * Handle out of order packets. The network stack might
  * provide the follow up _before_ the sync message. After all,
@@ -1249,6 +1266,7 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 	case SF_HAVE_SYNC:
 		switch (event) {
 		case SYNC_MISMATCH:
+			port_syfufsm_print_mismatch(p, event, m);
 			msg_put(p->last_syncfup);
 			msg_get(m);
 			p->last_syncfup = m;
@@ -1256,6 +1274,7 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 		case SYNC_MATCH:
 			break;
 		case FUP_MISMATCH:
+			port_syfufsm_print_mismatch(p, event, m);
 			msg_put(p->last_syncfup);
 			msg_get(m);
 			p->last_syncfup = m;
@@ -1277,6 +1296,7 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 	case SF_HAVE_FUP:
 		switch (event) {
 		case SYNC_MISMATCH:
+			port_syfufsm_print_mismatch(p, event, m);
 			msg_put(p->last_syncfup);
 			msg_get(m);
 			p->last_syncfup = m;
@@ -1293,6 +1313,7 @@ static void port_syfufsm(struct port *p, enum syfu_event event,
 			p->syfu = SF_EMPTY;
 			break;
 		case FUP_MISMATCH:
+			port_syfufsm_print_mismatch(p, event, m);
 			msg_put(p->last_syncfup);
 			msg_get(m);
 			p->last_syncfup = m;
-- 
2.17.1


From b6fa2222016f807b4b4b704829cd048af8824513 Mon Sep 17 00:00:00 2001
From: Georg Sauthoff <mail@gms.tf>
Date: Sun, 21 Jun 2020 11:14:45 +0200
Subject: [PATCH 153/173] Eliminate isort

This saves a few bytes of static storage and less instructions are
executed when looking for the best offset.

Signed-off-by: Georg Sauthoff <mail@gms.tf>
---
 sysoff.c | 55 +++++++++++++++++++++++++++----------------------------
 1 file changed, 27 insertions(+), 28 deletions(-)

diff --git a/sysoff.c b/sysoff.c
index 05d2ed6..ec77a0d 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -34,12 +34,6 @@ static int64_t pctns(struct ptp_clock_time *t)
 	return t->sec * NS_PER_SEC + t->nsec;
 }
 
-static struct {
-	int64_t interval;
-	int64_t offset;
-	uint64_t timestamp;
-} samples[PTP_MAX_SAMPLES];
-
 static int sysoff_precise(int fd, int64_t *result, uint64_t *ts)
 {
 #ifdef PTP_SYS_OFFSET_PRECISE
@@ -57,28 +51,28 @@ static int sysoff_precise(int fd, int64_t *result, uint64_t *ts)
 #endif
 }
 
-static void insertion_sort(int length, int64_t interval, int64_t offset, uint64_t ts)
-{
-	int i = length - 1;
-	while (i >= 0) {
-		if (samples[i].interval < interval)
-			break;
-		samples[i+1] = samples[i];
-		i--;
-	}
-	samples[i+1].interval = interval;
-	samples[i+1].offset = offset;
-	samples[i+1].timestamp = ts;
-}
-
 static int64_t sysoff_estimate(struct ptp_clock_time *pct, int extended,
 			       int n_samples, uint64_t *ts, int64_t *delay)
 {
 	int64_t t1, t2, tp;
-	int64_t interval, offset;
-	int i;
+	int64_t interval, timestamp, offset;
+	int64_t shortest_interval, best_timestamp, best_offset;
+	int i = 0;
+
+	if (extended) {
+		t1 = pctns(&pct[3*i]);
+		tp = pctns(&pct[3*i+1]);
+		t2 = pctns(&pct[3*i+2]);
+	} else {
+		t1 = pctns(&pct[2*i]);
+		tp = pctns(&pct[2*i+1]);
+		t2 = pctns(&pct[2*i+2]);
+	}
+	shortest_interval = t2 - t1;
+	best_timestamp = (t2 + t1) / 2;
+	best_offset = best_timestamp - tp;
 
-	for (i = 0; i < n_samples; i++) {
+	for (i = 1; i < n_samples; i++) {
 		if (extended) {
 			t1 = pctns(&pct[3*i]);
 			tp = pctns(&pct[3*i+1]);
@@ -89,12 +83,17 @@ static int64_t sysoff_estimate(struct ptp_clock_time *pct, int extended,
 			t2 = pctns(&pct[2*i+2]);
 		}
 		interval = t2 - t1;
-		offset = (t2 + t1) / 2 - tp;
-		insertion_sort(i, interval, offset, (t2 + t1) / 2);
+		timestamp = (t2 + t1) / 2;
+		offset = timestamp - tp;
+		if (interval < shortest_interval) {
+			shortest_interval = interval;
+			best_timestamp = timestamp;
+			best_offset = offset;
+		}
 	}
-	*ts = samples[0].timestamp;
-	*delay = samples[0].interval;
-	return samples[0].offset;
+	*ts = best_timestamp;
+	*delay = shortest_interval;
+	return best_offset;
 }
 
 static int sysoff_extended(int fd, int n_samples,
-- 
2.17.1


From cb3fbc1010d5dafa0e2582767502b21d5e136866 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 24 Jun 2020 08:59:31 -0700
Subject: [PATCH 154/173] Catch unexpected socket polling errors.

The poll(2) system call may set POLLERR in the returned events.  Normally
no errors are returned unless specifically requested by setting an
appropriate socket option.  Nevertheless, the poll(2) API is quite generic,
and there is no guarantee that the kernel networking stack might push an
error event one day.  This patch adds defensive code in order to catch any
unexpected error condition.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 clock.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/clock.c b/clock.c
index f43cc2a..a66d189 100644
--- a/clock.c
+++ b/clock.c
@@ -1559,8 +1559,14 @@ int clock_poll(struct clock *c)
 	LIST_FOREACH(p, &c->ports, list) {
 		/* Let the ports handle their events. */
 		for (i = 0; i < N_POLLFD; i++) {
-			if (cur[i].revents & (POLLIN|POLLPRI)) {
-				event = port_event(p, i);
+			if (cur[i].revents & (POLLIN|POLLPRI|POLLERR)) {
+				if (cur[i].revents & POLLERR) {
+					pr_err("port %d: unexpected socket error",
+					       port_number(p));
+					event = EV_FAULT_DETECTED;
+				} else {
+					event = port_event(p, i);
+				}
 				if (EV_STATE_DECISION_EVENT == event) {
 					c->sde = 1;
 				}
-- 
2.17.1


From 61c6a708980217119e829e4b41ea2504e673e4fb Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Thu, 25 Jun 2020 01:21:34 +0300
Subject: [PATCH 155/173] phc2sys: provide missing kernel headers for sysoff
 functionality

Currently it is very finicky to deploy linuxptp in an automated build
system and make KBUILD_OUTPUT pick up the output of "make
headers_install" in order for the application to make full use of the
features exposed by the runtime kernel. And the toolchain/libc will
almost certainly never contain recent enough kernel headers to be of any
use here. And there's no good reason for that: the application can probe
at runtime for the sysoff methods supported by the kernel anyway.

So let's provide the kernel definitions for sysoff, sysoff_precise and
sysoff_extended, such that SYSOFF_COMPILE_TIME_MISSING is not something
that will bother us any longer.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 missing.h | 52 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 sysoff.c  | 27 +--------------------------
 sysoff.h  |  2 +-
 3 files changed, 54 insertions(+), 27 deletions(-)

diff --git a/missing.h b/missing.h
index bc708cb..35eaf15 100644
--- a/missing.h
+++ b/missing.h
@@ -97,6 +97,58 @@ struct compat_ptp_clock_caps {
 
 #endif /*LINUX_VERSION_CODE < 5.8*/
 
+#ifndef PTP_MAX_SAMPLES
+#define PTP_MAX_SAMPLES 25 /* Maximum allowed offset measurement samples. */
+#endif /* PTP_MAX_SAMPLES */
+
+#ifndef PTP_SYS_OFFSET
+
+#define PTP_SYS_OFFSET     _IOW(PTP_CLK_MAGIC, 5, struct ptp_sys_offset)
+
+struct ptp_sys_offset {
+	unsigned int n_samples; /* Desired number of measurements. */
+	unsigned int rsv[3];    /* Reserved for future use. */
+	/*
+	 * Array of interleaved system/phc time stamps. The kernel
+	 * will provide 2*n_samples + 1 time stamps, with the last
+	 * one as a system time stamp.
+	 */
+	struct ptp_clock_time ts[2 * PTP_MAX_SAMPLES + 1];
+};
+
+#endif /* PTP_SYS_OFFSET */
+
+#ifndef PTP_SYS_OFFSET_PRECISE
+
+#define PTP_SYS_OFFSET_PRECISE \
+	_IOWR(PTP_CLK_MAGIC, 8, struct ptp_sys_offset_precise)
+
+struct ptp_sys_offset_precise {
+	struct ptp_clock_time device;
+	struct ptp_clock_time sys_realtime;
+	struct ptp_clock_time sys_monoraw;
+	unsigned int rsv[4];    /* Reserved for future use. */
+};
+
+#endif /* PTP_SYS_OFFSET_PRECISE */
+
+#ifndef PTP_SYS_OFFSET_EXTENDED
+
+#define PTP_SYS_OFFSET_EXTENDED \
+	_IOWR(PTP_CLK_MAGIC, 9, struct ptp_sys_offset_extended)
+
+struct ptp_sys_offset_extended {
+	unsigned int n_samples; /* Desired number of measurements. */
+	unsigned int rsv[3];    /* Reserved for future use. */
+	/*
+	 * Array of [system, phc, system] time stamps. The kernel will provide
+	 * 3*n_samples time stamps.
+	 */
+	struct ptp_clock_time ts[PTP_MAX_SAMPLES][3];
+};
+
+#endif /* PTP_SYS_OFFSET_EXTENDED */
+
 #ifndef PTP_PIN_SETFUNC
 
 enum ptp_pin_function {
diff --git a/sysoff.c b/sysoff.c
index ec77a0d..2743859 100644
--- a/sysoff.c
+++ b/sysoff.c
@@ -27,8 +27,6 @@
 
 #define NS_PER_SEC 1000000000LL
 
-#ifdef PTP_SYS_OFFSET
-
 static int64_t pctns(struct ptp_clock_time *t)
 {
 	return t->sec * NS_PER_SEC + t->nsec;
@@ -36,7 +34,6 @@ static int64_t pctns(struct ptp_clock_time *t)
 
 static int sysoff_precise(int fd, int64_t *result, uint64_t *ts)
 {
-#ifdef PTP_SYS_OFFSET_PRECISE
 	struct ptp_sys_offset_precise pso;
 	memset(&pso, 0, sizeof(pso));
 	if (ioctl(fd, PTP_SYS_OFFSET_PRECISE, &pso)) {
@@ -46,9 +43,6 @@ static int sysoff_precise(int fd, int64_t *result, uint64_t *ts)
 	*result = pctns(&pso.sys_realtime) - pctns(&pso.device);
 	*ts = pctns(&pso.sys_realtime);
 	return SYSOFF_PRECISE;
-#else
-	return SYSOFF_COMPILE_TIME_MISSING;
-#endif
 }
 
 static int64_t sysoff_estimate(struct ptp_clock_time *pct, int extended,
@@ -99,7 +93,6 @@ static int64_t sysoff_estimate(struct ptp_clock_time *pct, int extended,
 static int sysoff_extended(int fd, int n_samples,
 			   int64_t *result, uint64_t *ts, int64_t *delay)
 {
-#ifdef PTP_SYS_OFFSET_EXTENDED
 	struct ptp_sys_offset_extended pso;
 	memset(&pso, 0, sizeof(pso));
 	pso.n_samples = n_samples;
@@ -109,9 +102,6 @@ static int sysoff_extended(int fd, int n_samples,
 	}
 	*result = sysoff_estimate(&pso.ts[0][0], 1, n_samples, ts, delay);
 	return SYSOFF_EXTENDED;
-#else
-	return SYSOFF_COMPILE_TIME_MISSING;
-#endif
 }
 
 static int sysoff_basic(int fd, int n_samples,
@@ -140,7 +130,7 @@ int sysoff_measure(int fd, int method, int n_samples,
 	case SYSOFF_BASIC:
 		return sysoff_basic(fd, n_samples, result, ts, delay);
 	}
-	return SYSOFF_COMPILE_TIME_MISSING;
+	return SYSOFF_RUN_TIME_MISSING;
 }
 
 int sysoff_probe(int fd, int n_samples)
@@ -164,18 +154,3 @@ int sysoff_probe(int fd, int n_samples)
 
 	return SYSOFF_RUN_TIME_MISSING;
 }
-
-#else /* !PTP_SYS_OFFSET */
-
-int sysoff_measure(int fd, int method, int n_samples,
-		   int64_t *result, uint64_t *ts, int64_t *delay)
-{
-	return SYSOFF_COMPILE_TIME_MISSING;
-}
-
-int sysoff_probe(int fd, int n_samples)
-{
-	return SYSOFF_COMPILE_TIME_MISSING;
-}
-
-#endif /* PTP_SYS_OFFSET */
diff --git a/sysoff.h b/sysoff.h
index 79d2290..e4de919 100644
--- a/sysoff.h
+++ b/sysoff.h
@@ -19,9 +19,9 @@
  */
 
 #include <stdint.h>
+#include "missing.h"
 
 enum {
-	SYSOFF_COMPILE_TIME_MISSING = -2,
 	SYSOFF_RUN_TIME_MISSING = -1,
 	SYSOFF_PRECISE,
 	SYSOFF_EXTENDED,
-- 
2.17.1


From 278d9f45ab2e89e6887b27768d2a69ebdd54a9ce Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 22 Jul 2020 14:49:05 -0700
Subject: [PATCH 156/173] ts2phc: Use proper close method on the error path.

When creating a ts2phc slave, a clock is obtained by invoking the
posix_clock_open() method.  However, in case of an error, the same clock
is closed again by calling close(2) on the associated file descriptor
directly.  While not incorrect, still the code should instead use the
close function that matches the open method.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_slave.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/ts2phc_slave.c b/ts2phc_slave.c
index 82848d0..22d00cd 100644
--- a/ts2phc_slave.c
+++ b/ts2phc_slave.c
@@ -223,7 +223,7 @@ no_ext_ts:
 no_pin_func:
 	servo_destroy(slave->servo);
 no_servo:
-	close(slave->fd);
+	posix_clock_close(slave->clk);
 no_posix_clock:
 	free(slave->name);
 	free(slave);
-- 
2.17.1


From 70c32043a53cac5bb1eb96e4ef5947e63a6eb405 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 22 Jul 2020 14:52:48 -0700
Subject: [PATCH 157/173] ts2phc: Fix memory leak.

Each slave creates an instance of a servo.  However, when cleaning up, the
code neglected to free the servo, resulting in a memory leak.  This patch
fixes the issue by calling the appropriate method to destroy the servo.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_slave.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/ts2phc_slave.c b/ts2phc_slave.c
index 22d00cd..71077a7 100644
--- a/ts2phc_slave.c
+++ b/ts2phc_slave.c
@@ -240,6 +240,7 @@ static void ts2phc_slave_destroy(struct ts2phc_slave *slave)
 	if (ioctl(slave->fd, PTP_EXTTS_REQUEST2, &extts)) {
 		pr_err(PTP_EXTTS_REQUEST_FAILED);
 	}
+	servo_destroy(slave->servo);
 	posix_clock_close(slave->clk);
 	free(slave->name);
 	free(slave);
-- 
2.17.1


From 1335db3bded3d424df9ec49919ed355802f6757b Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 22 Jul 2020 14:56:36 -0700
Subject: [PATCH 158/173] ts2phc: Ignore pulses with invalid time stamps.

The API to obtain the time stamp of a PPS source indicates the validity of
the returned value.  However, the current code does not ever test the
validity information in any way.  This patch lets the clients ignore PPS
values that lack a valid time stamp.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_slave.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/ts2phc_slave.c b/ts2phc_slave.c
index 71077a7..749efe5 100644
--- a/ts2phc_slave.c
+++ b/ts2phc_slave.c
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include <linux/ptp_clock.h>
 #include <poll.h>
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdlib.h>
 #include <sys/ioctl.h>
@@ -50,7 +51,7 @@ struct ts2phc_slave_array {
 
 struct ts2phc_source_timestamp {
 	struct timespec ts;
-	int valid;
+	bool valid;
 };
 
 enum extts_result {
@@ -269,6 +270,11 @@ static int ts2phc_slave_event(struct ts2phc_slave *slave,
 		return 0;
 	}
 
+	if (!source_ts.valid) {
+		pr_debug("%s ignoring invalid master time stamp", slave->name);
+		return 0;
+	}
+
 	adj = servo_sample(slave->servo, offset, extts_ts,
 			   SAMPLE_WEIGHT, &slave->state);
 
@@ -398,7 +404,7 @@ int ts2phc_slave_poll(struct ts2phc_master *master)
 {
 	struct ts2phc_source_timestamp source_ts;
 	unsigned int i;
-	int cnt;
+	int cnt, err;
 
 	if (ts2phc_slave_array_create()) {
 		return -1;
@@ -416,7 +422,8 @@ int ts2phc_slave_poll(struct ts2phc_master *master)
 		return 0;
 	}
 
-	source_ts.valid = ts2phc_master_getppstime(master, &source_ts.ts);
+	err = ts2phc_master_getppstime(master, &source_ts.ts);
+	source_ts.valid = err ? false : true;
 
 	for (i = 0; i < ts2phc_n_slaves; i++) {
 		if (polling_array.pfd[i].revents & (POLLIN|POLLPRI)) {
-- 
2.17.1


From 3da961bb112b4d0e823ff125901b5674e7b57c0e Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Wed, 22 Jul 2020 16:14:39 -0700
Subject: [PATCH 159/173] Version 3.0

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 version.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/version.sh b/version.sh
index c4dbc02..57dcd82 100755
--- a/version.sh
+++ b/version.sh
@@ -4,7 +4,7 @@
 # local version information from the git version control system.
 # Adapted from scripts/setlocalversion in the Linux kernel sources.
 #
-major=2
+major=3
 minor=0
 extra=
 
-- 
2.17.1


From 226c285ec42241d2133877346563353f9849274f Mon Sep 17 00:00:00 2001
From: Jacob Keller <jacob.e.keller@intel.com>
Date: Wed, 5 Aug 2020 16:02:08 -0700
Subject: [PATCH 160/173] phc_ctl: display all capability information

The capability command for phc_ctl does not display the number of pins
or the cross timestamping support. Add this as output so that the user
can see the complete device capabilities.

Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
---
 phc_ctl.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/phc_ctl.c b/phc_ctl.c
index 9191342..00d7a1c 100644
--- a/phc_ctl.c
+++ b/phc_ctl.c
@@ -320,12 +320,16 @@ static int do_caps(clockid_t clkid, int cmdc, char *cmdv[])
 		"  %d programable alarms\n"
 		"  %d external time stamp channels\n"
 		"  %d programmable periodic signals\n"
-		"  %s pulse per second support",
+		"  %d configurable input/output pins\n"
+		"  %s pulse per second support\n"
+		"  %s cross timestamping support\n",
 		caps.max_adj,
 		caps.n_alarm,
 		caps.n_ext_ts,
 		caps.n_per_out,
-		caps.pps ? "has" : "doesn't have");
+		caps.n_pins,
+		caps.pps ? "has" : "doesn't have",
+		caps.cross_timestamping ? "has" : "doesn't have");
 	return 0;
 }
 
-- 
2.17.1


From 6325880094f86867dd7a6f41e5df4fd43c02789d Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Tue, 18 Aug 2020 02:19:27 +0300
Subject: [PATCH 161/173] tmv: introduce a conversion helper from
 ptp_clock_time

This is useful when dealing with timestamps returned by various
ancillary PHC ioctl kernel APIs, such as extts.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 tmv.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/tmv.h b/tmv.h
index f4a1a22..9039534 100644
--- a/tmv.h
+++ b/tmv.h
@@ -20,6 +20,7 @@
 #ifndef HAVE_TMV_H
 #define HAVE_TMV_H
 
+#include <linux/ptp_clock.h>
 #include <time.h>
 
 #include "ddt.h"
@@ -160,4 +161,11 @@ static inline tmv_t timestamp_to_tmv(struct timestamp ts)
 	return t;
 }
 
+static inline tmv_t pct_to_tmv(struct ptp_clock_time pct)
+{
+	tmv_t t;
+	t.ns = pct.sec * NS_PER_SEC + pct.nsec;
+	return t;
+}
+
 #endif
-- 
2.17.1


From cef87c6f032de95380c5b2780c3300db383a98e7 Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Tue, 18 Aug 2020 02:19:28 +0300
Subject: [PATCH 162/173] tmv: introduce an initializer from nanoseconds

Interestingly, although tmv_t is a wrapper over nanoseconds, there is no
initializer from a raw nanosecond value. So add one.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 tmv.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/tmv.h b/tmv.h
index 9039534..0c1155f 100644
--- a/tmv.h
+++ b/tmv.h
@@ -112,6 +112,13 @@ static inline int64_t tmv_to_nanoseconds(tmv_t x)
 	return x.ns;
 }
 
+static inline tmv_t nanoseconds_to_tmv(int64_t ns)
+{
+	tmv_t t;
+	t.ns = ns;
+	return t;
+}
+
 static inline TimeInterval tmv_to_TimeInterval(tmv_t x)
 {
 	if (x.ns < (int64_t)MIN_TMV_TO_TIMEINTERVAL) {
-- 
2.17.1


From 380d023abb1fdce0dba9d58ca1abaf2e2de5488f Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Tue, 18 Aug 2020 02:19:29 +0300
Subject: [PATCH 163/173] posix_clock_open: derive PHC index from device name
 if possible

Currently the PHC index is retrieved only through an ethtool ioctl if
the PHC is specified as an Ethernet interface. If it's a char device
such as /dev/ptp5, the phc_index will remain unpopulated. Try to infer
it from the char device's path.

This is useful when trying to determine whether multiple clocks are in
fact the same (such as /dev/ptp3 and sw1p3), just compare their PHC
index.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
---
 util.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/util.c b/util.c
index 296dd59..027d694 100644
--- a/util.c
+++ b/util.c
@@ -211,6 +211,16 @@ clockid_t posix_clock_open(const char *device, int *phc_index)
 	/* check if device is valid phc device */
 	clkid = phc_open(device);
 	if (clkid != CLOCK_INVALID) {
+		if (!strncmp(device, "/dev/ptp", strlen("/dev/ptp"))) {
+			int r = get_ranged_int(device + strlen("/dev/ptp"),
+					       phc_index, 0, 65535);
+			if (r) {
+				fprintf(stderr,
+					"failed to parse PHC index from %s\n",
+					device);
+				return -1;
+			}
+		}
 		return clkid;
 	}
 	/* check if device is a valid ethernet device */
-- 
2.17.1


From 14e09fd9ed1a57ea64279b79a87aae316efa107a Mon Sep 17 00:00:00 2001
From: Vladimir Oltean <olteanv@gmail.com>
Date: Tue, 18 Aug 2020 02:19:30 +0300
Subject: [PATCH 164/173] phc2sys: rename struct node to struct phc2sys_private

We will be reusing some PMC code between phc2sys and ts2phc. In
preparation of that, we would like to extract the PMC related properties
of the current private program data structure of phc2sys, "struct node",
into something smaller that can be shared properly.

The "struct node" name is nice enough, so use that to denote the smaller
data structure for PMC from now on. Rename the bigger data structure to
phc2sys_private.

Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
---
 phc2sys.c | 433 ++++++++++++++++++++++++++++--------------------------
 1 file changed, 221 insertions(+), 212 deletions(-)

diff --git a/phc2sys.c b/phc2sys.c
index 64bdf26..a36cbe0 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -99,7 +99,7 @@ struct port {
 	struct clock *clock;
 };
 
-struct node {
+struct phc2sys_private {
 	unsigned int stats_max_count;
 	int sanity_freq_limit;
 	enum servo_type servo_type;
@@ -124,18 +124,21 @@ struct node {
 
 static struct config *phc2sys_config;
 
-static int update_pmc(struct node *node, int subscribe);
-static int clock_handle_leap(struct node *node, struct clock *clock,
+static int update_pmc(struct phc2sys_private *priv, int subscribe);
+static int clock_handle_leap(struct phc2sys_private *priv,
+			     struct clock *clock,
 			     int64_t offset, uint64_t ts);
-static int run_pmc_get_utc_offset(struct node *node, int timeout);
-static void run_pmc_events(struct node *node);
+static int run_pmc_get_utc_offset(struct phc2sys_private *priv,
+				  int timeout);
+static void run_pmc_events(struct phc2sys_private *priv);
 
 static int normalize_state(int state);
-static int run_pmc_port_properties(struct node *node, int timeout,
-				   unsigned int port,
+static int run_pmc_port_properties(struct phc2sys_private *priv,
+				   int timeout, unsigned int port,
 				   int *state, int *tstamping, char *iface);
 
-static struct servo *servo_add(struct node *node, struct clock *clock)
+static struct servo *servo_add(struct phc2sys_private *priv,
+			       struct clock *clock)
 {
 	double ppb;
 	int max_ppb;
@@ -157,19 +160,19 @@ static struct servo *servo_add(struct node *node, struct clock *clock)
 		}
 	}
 
-	servo = servo_create(phc2sys_config, node->servo_type,
+	servo = servo_create(phc2sys_config, priv->servo_type,
 			     -ppb, max_ppb, 0);
 	if (!servo) {
 		pr_err("Failed to create servo");
 		return NULL;
 	}
 
-	servo_sync_interval(servo, node->phc_interval);
+	servo_sync_interval(servo, priv->phc_interval);
 
 	return servo;
 }
 
-static struct clock *clock_add(struct node *node, char *device)
+static struct clock *clock_add(struct phc2sys_private *priv, char *device)
 {
 	struct clock *c;
 	clockid_t clkid = CLOCK_INVALID;
@@ -198,7 +201,7 @@ static struct clock *clock_add(struct node *node, char *device)
 		c->source_label = "phc";
 	}
 
-	if (node->stats_max_count > 0) {
+	if (priv->stats_max_count > 0) {
 		c->offset_stats = stats_create();
 		c->freq_stats = stats_create();
 		c->delay_stats = stats_create();
@@ -209,8 +212,8 @@ static struct clock *clock_add(struct node *node, char *device)
 			return NULL;
 		}
 	}
-	if (node->sanity_freq_limit) {
-		c->sanity_check = clockcheck_create(node->sanity_freq_limit);
+	if (priv->sanity_freq_limit) {
+		c->sanity_check = clockcheck_create(priv->sanity_freq_limit);
 		if (!c->sanity_check) {
 			pr_err("failed to create clock check");
 			return NULL;
@@ -218,21 +221,21 @@ static struct clock *clock_add(struct node *node, char *device)
 	}
 
 	if (clkid != CLOCK_INVALID)
-		c->servo = servo_add(node, c);
+		c->servo = servo_add(priv, c);
 
 	if (clkid != CLOCK_INVALID && clkid != CLOCK_REALTIME)
 		c->sysoff_method = sysoff_probe(CLOCKID_TO_FD(clkid),
-						node->phc_readings);
+						priv->phc_readings);
 
-	LIST_INSERT_HEAD(&node->clocks, c, list);
+	LIST_INSERT_HEAD(&priv->clocks, c, list);
 	return c;
 }
 
-static void clock_cleanup(struct node *node)
+static void clock_cleanup(struct phc2sys_private *priv)
 {
 	struct clock *c, *tmp;
 
-	LIST_FOREACH_SAFE(c, &node->clocks, list, tmp) {
+	LIST_FOREACH_SAFE(c, &priv->clocks, list, tmp) {
 		if (c->servo) {
 			servo_destroy(c->servo);
 		}
@@ -255,45 +258,45 @@ static void clock_cleanup(struct node *node)
 	}
 }
 
-static void port_cleanup(struct node *node)
+static void port_cleanup(struct phc2sys_private *priv)
 {
 	struct port *p, *tmp;
 
-	LIST_FOREACH_SAFE(p, &node->ports, list, tmp) {
+	LIST_FOREACH_SAFE(p, &priv->ports, list, tmp) {
 		free(p);
 	}
 }
 
-static struct port *port_get(struct node *node, unsigned int number)
+static struct port *port_get(struct phc2sys_private *priv, unsigned int number)
 {
 	struct port *p;
 
-	LIST_FOREACH(p, &node->ports, list) {
+	LIST_FOREACH(p, &priv->ports, list) {
 		if (p->number == number)
 			return p;
 	}
 	return NULL;
 }
 
-static struct port *port_add(struct node *node, unsigned int number,
+static struct port *port_add(struct phc2sys_private *priv, unsigned int number,
 			     char *device)
 {
 	struct port *p;
 	struct clock *c = NULL, *tmp;
 
-	p = port_get(node, number);
+	p = port_get(priv, number);
 	if (p)
 		return p;
 	/* port is a new one, look whether we have the device already on
 	 * a different port */
-	LIST_FOREACH(tmp, &node->clocks, list) {
+	LIST_FOREACH(tmp, &priv->clocks, list) {
 		if (!strcmp(tmp->device, device)) {
 			c = tmp;
 			break;
 		}
 	}
 	if (!c) {
-		c = clock_add(node, device);
+		c = clock_add(priv, device);
 		if (!c)
 			return NULL;
 	}
@@ -304,11 +307,12 @@ static struct port *port_add(struct node *node, unsigned int number,
 	}
 	p->number = number;
 	p->clock = c;
-	LIST_INSERT_HEAD(&node->ports, p, list);
+	LIST_INSERT_HEAD(&priv->ports, p, list);
 	return p;
 }
 
-static void clock_reinit(struct node *node, struct clock *clock, int new_state)
+static void clock_reinit(struct phc2sys_private *priv, struct clock *clock,
+			 int new_state)
 {
 	int phc_index = -1, phc_switched = 0;
 	int state, timestamping, ret = -1;
@@ -318,9 +322,9 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 	char iface[IFNAMSIZ];
 	clockid_t clkid = CLOCK_INVALID;
 
-	LIST_FOREACH(p, &node->ports, list) {
+	LIST_FOREACH(p, &priv->ports, list) {
 		if (p->clock == clock) {
-			ret = run_pmc_port_properties(node, 1000, p->number,
+			ret = run_pmc_port_properties(priv, 1000, p->number,
 					              &state, &timestamping,
 						      iface);
 			if (ret > 0)
@@ -345,7 +349,7 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 			clock->clkid = clkid;
 			clock->phc_index = phc_index;
 
-			servo = servo_add(node, clock);
+			servo = servo_add(priv, clock);
 			if (servo) {
 				servo_destroy(clock->servo);
 				clock->servo = servo;
@@ -367,9 +371,11 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 	}
 }
 
-static struct clock *find_dst_clock(struct node *node, int phc_index) {
+static struct clock *find_dst_clock(struct phc2sys_private *priv,
+				    int phc_index)
+{
 	struct clock *c = NULL;
-	LIST_FOREACH(c, &node->dst_clocks, dst_list) {
+	LIST_FOREACH(c, &priv->dst_clocks, dst_list) {
 		if (c->phc_index == phc_index) {
 			break;
 		}
@@ -377,26 +383,26 @@ static struct clock *find_dst_clock(struct node *node, int phc_index) {
 	return c;
 }
 
-static void reconfigure(struct node *node)
+static void reconfigure(struct phc2sys_private *priv)
 {
 	struct clock *c, *rt = NULL, *src = NULL, *last = NULL, *dup = NULL;
 	int src_cnt = 0, dst_cnt = 0;
 
 	pr_info("reconfiguring after port state change");
-	node->state_changed = 0;
+	priv->state_changed = 0;
 
-	while (node->dst_clocks.lh_first != NULL) {
-		LIST_REMOVE(node->dst_clocks.lh_first, dst_list);
+	while (priv->dst_clocks.lh_first != NULL) {
+		LIST_REMOVE(priv->dst_clocks.lh_first, dst_list);
 	}
 
-	LIST_FOREACH(c, &node->clocks, list) {
+	LIST_FOREACH(c, &priv->clocks, list) {
 		if (c->clkid == CLOCK_REALTIME) {
 			rt = c;
 			continue;
 		}
 
 		if (c->new_state) {
-			clock_reinit(node, c, c->new_state);
+			clock_reinit(priv, c, c->new_state);
 			c->state = c->new_state;
 			c->new_state = 0;
 		}
@@ -408,12 +414,12 @@ static void reconfigure(struct node *node)
 		case PS_PRE_MASTER:
 		case PS_MASTER:
 		case PS_PASSIVE:
-			dup = find_dst_clock(node, c->phc_index);
+			dup = find_dst_clock(priv, c->phc_index);
 			if (!dup) {
 				pr_info("selecting %s for synchronization",
 					c->device);
 				dst_cnt++;
-				LIST_INSERT_HEAD(&node->dst_clocks,
+				LIST_INSERT_HEAD(&priv->dst_clocks,
 						 c, dst_list);
 			} else {
 				pr_info("skipping %s: %s has the same clock "
@@ -433,10 +439,10 @@ static void reconfigure(struct node *node)
 	}
 	if (dst_cnt > 1 && !src) {
 		if (!rt || rt->dest_only) {
-			node->master = last;
+			priv->master = last;
 			/* Reset to original state in next reconfiguration. */
-			node->master->new_state = node->master->state;
-			node->master->state = PS_SLAVE;
+			priv->master->new_state = priv->master->state;
+			priv->master->state = PS_SLAVE;
 			if (rt)
 				rt->state = PS_SLAVE;
 			pr_info("no source, selecting %s as the default clock",
@@ -446,23 +452,23 @@ static void reconfigure(struct node *node)
 	}
 	if (src_cnt > 1) {
 		pr_info("multiple master clocks available, postponing sync...");
-		node->master = NULL;
+		priv->master = NULL;
 		return;
 	}
 	if (src_cnt > 0 && !src) {
 		pr_info("master clock not ready, waiting...");
-		node->master = NULL;
+		priv->master = NULL;
 		return;
 	}
 	if (!src_cnt && !dst_cnt) {
 		pr_info("no PHC ready, waiting...");
-		node->master = NULL;
+		priv->master = NULL;
 		return;
 	}
 	if ((!src_cnt && (!rt || rt->dest_only)) ||
 	    (!dst_cnt && !rt)) {
 		pr_info("nothing to synchronize");
-		node->master = NULL;
+		priv->master = NULL;
 		return;
 	}
 	if (!src_cnt) {
@@ -471,12 +477,12 @@ static void reconfigure(struct node *node)
 	} else if (rt) {
 		if (rt->state != PS_MASTER) {
 			rt->state = PS_MASTER;
-			clock_reinit(node, rt, rt->state);
+			clock_reinit(priv, rt, rt->state);
 		}
-		LIST_INSERT_HEAD(&node->dst_clocks, rt, dst_list);
+		LIST_INSERT_HEAD(&priv->dst_clocks, rt, dst_list);
 		pr_info("selecting %s for synchronization", rt->device);
 	}
-	node->master = src;
+	priv->master = src;
 	pr_info("selecting %s as the master clock", src->device);
 }
 
@@ -511,12 +517,12 @@ static int read_phc(clockid_t clkid, clockid_t sysclk, int readings,
 	return 1;
 }
 
-static int64_t get_sync_offset(struct node *node, struct clock *dst)
+static int64_t get_sync_offset(struct phc2sys_private *priv, struct clock *dst)
 {
-	int direction = node->forced_sync_offset;
+	int direction = priv->forced_sync_offset;
 
 	if (!direction)
-		direction = dst->is_utc - node->master->is_utc;
+		direction = dst->is_utc - priv->master->is_utc;
 	return (int64_t)dst->sync_offset * NS_PER_SEC * direction;
 }
 
@@ -559,16 +565,16 @@ static void update_clock_stats(struct clock *clock, unsigned int max_count,
 	stats_reset(clock->delay_stats);
 }
 
-static void update_clock(struct node *node, struct clock *clock,
+static void update_clock(struct phc2sys_private *priv, struct clock *clock,
 			 int64_t offset, uint64_t ts, int64_t delay)
 {
 	enum servo_state state;
 	double ppb;
 
-	if (clock_handle_leap(node, clock, offset, ts))
+	if (clock_handle_leap(priv, clock, offset, ts))
 		return;
 
-	offset += get_sync_offset(node, clock);
+	offset += get_sync_offset(priv, clock);
 
 	if (clock->sanity_check && clockcheck_sample(clock->sanity_check, ts))
 		servo_reset(clock->servo);
@@ -595,16 +601,16 @@ static void update_clock(struct node *node, struct clock *clock,
 	}
 
 	if (clock->offset_stats) {
-		update_clock_stats(clock, node->stats_max_count, offset, ppb, delay);
+		update_clock_stats(clock, priv->stats_max_count, offset, ppb, delay);
 	} else {
 		if (delay >= 0) {
 			pr_info("%s %s offset %9" PRId64 " s%d freq %+7.0f "
 				"delay %6" PRId64,
-				clock->device, node->master->source_label,
+				clock->device, priv->master->source_label,
 				offset, state, ppb, delay);
 		} else {
 			pr_info("%s %s offset %9" PRId64 " s%d freq %+7.0f",
-				clock->device, node->master->source_label,
+				clock->device, priv->master->source_label,
 				offset, state, ppb);
 		}
 	}
@@ -642,19 +648,20 @@ static int read_pps(int fd, int64_t *offset, uint64_t *ts)
 	return 1;
 }
 
-static int do_pps_loop(struct node *node, struct clock *clock, int fd)
+static int do_pps_loop(struct phc2sys_private *priv, struct clock *clock,
+		       int fd)
 {
 	int64_t pps_offset, phc_offset, phc_delay;
 	uint64_t pps_ts, phc_ts;
-	clockid_t src = node->master->clkid;
+	clockid_t src = priv->master->clkid;
 
-	node->master->source_label = "pps";
+	priv->master->source_label = "pps";
 
 	if (src == CLOCK_INVALID) {
 		/* The sync offset can't be applied with PPS alone. */
-		node->sync_offset = 0;
+		priv->sync_offset = 0;
 	} else {
-		enable_pps_output(node->master->clkid);
+		enable_pps_output(priv->master->clkid);
 	}
 
 	while (is_running()) {
@@ -665,7 +672,7 @@ static int do_pps_loop(struct node *node, struct clock *clock, int fd)
 		/* If a PHC is available, use it to get the whole number
 		   of seconds in the offset and PPS for the rest. */
 		if (src != CLOCK_INVALID) {
-			if (!read_phc(src, clock->clkid, node->phc_readings,
+			if (!read_phc(src, clock->clkid, priv->phc_readings,
 				      &phc_offset, &phc_ts, &phc_delay))
 				return -1;
 
@@ -683,9 +690,9 @@ static int do_pps_loop(struct node *node, struct clock *clock, int fd)
 			pps_offset = pps_ts - phc_ts;
 		}
 
-		if (update_pmc(node, 0) < 0)
+		if (update_pmc(priv, 0) < 0)
 			continue;
-		update_clock(node, clock, pps_offset, pps_ts, -1);
+		update_clock(priv, clock, pps_offset, pps_ts, -1);
 	}
 	close(fd);
 	return 0;
@@ -708,45 +715,45 @@ static int update_needed(struct clock *c)
 	return 0;
 }
 
-static int do_loop(struct node *node, int subscriptions)
+static int do_loop(struct phc2sys_private *priv, int subscriptions)
 {
 	struct timespec interval;
 	struct clock *clock;
 	uint64_t ts;
 	int64_t offset, delay;
 
-	interval.tv_sec = node->phc_interval;
-	interval.tv_nsec = (node->phc_interval - interval.tv_sec) * 1e9;
+	interval.tv_sec = priv->phc_interval;
+	interval.tv_nsec = (priv->phc_interval - interval.tv_sec) * 1e9;
 
 	while (is_running()) {
 		clock_nanosleep(CLOCK_MONOTONIC, 0, &interval, NULL);
-		if (update_pmc(node, subscriptions) < 0)
+		if (update_pmc(priv, subscriptions) < 0)
 			continue;
 
 		if (subscriptions) {
-			run_pmc_events(node);
-			if (node->state_changed) {
+			run_pmc_events(priv);
+			if (priv->state_changed) {
 				/* force getting offset, as it may have
 				 * changed after the port state change */
-				if (run_pmc_get_utc_offset(node, 1000) <= 0) {
+				if (run_pmc_get_utc_offset(priv, 1000) <= 0) {
 					pr_err("failed to get UTC offset");
 					continue;
 				}
-				reconfigure(node);
+				reconfigure(priv);
 			}
 		}
-		if (!node->master)
+		if (!priv->master)
 			continue;
 
-		LIST_FOREACH(clock, &node->dst_clocks, dst_list) {
+		LIST_FOREACH(clock, &priv->dst_clocks, dst_list) {
 			if (!update_needed(clock))
 				continue;
 
 			/* don't try to synchronize the clock to itself */
-			if (clock->clkid == node->master->clkid ||
+			if (clock->clkid == priv->master->clkid ||
 			    (clock->phc_index >= 0 &&
-			     clock->phc_index == node->master->phc_index) ||
-			    !strcmp(clock->device, node->master->device))
+			     clock->phc_index == priv->master->phc_index) ||
+			    !strcmp(clock->device, priv->master->device))
 				continue;
 
 			if (!clock->servo) {
@@ -755,41 +762,42 @@ static int do_loop(struct node *node, int subscriptions)
 			}
 
 			if (clock->clkid == CLOCK_REALTIME &&
-			    node->master->sysoff_method >= 0) {
+			    priv->master->sysoff_method >= 0) {
 				/* use sysoff */
-				if (sysoff_measure(CLOCKID_TO_FD(node->master->clkid),
-						   node->master->sysoff_method,
-						   node->phc_readings,
+				if (sysoff_measure(CLOCKID_TO_FD(priv->master->clkid),
+						   priv->master->sysoff_method,
+						   priv->phc_readings,
 						   &offset, &ts, &delay) < 0)
 					return -1;
-			} else if (node->master->clkid == CLOCK_REALTIME &&
+			} else if (priv->master->clkid == CLOCK_REALTIME &&
 				   clock->sysoff_method >= 0) {
 				/* use reversed sysoff */
 				if (sysoff_measure(CLOCKID_TO_FD(clock->clkid),
 						   clock->sysoff_method,
-						   node->phc_readings,
+						   priv->phc_readings,
 						   &offset, &ts, &delay) < 0)
 					return -1;
 				offset = -offset;
 				ts += offset;
 			} else {
 				/* use phc */
-				if (!read_phc(node->master->clkid, clock->clkid,
-					      node->phc_readings,
+				if (!read_phc(priv->master->clkid, clock->clkid,
+					      priv->phc_readings,
 					      &offset, &ts, &delay))
 					continue;
 			}
-			update_clock(node, clock, offset, ts, delay);
+			update_clock(priv, clock, offset, ts, delay);
 		}
 	}
 	return 0;
 }
 
-static int check_clock_identity(struct node *node, struct ptp_message *msg)
+static int check_clock_identity(struct phc2sys_private *priv,
+				struct ptp_message *msg)
 {
-	if (!node->clock_identity_set)
+	if (!priv->clock_identity_set)
 		return 1;
-	return cid_eq(&node->clock_identity,
+	return cid_eq(&priv->clock_identity,
 		       &msg->header.sourcePortIdentity.clockIdentity);
 }
 
@@ -841,12 +849,13 @@ static int normalize_state(int state)
 	return state;
 }
 
-static int clock_compute_state(struct node *node, struct clock *clock)
+static int clock_compute_state(struct phc2sys_private *priv,
+			       struct clock *clock)
 {
 	struct port *p;
 	int state = PS_DISABLED;
 
-	LIST_FOREACH(p, &node->ports, list) {
+	LIST_FOREACH(p, &priv->ports, list) {
 		if (p->clock != clock)
 			continue;
 		/* PS_SLAVE takes the highest precedence, PS_UNCALIBRATED
@@ -859,8 +868,8 @@ static int clock_compute_state(struct node *node, struct clock *clock)
 	return state;
 }
 
-static int recv_subscribed(struct node *node, struct ptp_message *msg,
-			   int excluded)
+static int recv_subscribed(struct phc2sys_private *priv,
+			   struct ptp_message *msg, int excluded)
 {
 	int mgt_id, state;
 	struct portDS *pds;
@@ -873,7 +882,7 @@ static int recv_subscribed(struct node *node, struct ptp_message *msg,
 	switch (mgt_id) {
 	case TLV_PORT_DATA_SET:
 		pds = get_mgt_data(msg);
-		port = port_get(node, pds->portIdentity.portNumber);
+		port = port_get(priv, pds->portIdentity.portNumber);
 		if (!port) {
 			pr_info("received data for unknown port %s",
 				pid2str(&pds->portIdentity));
@@ -885,10 +894,10 @@ static int recv_subscribed(struct node *node, struct ptp_message *msg,
 				pid2str(&pds->portIdentity));
 			port->state = state;
 			clock = port->clock;
-			state = clock_compute_state(node, clock);
+			state = clock_compute_state(priv, clock);
 			if (clock->state != state || clock->new_state) {
 				clock->new_state = state;
-				node->state_changed = 1;
+				priv->state_changed = 1;
 			}
 		}
 		return 1;
@@ -896,26 +905,26 @@ static int recv_subscribed(struct node *node, struct ptp_message *msg,
 	return 0;
 }
 
-static void send_subscription(struct node *node)
+static void send_subscription(struct phc2sys_private *priv)
 {
 	struct subscribe_events_np sen;
 
 	memset(&sen, 0, sizeof(sen));
 	sen.duration = PMC_SUBSCRIBE_DURATION;
 	sen.bitmask[0] = 1 << NOTIFY_PORT_STATE;
-	pmc_send_set_action(node->pmc, TLV_SUBSCRIBE_EVENTS_NP, &sen, sizeof(sen));
+	pmc_send_set_action(priv->pmc, TLV_SUBSCRIBE_EVENTS_NP, &sen, sizeof(sen));
 }
 
-static int init_pmc(struct config *cfg, struct node *node)
+static int init_pmc(struct config *cfg, struct phc2sys_private *priv)
 {
 	char uds_local[MAX_IFNAME_SIZE + 1];
 
 	snprintf(uds_local, sizeof(uds_local), "/var/run/phc2sys.%d",
 		 getpid());
-	node->pmc = pmc_create(cfg, TRANS_UDS, uds_local, 0,
+	priv->pmc = pmc_create(cfg, TRANS_UDS, uds_local, 0,
 			       config_get_int(cfg, NULL, "domainNumber"),
 			       config_get_int(cfg, NULL, "transportSpecific") << 4, 1);
-	if (!node->pmc) {
+	if (!priv->pmc) {
 		pr_err("failed to create pmc");
 		return -1;
 	}
@@ -929,7 +938,7 @@ static int init_pmc(struct config *cfg, struct node *node)
  * -1: error reported by the other side
  * -2: local error, fatal
  */
-static int run_pmc(struct node *node, int timeout, int ds_id,
+static int run_pmc(struct phc2sys_private *priv, int timeout, int ds_id,
 		   struct ptp_message **msg)
 {
 #define N_FD 1
@@ -937,9 +946,9 @@ static int run_pmc(struct node *node, int timeout, int ds_id,
 	int cnt, res;
 
 	while (1) {
-		pollfd[0].fd = pmc_get_transport_fd(node->pmc);
+		pollfd[0].fd = pmc_get_transport_fd(priv->pmc);
 		pollfd[0].events = POLLIN|POLLPRI;
-		if (!node->pmc_ds_requested && ds_id >= 0)
+		if (!priv->pmc_ds_requested && ds_id >= 0)
 			pollfd[0].events |= POLLOUT;
 
 		cnt = poll(pollfd, N_FD, timeout);
@@ -949,7 +958,7 @@ static int run_pmc(struct node *node, int timeout, int ds_id,
 		}
 		if (!cnt) {
 			/* Request the data set again in the next run. */
-			node->pmc_ds_requested = 0;
+			priv->pmc_ds_requested = 0;
 			return 0;
 		}
 
@@ -958,24 +967,24 @@ static int run_pmc(struct node *node, int timeout, int ds_id,
 		    !(pollfd[0].revents & (POLLIN|POLLPRI))) {
 			switch (ds_id) {
 			case TLV_SUBSCRIBE_EVENTS_NP:
-				send_subscription(node);
+				send_subscription(priv);
 				break;
 			default:
-				pmc_send_get_action(node->pmc, ds_id);
+				pmc_send_get_action(priv->pmc, ds_id);
 				break;
 			}
-			node->pmc_ds_requested = 1;
+			priv->pmc_ds_requested = 1;
 		}
 
 		if (!(pollfd[0].revents & (POLLIN|POLLPRI)))
 			continue;
 
-		*msg = pmc_recv(node->pmc);
+		*msg = pmc_recv(priv->pmc);
 
 		if (!*msg)
 			continue;
 
-		if (!check_clock_identity(node, *msg)) {
+		if (!check_clock_identity(priv, *msg)) {
 			msg_put(*msg);
 			*msg = NULL;
 			continue;
@@ -983,21 +992,21 @@ static int run_pmc(struct node *node, int timeout, int ds_id,
 
 		res = is_msg_mgt(*msg);
 		if (res < 0 && get_mgt_err_id(*msg) == ds_id) {
-			node->pmc_ds_requested = 0;
+			priv->pmc_ds_requested = 0;
 			return -1;
 		}
-		if (res <= 0 || recv_subscribed(node, *msg, ds_id) ||
+		if (res <= 0 || recv_subscribed(priv, *msg, ds_id) ||
 		    get_mgt_id(*msg) != ds_id) {
 			msg_put(*msg);
 			*msg = NULL;
 			continue;
 		}
-		node->pmc_ds_requested = 0;
+		priv->pmc_ds_requested = 0;
 		return 1;
 	}
 }
 
-static int run_pmc_wait_sync(struct node *node, int timeout)
+static int run_pmc_wait_sync(struct phc2sys_private *priv, int timeout)
 {
 	struct ptp_message *msg;
 	int res;
@@ -1005,7 +1014,7 @@ static int run_pmc_wait_sync(struct node *node, int timeout)
 	Enumeration8 portState;
 
 	while (1) {
-		res = run_pmc(node, timeout, TLV_PORT_DATA_SET, &msg);
+		res = run_pmc(priv, timeout, TLV_PORT_DATA_SET, &msg);
 		if (res <= 0)
 			return res;
 
@@ -1019,47 +1028,47 @@ static int run_pmc_wait_sync(struct node *node, int timeout)
 			return 1;
 		}
 		/* try to get more data sets (for other ports) */
-		node->pmc_ds_requested = 1;
+		priv->pmc_ds_requested = 1;
 	}
 }
 
-static int run_pmc_get_utc_offset(struct node *node, int timeout)
+static int run_pmc_get_utc_offset(struct phc2sys_private *priv, int timeout)
 {
 	struct ptp_message *msg;
 	int res;
 	struct timePropertiesDS *tds;
 
-	res = run_pmc(node, timeout, TLV_TIME_PROPERTIES_DATA_SET, &msg);
+	res = run_pmc(priv, timeout, TLV_TIME_PROPERTIES_DATA_SET, &msg);
 	if (res <= 0)
 		return res;
 
 	tds = (struct timePropertiesDS *)get_mgt_data(msg);
 	if (tds->flags & PTP_TIMESCALE) {
-		node->sync_offset = tds->currentUtcOffset;
+		priv->sync_offset = tds->currentUtcOffset;
 		if (tds->flags & LEAP_61)
-			node->leap = 1;
+			priv->leap = 1;
 		else if (tds->flags & LEAP_59)
-			node->leap = -1;
+			priv->leap = -1;
 		else
-			node->leap = 0;
-		node->utc_offset_traceable = tds->flags & UTC_OFF_VALID &&
+			priv->leap = 0;
+		priv->utc_offset_traceable = tds->flags & UTC_OFF_VALID &&
 					     tds->flags & TIME_TRACEABLE;
 	} else {
-		node->sync_offset = 0;
-		node->leap = 0;
-		node->utc_offset_traceable = 0;
+		priv->sync_offset = 0;
+		priv->leap = 0;
+		priv->utc_offset_traceable = 0;
 	}
 	msg_put(msg);
 	return 1;
 }
 
-static int run_pmc_get_number_ports(struct node *node, int timeout)
+static int run_pmc_get_number_ports(struct phc2sys_private *priv, int timeout)
 {
 	struct ptp_message *msg;
 	int res;
 	struct defaultDS *dds;
 
-	res = run_pmc(node, timeout, TLV_DEFAULT_DATA_SET, &msg);
+	res = run_pmc(priv, timeout, TLV_DEFAULT_DATA_SET, &msg);
 	if (res <= 0)
 		return res;
 
@@ -1069,26 +1078,26 @@ static int run_pmc_get_number_ports(struct node *node, int timeout)
 	return res;
 }
 
-static int run_pmc_subscribe(struct node *node, int timeout)
+static int run_pmc_subscribe(struct phc2sys_private *priv, int timeout)
 {
 	struct ptp_message *msg;
 	int res;
 
-	res = run_pmc(node, timeout, TLV_SUBSCRIBE_EVENTS_NP, &msg);
+	res = run_pmc(priv, timeout, TLV_SUBSCRIBE_EVENTS_NP, &msg);
 	if (res <= 0)
 		return res;
 	msg_put(msg);
 	return 1;
 }
 
-static void run_pmc_events(struct node *node)
+static void run_pmc_events(struct phc2sys_private *priv)
 {
 	struct ptp_message *msg;
 
-	run_pmc(node, 0, -1, &msg);
+	run_pmc(priv, 0, -1, &msg);
 }
 
-static int run_pmc_port_properties(struct node *node, int timeout,
+static int run_pmc_port_properties(struct phc2sys_private *priv, int timeout,
 				   unsigned int port,
 				   int *state, int *tstamping, char *iface)
 {
@@ -1096,9 +1105,9 @@ static int run_pmc_port_properties(struct node *node, int timeout,
 	int res, len;
 	struct port_properties_np *ppn;
 
-	pmc_target_port(node->pmc, port);
+	pmc_target_port(priv->pmc, port);
 	while (1) {
-		res = run_pmc(node, timeout, TLV_PORT_PROPERTIES_NP, &msg);
+		res = run_pmc(priv, timeout, TLV_PORT_PROPERTIES_NP, &msg);
 		if (res <= 0)
 			goto out;
 
@@ -1121,35 +1130,35 @@ static int run_pmc_port_properties(struct node *node, int timeout,
 		break;
 	}
 out:
-	pmc_target_all(node->pmc);
+	pmc_target_all(priv->pmc);
 	return res;
 }
 
-static int run_pmc_clock_identity(struct node *node, int timeout)
+static int run_pmc_clock_identity(struct phc2sys_private *priv, int timeout)
 {
 	struct ptp_message *msg;
 	struct defaultDS *dds;
 	int res;
 
-	res = run_pmc(node, timeout, TLV_DEFAULT_DATA_SET, &msg);
+	res = run_pmc(priv, timeout, TLV_DEFAULT_DATA_SET, &msg);
 	if (res <= 0)
 		return res;
 
 	dds = (struct defaultDS *)get_mgt_data(msg);
-	memcpy(&node->clock_identity, &dds->clockIdentity,
+	memcpy(&priv->clock_identity, &dds->clockIdentity,
 	       sizeof(struct ClockIdentity));
-	node->clock_identity_set = 1;
+	priv->clock_identity_set = 1;
 	msg_put(msg);
 	return 1;
 }
 
-static void close_pmc(struct node *node)
+static void close_pmc(struct phc2sys_private *priv)
 {
-	pmc_destroy(node->pmc);
-	node->pmc = NULL;
+	pmc_destroy(priv->pmc);
+	priv->pmc = NULL;
 }
 
-static int auto_init_ports(struct node *node, int add_rt)
+static int auto_init_ports(struct phc2sys_private *priv, int add_rt)
 {
 	struct port *port;
 	struct clock *clock;
@@ -1161,7 +1170,7 @@ static int auto_init_ports(struct node *node, int add_rt)
 	while (1) {
 		if (!is_running())
 			return -1;
-		res = run_pmc_clock_identity(node, 1000);
+		res = run_pmc_clock_identity(priv, 1000);
 		if (res < 0)
 			return -1;
 		if (res > 0)
@@ -1170,20 +1179,20 @@ static int auto_init_ports(struct node *node, int add_rt)
 		pr_notice("Waiting for ptp4l...");
 	}
 
-	number_ports = run_pmc_get_number_ports(node, 1000);
+	number_ports = run_pmc_get_number_ports(priv, 1000);
 	if (number_ports <= 0) {
 		pr_err("failed to get number of ports");
 		return -1;
 	}
 
-	res = run_pmc_subscribe(node, 1000);
+	res = run_pmc_subscribe(priv, 1000);
 	if (res <= 0) {
 		pr_err("failed to subscribe");
 		return -1;
 	}
 
 	for (i = 1; i <= number_ports; i++) {
-		res = run_pmc_port_properties(node, 1000, i, &state,
+		res = run_pmc_port_properties(priv, 1000, i, &state,
 					      &timestamping, iface);
 		if (res == -1) {
 			/* port does not exist, ignore the port */
@@ -1197,22 +1206,22 @@ static int auto_init_ports(struct node *node, int add_rt)
 			/* ignore ports with software time stamping */
 			continue;
 		}
-		port = port_add(node, i, iface);
+		port = port_add(priv, i, iface);
 		if (!port)
 			return -1;
 		port->state = normalize_state(state);
 	}
-	if (LIST_EMPTY(&node->clocks)) {
+	if (LIST_EMPTY(&priv->clocks)) {
 		pr_err("no suitable ports available");
 		return -1;
 	}
-	LIST_FOREACH(clock, &node->clocks, list) {
-		clock->new_state = clock_compute_state(node, clock);
+	LIST_FOREACH(clock, &priv->clocks, list) {
+		clock->new_state = clock_compute_state(priv, clock);
 	}
-	node->state_changed = 1;
+	priv->state_changed = 1;
 
 	if (add_rt) {
-		clock = clock_add(node, "CLOCK_REALTIME");
+		clock = clock_add(priv, "CLOCK_REALTIME");
 		if (!clock)
 			return -1;
 		if (add_rt == 1)
@@ -1220,7 +1229,7 @@ static int auto_init_ports(struct node *node, int add_rt)
 	}
 
 	/* get initial offset */
-	if (run_pmc_get_utc_offset(node, 1000) <= 0) {
+	if (run_pmc_get_utc_offset(priv, 1000) <= 0) {
 		pr_err("failed to get UTC offset");
 		return -1;
 	}
@@ -1228,7 +1237,7 @@ static int auto_init_ports(struct node *node, int add_rt)
 }
 
 /* Returns: -1 in case of error, 0 otherwise */
-static int update_pmc(struct node *node, int subscribe)
+static int update_pmc(struct phc2sys_private *priv, int subscribe)
 {
 	struct timespec tp;
 	uint64_t ts;
@@ -1239,33 +1248,33 @@ static int update_pmc(struct node *node, int subscribe)
 	}
 	ts = tp.tv_sec * NS_PER_SEC + tp.tv_nsec;
 
-	if (node->pmc &&
-	    !(ts > node->pmc_last_update &&
-	      ts - node->pmc_last_update < PMC_UPDATE_INTERVAL)) {
+	if (priv->pmc &&
+	    !(ts > priv->pmc_last_update &&
+	      ts - priv->pmc_last_update < PMC_UPDATE_INTERVAL)) {
 		if (subscribe)
-			run_pmc_subscribe(node, 0);
-		if (run_pmc_get_utc_offset(node, 0) > 0)
-			node->pmc_last_update = ts;
+			run_pmc_subscribe(priv, 0);
+		if (run_pmc_get_utc_offset(priv, 0) > 0)
+			priv->pmc_last_update = ts;
 	}
 
 	return 0;
 }
 
 /* Returns: non-zero to skip clock update */
-static int clock_handle_leap(struct node *node, struct clock *clock,
+static int clock_handle_leap(struct phc2sys_private *priv, struct clock *clock,
 			     int64_t offset, uint64_t ts)
 {
-	int clock_leap, node_leap = node->leap;
+	int clock_leap, node_leap = priv->leap;
 
-	clock->sync_offset = node->sync_offset;
+	clock->sync_offset = priv->sync_offset;
 
 	if ((node_leap || clock->leap_set) &&
-	    clock->is_utc != node->master->is_utc) {
+	    clock->is_utc != priv->master->is_utc) {
 		/* If the master clock is in UTC, get a time stamp from it, as
 		   it is the clock which will include the leap second. */
-		if (node->master->is_utc) {
+		if (priv->master->is_utc) {
 			struct timespec tp;
-			if (clock_gettime(node->master->clkid, &tp)) {
+			if (clock_gettime(priv->master->clkid, &tp)) {
 				pr_err("failed to read clock: %m");
 				return -1;
 			}
@@ -1275,7 +1284,7 @@ static int clock_handle_leap(struct node *node, struct clock *clock,
 		/* If the clock will be stepped, the time stamp has to be the
 		   new time. Ignore possible 1 second error in UTC offset. */
 		if (clock->is_utc && clock->servo_state == SERVO_UNLOCKED)
-			ts -= offset + get_sync_offset(node, clock);
+			ts -= offset + get_sync_offset(priv, clock);
 
 		/* Suspend clock updates in the last second before midnight. */
 		if (is_utc_ambiguous(ts)) {
@@ -1290,7 +1299,7 @@ static int clock_handle_leap(struct node *node, struct clock *clock,
 		if (clock->leap_set != clock_leap) {
 			/* Only the system clock can leap. */
 			if (clock->clkid == CLOCK_REALTIME &&
-			    node->kernel_leap)
+			    priv->kernel_leap)
 				sysclk_set_leap(clock_leap);
 			else
 				servo_leap(clock->servo, clock_leap);
@@ -1298,7 +1307,7 @@ static int clock_handle_leap(struct node *node, struct clock *clock,
 		}
 	}
 
-	if (node->utc_offset_traceable &&
+	if (priv->utc_offset_traceable &&
 	    clock->utc_offset_set != clock->sync_offset) {
 		if (clock->clkid == CLOCK_REALTIME)
 			sysclk_set_tai_offset(clock->sync_offset);
@@ -1358,7 +1367,7 @@ int main(int argc, char *argv[])
 	int autocfg = 0, c, domain_number = 0, index, ntpshm_segment;
 	int pps_fd = -1, print_level = LOG_INFO, r = -1, rt = 0, wait_sync = 0;
 	double phc_rate, tmp;
-	struct node node = {
+	struct phc2sys_private priv = {
 		.phc_readings = 5,
 		.phc_interval = 1.0,
 	};
@@ -1453,21 +1462,21 @@ int main(int argc, char *argv[])
 		case 'R':
 			if (get_arg_val_d(c, optarg, &phc_rate, 1e-9, DBL_MAX))
 				goto end;
-			node.phc_interval = 1.0 / phc_rate;
+			priv.phc_interval = 1.0 / phc_rate;
 			break;
 		case 'N':
-			if (get_arg_val_i(c, optarg, &node.phc_readings, 1, INT_MAX))
+			if (get_arg_val_i(c, optarg, &priv.phc_readings, 1, INT_MAX))
 				goto end;
 			break;
 		case 'O':
-			if (get_arg_val_i(c, optarg, &node.sync_offset,
+			if (get_arg_val_i(c, optarg, &priv.sync_offset,
 					  INT_MIN, INT_MAX))
 				goto end;
-			node.forced_sync_offset = -1;
+			priv.forced_sync_offset = -1;
 			break;
 		case 'L':
-			if (get_arg_val_i(c, optarg, &node.sanity_freq_limit, 0, INT_MAX) ||
-			    config_set_int(cfg, "sanity_freq_limit", node.sanity_freq_limit)) {
+			if (get_arg_val_i(c, optarg, &priv.sanity_freq_limit, 0, INT_MAX) ||
+			    config_set_int(cfg, "sanity_freq_limit", priv.sanity_freq_limit)) {
 				goto end;
 			}
 			break;
@@ -1477,7 +1486,7 @@ int main(int argc, char *argv[])
 				goto end;
 			break;
 		case 'u':
-			if (get_arg_val_ui(c, optarg, &node.stats_max_count,
+			if (get_arg_val_ui(c, optarg, &priv.stats_max_count,
 					  0, UINT_MAX))
 				goto end;
 			break;
@@ -1544,7 +1553,7 @@ int main(int argc, char *argv[])
 		return c;
 	}
 
-	if (autocfg && (src_name || dst_name || pps_fd >= 0 || wait_sync || node.forced_sync_offset)) {
+	if (autocfg && (src_name || dst_name || pps_fd >= 0 || wait_sync || priv.forced_sync_offset)) {
 		fprintf(stderr,
 			"autoconfiguration cannot be mixed with manual config options.\n");
 		goto bad_usage;
@@ -1555,15 +1564,15 @@ int main(int argc, char *argv[])
 		goto bad_usage;
 	}
 
-	if (!autocfg && !wait_sync && !node.forced_sync_offset) {
+	if (!autocfg && !wait_sync && !priv.forced_sync_offset) {
 		fprintf(stderr,
 			"time offset must be specified using -w or -O\n");
 		goto bad_usage;
 	}
 
-	if (node.servo_type == CLOCK_SERVO_NTPSHM) {
-		node.kernel_leap = 0;
-		node.sanity_freq_limit = 0;
+	if (priv.servo_type == CLOCK_SERVO_NTPSHM) {
+		priv.kernel_leap = 0;
+		priv.sanity_freq_limit = 0;
 	}
 
 	print_set_progname(progname);
@@ -1572,24 +1581,24 @@ int main(int argc, char *argv[])
 	print_set_syslog(config_get_int(cfg, NULL, "use_syslog"));
 	print_set_level(config_get_int(cfg, NULL, "logging_level"));
 
-	node.servo_type = config_get_int(cfg, NULL, "clock_servo");
-	if (node.servo_type == CLOCK_SERVO_NTPSHM) {
+	priv.servo_type = config_get_int(cfg, NULL, "clock_servo");
+	if (priv.servo_type == CLOCK_SERVO_NTPSHM) {
 		config_set_int(cfg, "kernel_leap", 0);
 		config_set_int(cfg, "sanity_freq_limit", 0);
 	}
-	node.kernel_leap = config_get_int(cfg, NULL, "kernel_leap");
-	node.sanity_freq_limit = config_get_int(cfg, NULL, "sanity_freq_limit");
+	priv.kernel_leap = config_get_int(cfg, NULL, "kernel_leap");
+	priv.sanity_freq_limit = config_get_int(cfg, NULL, "sanity_freq_limit");
 
 	if (autocfg) {
-		if (init_pmc(cfg, &node))
+		if (init_pmc(cfg, &priv))
 			goto end;
-		if (auto_init_ports(&node, rt) < 0)
+		if (auto_init_ports(&priv, rt) < 0)
 			goto end;
-		r = do_loop(&node, 1);
+		r = do_loop(&priv, 1);
 		goto end;
 	}
 
-	src = clock_add(&node, src_name);
+	src = clock_add(&priv, src_name);
 	free(src_name);
 	if (!src) {
 		fprintf(stderr,
@@ -1597,9 +1606,9 @@ int main(int argc, char *argv[])
 		goto bad_usage;
 	}
 	src->state = PS_SLAVE;
-	node.master = src;
+	priv.master = src;
 
-	dst = clock_add(&node, dst_name ? dst_name : "CLOCK_REALTIME");
+	dst = clock_add(&priv, dst_name ? dst_name : "CLOCK_REALTIME");
 	free(dst_name);
 	if (!dst) {
 		fprintf(stderr,
@@ -1607,7 +1616,7 @@ int main(int argc, char *argv[])
 		goto bad_usage;
 	}
 	dst->state = PS_MASTER;
-	LIST_INSERT_HEAD(&node.dst_clocks, dst, dst_list);
+	LIST_INSERT_HEAD(&priv.dst_clocks, dst, dst_list);
 
 	if (pps_fd >= 0 && dst->clkid != CLOCK_REALTIME) {
 		fprintf(stderr,
@@ -1618,11 +1627,11 @@ int main(int argc, char *argv[])
 	r = -1;
 
 	if (wait_sync) {
-		if (init_pmc(cfg, &node))
+		if (init_pmc(cfg, &priv))
 			goto end;
 
 		while (is_running()) {
-			r = run_pmc_wait_sync(&node, 1000);
+			r = run_pmc_wait_sync(&priv, 1000);
 			if (r < 0)
 				goto end;
 			if (r > 0)
@@ -1631,34 +1640,34 @@ int main(int argc, char *argv[])
 				pr_notice("Waiting for ptp4l...");
 		}
 
-		if (!node.forced_sync_offset) {
-			r = run_pmc_get_utc_offset(&node, 1000);
+		if (!priv.forced_sync_offset) {
+			r = run_pmc_get_utc_offset(&priv, 1000);
 			if (r <= 0) {
 				pr_err("failed to get UTC offset");
 				goto end;
 			}
 		}
 
-		if (node.forced_sync_offset ||
+		if (priv.forced_sync_offset ||
 		    (src->clkid != CLOCK_REALTIME && dst->clkid != CLOCK_REALTIME) ||
 		    src->clkid == CLOCK_INVALID)
-			close_pmc(&node);
+			close_pmc(&priv);
 	}
 
 	if (pps_fd >= 0) {
 		/* only one destination clock allowed with PPS until we
 		 * implement a mean to specify PTP port to PPS mapping */
 		servo_sync_interval(dst->servo, 1.0);
-		r = do_pps_loop(&node, dst, pps_fd);
+		r = do_pps_loop(&priv, dst, pps_fd);
 	} else {
-		r = do_loop(&node, 0);
+		r = do_loop(&priv, 0);
 	}
 
 end:
-	if (node.pmc)
-		close_pmc(&node);
-	clock_cleanup(&node);
-	port_cleanup(&node);
+	if (priv.pmc)
+		close_pmc(&priv);
+	clock_cleanup(&priv);
+	port_cleanup(&priv);
 	config_destroy(cfg);
 	msg_cleanup();
 	return r;
-- 
2.17.1


From 920ed85271a56cc0986d38d2541890d97736e03b Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 11:29:07 -0700
Subject: [PATCH 165/173] ts2phc: nmea: Correct UTC to TAI conversion.

The time value passed into the leap second lookup table should be in
seconds, but the calling code in the nmea module passes nanoseconds
instead.  This patch fixes the issue by converting the time value
accordingly.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 lstab.h              | 2 +-
 ts2phc_nmea_master.c | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/lstab.h b/lstab.h
index 7c5d918..d2393b4 100644
--- a/lstab.h
+++ b/lstab.h
@@ -54,7 +54,7 @@ enum lstab_result {
 /**
  * Returns the TAI - UTC offset for a given UTC time value.
  * @param lstab       A pointer obtained via lstab_create().
- * @param utctime     The UTC time value of interest.
+ * @param utctime     The UTC time value of interest, in seconds.
  * @param tai_offset  Pointer to a buffer to hold the result.
  * @return            One of the lstab_result enumeration values.
  */
diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index 2b9af3b..b217703 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -181,6 +181,7 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 	//
 	rmc = tmv_add(rmc, tmv_sub(local_t2, local_t1));
 	utc_time = tmv_to_nanoseconds(rmc);
+	utc_time /= (int64_t) 1000000000;
 	*ts = tmv_to_timespec(rmc);
 
 	result = lstab_utc2tai(m->lstab, utc_time, &tai_offset);
-- 
2.17.1


From 22b8d3f86d4c03466b10ee3c14feec7b59ab8fb3 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 11:54:35 -0700
Subject: [PATCH 166/173] ts2phc: nmea: Add error messages for leap second
 lookup failures.

If a leap second lookup fails, the likely reason is that the table is out
of date.  After all, the leap second table has an expiration date.  The
user will surely appreciate if the software complains loudly in this case.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_nmea_master.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index b217703..e89c2c7 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -190,7 +190,11 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 		lstab_error = 0;
 		break;
 	case LSTAB_UNKNOWN:
+		pr_err("nmea: unable to find utc time in leap second table");
+		lstab_error = -1;
+		break;
 	case LSTAB_AMBIGUOUS:
+		pr_err("nmea: utc time stamp is ambiguous");
 		lstab_error = -1;
 		break;
 	}
-- 
2.17.1


From 2d846120fee33fc80bb9e9064960bdef0146fbf3 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 11:59:12 -0700
Subject: [PATCH 167/173] ts2phc: nmea: Simplify validity checking.

If there is no valid fix reported by the RMC message, then calculation
of the PPS time stamp is pointless.  This patch simplifies the logic by
returning early in this case.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_nmea_master.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index e89c2c7..b8f7014 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -172,6 +172,11 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 
 	pthread_mutex_unlock(&m->mutex);
 
+	if (!fix_valid) {
+		pr_debug("nmea: no valid rmc fix");
+		return -1;
+	}
+
 	delay_t1 = rmc;
 	pr_debug("nmea delay: %" PRId64 " ns",
 		 tmv_to_nanoseconds(tmv_sub(delay_t2, delay_t1)));
@@ -200,7 +205,7 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 	}
 	ts->tv_sec += tai_offset;
 
-	return fix_valid ? lstab_error : -1;
+	return lstab_error;
 }
 
 struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *dev)
-- 
2.17.1


From 2bffe438ebb17853ab73996d97e7fa05f079bcf5 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 12:39:10 -0700
Subject: [PATCH 168/173] ts2phc: nmea: Add a configuration option for the
 current leap seconds file.

The PTP time scale is TAI, and a PTP GM needs to provide it.  However, most
GPS devices only provide UTC time of day information, and they do not, in
general, offer any kind of reliable, standardized leap seconds data.  After
all, this information is only broadcast every 12.5 minutes through the GPS
network, and that is far too long for a PTP GM to wait after startup.

This patch allows the built in leap seconds table to be overridden by an
up to date file provided in the environment.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 config.c             | 1 +
 ts2phc.8             | 8 ++++++++
 ts2phc_nmea_master.c | 2 +-
 3 files changed, 10 insertions(+), 1 deletion(-)

diff --git a/config.c b/config.c
index d3446b4..d237de9 100644
--- a/config.c
+++ b/config.c
@@ -260,6 +260,7 @@ struct config_item config_tab[] = {
 	PORT_ITEM_INT("inhibit_multicast_service", 0, 0, 1),
 	GLOB_ITEM_INT("initial_delay", 0, 0, INT_MAX),
 	GLOB_ITEM_INT("kernel_leap", 1, 0, 1),
+	GLOB_ITEM_STR("leapfile", NULL),
 	PORT_ITEM_INT("logAnnounceInterval", 1, INT8_MIN, INT8_MAX),
 	PORT_ITEM_INT("logMinDelayReqInterval", 0, INT8_MIN, INT8_MAX),
 	PORT_ITEM_INT("logMinPdelayReqInterval", 0, INT8_MIN, INT8_MAX),
diff --git a/ts2phc.8 b/ts2phc.8
index 07a4026..77f8940 100644
--- a/ts2phc.8
+++ b/ts2phc.8
@@ -116,6 +116,14 @@ This option can be useful in test scenarios, for example to determine
 how well synchronized a group of local clocks are to each other.
 The default is 0 (adjust the slave clocks).
 .TP
+.B leapfile
+The path to the current leap seconds definition file.
+In a Debian system this file is provided by the tzdata package and can
+be found at /usr/share/zoneinfo/leap-seconds.list.
+The default is an empty string, which causes the program to use a hard
+coded table that reflects the known leap seconds on the date of the
+software's release.
+.TP
 .B logging_level
 The maximum logging level of messages which should be printed.
 The default is 6 (LOG_INFO).
diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index b8f7014..76fc7ae 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -210,8 +210,8 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 
 struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *dev)
 {
+	const char *leapfile = config_get_string(cfg, NULL, "leapfile");
 	struct ts2phc_nmea_master *master;
-	const char *leapfile = NULL;	// TODO - read from config.
 	int err;
 
 	master = calloc(1, sizeof(*master));
-- 
2.17.1


From d16c7f899bff7a15dc97cb10a7e4b46b19944809 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 14:48:10 -0700
Subject: [PATCH 169/173] ts2phc: nmea: Clean up error path.

The error path does not clean up properly when allocations fail.  This
patch fixes the memory leaks on the error path.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_nmea_master.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index 76fc7ae..5c17e5a 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -220,6 +220,7 @@ struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *
 	}
 	master->lstab = lstab_create(leapfile);
 	if (!master->lstab) {
+		free(master);
 		return NULL;
 	}
 	master->master.destroy = ts2phc_nmea_master_destroy;
@@ -229,6 +230,7 @@ struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *
 	err = pthread_create(&master->worker, NULL, monitor_nmea_status, master);
 	if (err) {
 		pr_err("failed to create worker thread: %s", strerror(err));
+		lstab_destroy(master->lstab);
 		free(master);
 		return NULL;
 	}
-- 
2.17.1


From 74ed49e5a5b95659de4e9296c6e7085b2f65f5d7 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 14:55:21 -0700
Subject: [PATCH 170/173] ts2phc: nmea: Update the leap seconds table on
 demand.

If a leap seconds file is configured, the software will read the file once
on start up.  However, that file is nominally valid for a maximum of six
months.  This patch adds a check on the modification time of the file and
reloads the file if needed.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_nmea_master.c | 52 ++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 50 insertions(+), 2 deletions(-)

diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index 5c17e5a..247d239 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -7,6 +7,9 @@
 #include <pthread.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "config.h"
 #include "lstab.h"
@@ -26,6 +29,8 @@
 struct ts2phc_nmea_master {
 	struct ts2phc_master master;
 	struct config *config;
+	const char *leapfile;
+	time_t lsfile_mtime;
 	struct lstab *lstab;
 	pthread_t worker;
 	/* Protects anonymous struct fields, below, from concurrent access. */
@@ -138,6 +143,34 @@ static void *monitor_nmea_status(void *arg)
 	return NULL;
 }
 
+static int update_leapsecond_table(struct ts2phc_nmea_master *master)
+{
+	struct stat statbuf;
+	int err;
+
+	if (!master->leapfile) {
+		return 0;
+	}
+	err = stat(master->leapfile, &statbuf);
+	if (err) {
+		pr_err("nmea: file status failed on %s: %m", master->leapfile);
+		return -1;
+	}
+	if (master->lsfile_mtime == statbuf.st_mtim.tv_sec) {
+		return 0;
+	}
+	pr_info("nmea: updating leap seconds file");
+	if (master->lstab) {
+		lstab_destroy(master->lstab);
+	}
+	master->lstab = lstab_create(master->leapfile);
+	if (!master->lstab) {
+		return -1;
+	}
+	master->lsfile_mtime = statbuf.st_mtim.tv_sec;
+	return 0;
+}
+
 static void ts2phc_nmea_master_destroy(struct ts2phc_master *master)
 {
 	struct ts2phc_nmea_master *m =
@@ -189,6 +222,11 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 	utc_time /= (int64_t) 1000000000;
 	*ts = tmv_to_timespec(rmc);
 
+	if (update_leapsecond_table(m)) {
+		pr_err("nmea: failed to update leap seconds table");
+		return -1;
+	}
+
 	result = lstab_utc2tai(m->lstab, utc_time, &tai_offset);
 	switch (result) {
 	case LSTAB_OK:
@@ -210,19 +248,29 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 
 struct ts2phc_master *ts2phc_nmea_master_create(struct config *cfg, const char *dev)
 {
-	const char *leapfile = config_get_string(cfg, NULL, "leapfile");
 	struct ts2phc_nmea_master *master;
+	struct stat statbuf;
 	int err;
 
 	master = calloc(1, sizeof(*master));
 	if (!master) {
 		return NULL;
 	}
-	master->lstab = lstab_create(leapfile);
+	master->leapfile = config_get_string(cfg, NULL, "leapfile");
+	master->lstab = lstab_create(master->leapfile);
 	if (!master->lstab) {
 		free(master);
 		return NULL;
 	}
+	if (master->leapfile) {
+		err = stat(master->leapfile, &statbuf);
+		if (err) {
+			lstab_destroy(master->lstab);
+			free(master);
+			return NULL;
+		}
+		master->lsfile_mtime = statbuf.st_mtim.tv_sec;
+	}
 	master->master.destroy = ts2phc_nmea_master_destroy;
 	master->master.getppstime = ts2phc_nmea_master_getppstime;
 	master->config = cfg;
-- 
2.17.1


From 801a7b00df3ee67bb64c2087de1ecf353c6a90f5 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Mon, 21 Sep 2020 11:34:44 -0700
Subject: [PATCH 171/173] ts2phc: nmea: Drop time of day readings older than
 five seconds.

The nmea code estimates the device's current time by adding the duration
from the last reading as measured with the local montonic clock.  This
method is fine for a short duration, but the likely frequency offset
between the two clocks limits the long term accuracy.  In addition, if no
recent RMC record is available, probably some kind of error has occurred.
This patch limits the age of the RMC record used for ToD to five seconds.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 ts2phc_nmea_master.c | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/ts2phc_nmea_master.c b/ts2phc_nmea_master.c
index 247d239..b031e65 100644
--- a/ts2phc_nmea_master.c
+++ b/ts2phc_nmea_master.c
@@ -24,6 +24,7 @@
 #include "util.h"
 
 #define BAUD		9600
+#define MAX_RMC_AGE	5000000000ULL
 #define NMEA_TMO	2000 /*milliseconds*/
 
 struct ts2phc_nmea_master {
@@ -186,7 +187,7 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 {
 	struct ts2phc_nmea_master *m =
 		container_of(master, struct ts2phc_nmea_master, master);
-	tmv_t delay_t1, delay_t2, local_t1, local_t2, rmc;
+	tmv_t delay_t1, delay_t2, duration_since_rmc, local_t1, local_t2, rmc;
 	int lstab_error = 0, tai_offset = 0;
 	enum lstab_result result;
 	struct timespec now;
@@ -214,10 +215,12 @@ static int ts2phc_nmea_master_getppstime(struct ts2phc_master *master,
 	pr_debug("nmea delay: %" PRId64 " ns",
 		 tmv_to_nanoseconds(tmv_sub(delay_t2, delay_t1)));
 
-	//
-	// TODO - check that (local_t2 - local_t1) is smaller than X.
-	//
-	rmc = tmv_add(rmc, tmv_sub(local_t2, local_t1));
+	duration_since_rmc = tmv_sub(local_t2, local_t1);
+	if (tmv_to_nanoseconds(duration_since_rmc) > MAX_RMC_AGE) {
+		pr_err("nmea: rmc time stamp stale");
+		return -1;
+	}
+	rmc = tmv_add(rmc, duration_since_rmc);
 	utc_time = tmv_to_nanoseconds(rmc);
 	utc_time /= (int64_t) 1000000000;
 	*ts = tmv_to_timespec(rmc);
-- 
2.17.1


From 18393a1567cb83789e9fccf16c19401a7b53a4c8 Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Sun, 20 Sep 2020 12:02:18 -0700
Subject: [PATCH 172/173] lstab: Bring expiration up to date.

Bring the built in leap second table up to date through IERS Bulletin C59.
No new leap seconds have been scheduled for this year.

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 lstab.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lstab.c b/lstab.c
index 5fede16..391a6b9 100644
--- a/lstab.c
+++ b/lstab.c
@@ -48,7 +48,7 @@ struct lstab {
 	int length;
 };
 
-static const uint64_t expiration_date_ntp = 3802291200ULL; /* 28 June 2020 */
+static const uint64_t expiration_date_ntp = 3818102400ULL; /* 28 December 2020 */
 
 static const uint64_t offset_table[N_LEAPS * 2] = {
 	2272060800ULL,	10,	/* 1 Jan 1972 */
-- 
2.17.1


From 38ad3264f8726691c3fd0c97d0b34c8eee80c11b Mon Sep 17 00:00:00 2001
From: Richard Cochran <richardcochran@gmail.com>
Date: Fri, 25 Sep 2020 09:15:43 -0700
Subject: [PATCH 173/173] Version 3.1

Signed-off-by: Richard Cochran <richardcochran@gmail.com>
---
 version.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/version.sh b/version.sh
index 57dcd82..74e74d9 100755
--- a/version.sh
+++ b/version.sh
@@ -5,7 +5,7 @@
 # Adapted from scripts/setlocalversion in the Linux kernel sources.
 #
 major=3
-minor=0
+minor=1
 extra=
 
 usage() {
-- 
2.17.1

